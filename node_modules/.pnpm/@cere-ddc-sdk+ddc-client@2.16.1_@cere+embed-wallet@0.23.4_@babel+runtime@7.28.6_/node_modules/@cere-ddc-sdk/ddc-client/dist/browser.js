import{Cid as e,createLogger as t,UriSigner as s,Router as i,BalancedNode as n,bindErrorLogger as o,DEFAULT_PRESET as r,AuthToken as c,DagNode as a}from"@cere-ddc-sdk/ddc";export{AuthToken,AuthTokenOperation,CereWalletSigner,DEVNET,DagNode,DagNodeResponse,JsonSigner,KB,KeyringSigner,Link,MAINNET,MB,NodeError,StorageNodeMode,TESTNET,Tag,UriSigner,createCorrelationId}from"@cere-ddc-sdk/ddc";import{FileStorage as d,File as g}from"@cere-ddc-sdk/file-storage";export{File,FileResponse}from"@cere-ddc-sdk/file-storage";import{Blockchain as h}from"@cere-ddc-sdk/blockchain";function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var i in s)({}).hasOwnProperty.call(s,i)&&(e[i]=s[i])}return e},l.apply(null,arguments)}class u{constructor(t,s,i,n){this.cid="",this.name=void 0,this.bucketId=void 0,this.entity=void 0,this.name=null==n?void 0:n.name,this.bucketId=t,this.entity=i,e.isCid(s)?this.cid=s:null!=this.name||(this.name=s)}get cidOrName(){const e=this.cid||this.name;if(!e)throw new Error("Invalid DdcUri: both CID and Name are empty");return e}}class k extends u{constructor(e,t,s){super(e,t,"file",s)}}class b extends u{constructor(e,t,s){super(e,t,"dag-node",s)}}class f{constructor(e,c=r){this.ddcNode=void 0,this.blockchain=void 0,this.fileStorage=void 0,this.signer=void 0,this.logger=void 0;const a=t("DdcClient",c),g="string"==typeof c.blockchain?new h({wsEndpoint:c.blockchain}):c.blockchain,u="string"==typeof e?new s(e):e,k=new i(c.nodes?{signer:u,nodes:c.nodes,logger:a}:{signer:u,blockchain:g,logger:a});this.blockchain=g,this.signer=u,this.logger=a,this.ddcNode=new n(l({},c,{router:k,logger:a})),this.fileStorage=new d(k,l({},c,{logger:a})),a.debug(c,"DdcClient created"),!1!==c.logErrors&&o(this,this.logger,["getBalance","depositBalance","getDeposit","createBucket","getBucket","getBucketList","store","read","resolveName"])}static async create(e,t=r){return new f(e,t).connect()}async connect(){return await this.blockchain.isReady(),this}async disconnect(){return await this.blockchain.disconnect(),this}async getBalance(){this.logger.info("Getting the account balance %s",this.signer.address);const e=await this.blockchain.getAccountFreeBalance(this.signer.address);return this.logger.info("The account (%s) balance is %s",this.signer.address,e),e}async depositBalance(e,t,s={}){let i;return null===(!1===s.allowExtra?null:await this.blockchain.ddcCustomers.getStackingInfo(e,this.signer.address))?(this.logger.info("Depositing balance %s to %s for cluster %s",t,this.signer.address,e),i=this.blockchain.ddcCustomers.deposit(e,t)):(this.logger.info("Depositing extra balance %s to %s for cluster %s",t,this.signer.address,e),i=this.blockchain.ddcCustomers.depositExtra(e,t)),this.blockchain.send(i,{account:this.signer})}async depositBalanceFor(e,t,s){this.logger.info("Depositing balance %s for %s in cluster %s",s,e,t);const i=this.blockchain.ddcCustomers.depositFor(e,t,s);return this.blockchain.send(i,{account:this.signer})}async getDeposit(e,t){const s=t||this.signer.address;this.logger.info("Getting the account deposit %s for cluster %s",s,e);const i=await this.blockchain.ddcCustomers.getStackingInfo(e,s),n=BigInt((null==i?void 0:i.active)||0n);return this.logger.info("The account (%s) deposit for cluster %s is %s",s,e,n),n}async unlockDeposit(e,t){this.logger.info("Unlocking deposit %s for cluster %s",t,e);const s=this.blockchain.ddcCustomers.unlockDeposit(e,t);return this.blockchain.send(s,{account:this.signer})}async withdrawUnlockedDeposit(e){this.logger.info("Withdrawing unlocked deposit for cluster %s",e);const t=this.blockchain.ddcCustomers.withdrawUnlockedDeposit(e);return this.blockchain.send(t,{account:this.signer})}async createBucket(e,t={}){this.logger.info("Creating bucket on cluster %s",e);const s=await this.blockchain.send(this.blockchain.ddcCustomers.createBucket(e,l({},{isPublic:!1},t)),{account:this.signer}),[i]=this.blockchain.ddcCustomers.extractCreatedBucketIds(s.events);return this.logger.info("Bucket %s created in cluster %s in TX: %s",i,e,s.txHash),i}async getBucket(e){this.logger.info("Getting bucket %s",e);const t=await this.blockchain.ddcCustomers.getBucket(e);return this.logger.info("Got bucket %s",e),t}async getBucketList(){this.logger.info("Getting bucket list");const e=await this.blockchain.ddcCustomers.listBuckets();return this.logger.info("Got bucket list of lenght %s",e.length),e}async removeBuckets(...e){this.logger.info("Removing buckets %s",e);const t=await this.blockchain.send(this.blockchain.ddcCustomers.removeBuckets(...e),{account:this.signer}),s=this.blockchain.ddcCustomers.extractRemovedBucketIds(t.events);return this.logger.info("Buckets %s removed in TX: %s",s,t.txHash),s}bucketGet(e){return this.getBucket(e)}bucketList(){return this.getBucketList()}async grantAccess(e,t){return this.logger.info("Granting access to account %s",e),this.logger.debug({params:t},"Grant access params"),new c(l({},t,{subject:e})).sign(this.signer)}async store(e,t,s){if(this.logger.debug({entity:t,options:s},"Storing entity"),g.isFile(t)){const i=await this.fileStorage.store(e,t,s);return new k(e,i,s)}if(a.isDagNode(t)){const i=await this.storeDagNode(e,t,s);return new b(e,i,s)}throw new Error("`entity` argument is neither File nor DagNode")}async storeDagNode(e,t,s){return this.ddcNode.storeDagNode(e,t,s)}async read(e,t){if(this.logger.debug({uri:e,options:t},"Reading entity"),"file"===e.entity)return this.fileStorage.read(e.bucketId,e.cidOrName,t);if("dag-node"===e.entity)return this.ddcNode.getDagNode(e.bucketId,e.cidOrName,t);throw new Error("`uri` argument is neither FileUri or DagNodeUri")}async resolveName(e,t,s){return this.ddcNode.resolveName(e,t,s)}}export{b as DagNodeUri,f as DdcClient,u as DdcUri,k as FileUri};
//# sourceMappingURL=browser.js.map
