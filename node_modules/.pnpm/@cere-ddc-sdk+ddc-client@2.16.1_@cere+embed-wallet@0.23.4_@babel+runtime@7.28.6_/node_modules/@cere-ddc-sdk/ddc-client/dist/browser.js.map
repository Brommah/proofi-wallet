{"version":3,"file":"browser.js","sources":["../src/DdcUri.ts","../src/DdcClient.ts"],"sourcesContent":["import type { BucketId } from '@cere-ddc-sdk/blockchain';\nimport { Cid } from '@cere-ddc-sdk/ddc';\n\nexport type DdcEntity = 'file' | 'dag-node';\n\nexport type DdcUriOptions = {\n  name?: string;\n};\n\n/**\n * A generic representation of a DDC URI.\n *\n * @template T The type of the entity. Must extend DdcEntity.\n */\nexport class DdcUri<T extends DdcEntity = DdcEntity> {\n  /**\n   * The Content Identifier (CID) of the entity.\n   */\n  readonly cid: string = '';\n\n  /**\n   * The name of the entity.\n   */\n  readonly name?: string;\n\n  /**\n   * The bucket identifier.\n   */\n  readonly bucketId: BucketId;\n\n  /**\n   * The type of the entity.\n   */\n  readonly entity: T;\n\n  constructor(bucketId: BucketId, cidOrName: string, entity: T, options?: DdcUriOptions) {\n    this.name = options?.name;\n    this.bucketId = bucketId;\n    this.entity = entity;\n\n    if (Cid.isCid(cidOrName)) {\n      this.cid = cidOrName;\n    } else {\n      this.name ??= cidOrName;\n    }\n  }\n\n  /**\n   * The CID or name of the entity.\n   */\n  get cidOrName() {\n    const cidOrName = this.cid || this.name;\n\n    if (!cidOrName) {\n      throw new Error('Invalid DdcUri: both CID and Name are empty');\n    }\n\n    return cidOrName;\n  }\n}\n\n/**\n * Represents a URI for a file in DDC.\n *\n * A FileUri extends the DdcUri class with the entity type set to 'file'.\n *\n * @group Files\n * @extends DdcUri<'file'>\n */\nexport class FileUri extends DdcUri<'file'> {\n  constructor(bucketId: BucketId, cidOrName: string, options?: DdcUriOptions) {\n    super(bucketId, cidOrName, 'file', options);\n  }\n}\n\n/**\n * Represents a URI for a DAG (Directed Acyclic Graph) node in DDC.\n *\n * A DagNodeUri extends the DdcUri class with the entity type set to 'dag-node'.\n *\n * @group Directed Acyclic Graph (DAG)\n * @extends DdcUri<'dag-node'>\n */\nexport class DagNodeUri extends DdcUri<'dag-node'> {\n  constructor(bucketId: BucketId, cidOrName: string, options?: DdcUriOptions) {\n    super(bucketId, cidOrName, 'dag-node', options);\n  }\n}\n","import {\n  DagNode,\n  DagNodeResponse,\n  Router,\n  Signer,\n  UriSigner,\n  DagNodeStoreOptions,\n  ConfigPreset,\n  DagNodeGetOptions,\n  DEFAULT_PRESET,\n  Logger,\n  createLogger,\n  bindErrorLogger,\n  NodeInterface,\n  BalancedNode,\n  AuthTokenParams,\n  AuthToken,\n  BalancedNodeConfig,\n  CnsRecordGetOptions,\n} from '@cere-ddc-sdk/ddc';\nimport { FileStorage, File, FileStoreOptions, FileResponse, FileReadOptions } from '@cere-ddc-sdk/file-storage';\nimport { AccountId, Blockchain, BucketId, BucketParams, ClusterId, Sendable } from '@cere-ddc-sdk/blockchain';\n\nimport { DagNodeUri, DdcUri, FileUri } from './DdcUri';\n\nexport type DdcClientConfig = Omit<BalancedNodeConfig, 'router'> &\n  Omit<ConfigPreset, 'blockchain'> & {\n    blockchain: Blockchain | ConfigPreset['blockchain'];\n  };\n\ntype DepositBalanceOptions = {\n  allowExtra?: boolean;\n};\n\n/**\n * `DdcClient` is a class that provides methods to interact with the DDC.\n *\n * It provides methods to manage buckets, grant access, and store and read files and DAG nodes.\n */\nexport class DdcClient {\n  private readonly ddcNode: NodeInterface;\n  private readonly blockchain: Blockchain;\n  private readonly fileStorage: FileStorage;\n  private readonly signer: Signer;\n  private readonly logger: Logger;\n\n  constructor(uriOrSigner: Signer | string, config: DdcClientConfig = DEFAULT_PRESET) {\n    const logger = createLogger('DdcClient', config);\n    const blockchain =\n      typeof config.blockchain === 'string' ? new Blockchain({ wsEndpoint: config.blockchain }) : config.blockchain;\n\n    const signer = typeof uriOrSigner === 'string' ? new UriSigner(uriOrSigner) : uriOrSigner;\n    const router = config.nodes\n      ? new Router({ signer, nodes: config.nodes, logger })\n      : new Router({ signer, blockchain, logger });\n\n    this.blockchain = blockchain;\n    this.signer = signer;\n    this.logger = logger;\n    this.ddcNode = new BalancedNode({ ...config, router, logger });\n    this.fileStorage = new FileStorage(router, { ...config, logger });\n\n    logger.debug(config, 'DdcClient created');\n\n    if (config.logErrors !== false) {\n      bindErrorLogger(this, this.logger, [\n        'getBalance',\n        'depositBalance',\n        'getDeposit',\n        'createBucket',\n        'getBucket',\n        'getBucketList',\n        'store',\n        'read',\n        'resolveName',\n      ]);\n    }\n  }\n\n  /**\n   * Creates a new instance of the DdcClient.\n   *\n   * @param uriOrSigner - A Signer instance or a [substrate URI](https://polkadot.js.org/docs/keyring/start/suri).\n   * @param config - Configuration options for the DdcClient. Defaults to TESTNET.\n   *\n   * @returns A promise that resolves to a new instance of the DdcClient.\n   *\n   * @example\n   *\n   * ```typescript\n   * const ddcClient = await DdcClient.create('//Alice', DEVNET);\n   * ```\n   *\n   * ```typescript\n   * const ddcClient = await DdcClient.create('//Alice', {\n   *   blockchain: 'wss://devnet.cere.network',\n   *   retries: 3,\n   * });\n   * ```\n   */\n  static async create(uriOrSigner: Signer | string, config: DdcClientConfig = DEFAULT_PRESET) {\n    const client = new DdcClient(uriOrSigner, config);\n\n    return client.connect();\n  }\n\n  async connect() {\n    await this.blockchain.isReady();\n\n    return this;\n  }\n\n  async disconnect() {\n    await this.blockchain.disconnect();\n\n    return this;\n  }\n\n  /**\n   * Retrieves the current free balance of the account.\n   *\n   * @returns A promise that resolves to the current balance of the account.\n   *\n   * @example\n   * ```typescript\n   * const balance = await ddcClient.getBalance();\n   *\n   * console.log(balance);\n   * ```\n   * */\n  async getBalance() {\n    this.logger.info('Getting the account balance %s', this.signer.address);\n    const balance = await this.blockchain.getAccountFreeBalance(this.signer.address);\n    this.logger.info('The account (%s) balance is %s', this.signer.address, balance);\n\n    return balance;\n  }\n\n  /**\n   * Deposits a specified amount of tokens to the account for a specific cluster. The account must have enough tokens to cover the deposit.\n   *\n   * @param clusterId - The ID of the cluster to deposit tokens for.\n   * @param amount - The amount of tokens to deposit.\n   * @param options - Additional options for the deposit.\n   *\n   * @returns A promise that resolves to the transaction hash of the deposit.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId: ClusterId = '0x...';\n   * const amount = 100n;\n   * const txHash = await ddcClient.depositBalance(clusterId, amount);\n   *\n   * console.log(txHash);\n   * ```\n   * */\n  async depositBalance(clusterId: ClusterId, amount: bigint, options: DepositBalanceOptions = {}) {\n    let tx: Sendable;\n    const currentDeposit =\n      options.allowExtra === false\n        ? null\n        : await this.blockchain.ddcCustomers.getStackingInfo(clusterId, this.signer.address);\n\n    if (currentDeposit === null) {\n      this.logger.info('Depositing balance %s to %s for cluster %s', amount, this.signer.address, clusterId);\n      tx = this.blockchain.ddcCustomers.deposit(clusterId, amount);\n    } else {\n      this.logger.info('Depositing extra balance %s to %s for cluster %s', amount, this.signer.address, clusterId);\n      tx = this.blockchain.ddcCustomers.depositExtra(clusterId, amount);\n    }\n\n    return this.blockchain.send(tx, { account: this.signer });\n  }\n\n  /**\n   * Deposits a specified amount of tokens to the target address for a specific cluster.\n   * This allows depositing funds on behalf of another address.\n   *\n   * @param targetAddress - The target address to deposit funds for.\n   * @param clusterId - The ID of the cluster to deposit tokens for.\n   * @param amount - The amount of tokens to deposit.\n   *\n   * @returns A promise that resolves to the transaction hash of the deposit.\n   *\n   * @example\n   *\n   * ```typescript\n   * const targetAddress = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const clusterId: ClusterId = '0x...';\n   * const amount = 100n;\n   * const txHash = await ddcClient.depositBalanceFor(targetAddress, clusterId, amount);\n   *\n   * console.log(txHash);\n   * ```\n   * */\n  async depositBalanceFor(targetAddress: AccountId, clusterId: ClusterId, amount: bigint) {\n    this.logger.info('Depositing balance %s for %s in cluster %s', amount, targetAddress, clusterId);\n    const tx = this.blockchain.ddcCustomers.depositFor(targetAddress, clusterId, amount);\n    return this.blockchain.send(tx, { account: this.signer });\n  }\n\n  /**\n   * Retrieves the current active deposit of the account for a specific cluster.\n   *\n   * @param clusterId - The ID of the cluster to get deposit for.\n   * @param accountId - Optional account ID. If not provided, uses the signer's address.\n   *\n   * @returns A promise that resolves to the current active deposit of the account.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId: ClusterId = '0x...';\n   * const deposit = await ddcClient.getDeposit(clusterId);\n   *\n   * console.log(deposit);\n   * ```\n   * */\n  async getDeposit(clusterId: ClusterId, accountId?: AccountId) {\n    const targetAccountId = accountId || this.signer.address;\n    this.logger.info('Getting the account deposit %s for cluster %s', targetAccountId, clusterId);\n    const info = await this.blockchain.ddcCustomers.getStackingInfo(clusterId, targetAccountId);\n    const deposit = BigInt(info?.active || 0n);\n    this.logger.info('The account (%s) deposit for cluster %s is %s', targetAccountId, clusterId, deposit);\n\n    return deposit;\n  }\n\n  /**\n   * Unlocks deposit funds from the account for the specified cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param amount - The amount to unlock.\n   *\n   * @returns A promise that resolves to the transaction hash.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId: ClusterId = '0x...';\n   * const amount = 100n;\n   * const txHash = await ddcClient.unlockDeposit(clusterId, amount);\n   *\n   * console.log(txHash);\n   * ```\n   * */\n  async unlockDeposit(clusterId: ClusterId, amount: bigint) {\n    this.logger.info('Unlocking deposit %s for cluster %s', amount, clusterId);\n    const tx = this.blockchain.ddcCustomers.unlockDeposit(clusterId, amount);\n    return this.blockchain.send(tx, { account: this.signer });\n  }\n\n  /**\n   * Withdraws unlocked funds from the account for the specified cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   *\n   * @returns A promise that resolves to the transaction hash.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId: ClusterId = '0x...';\n   * const txHash = await ddcClient.withdrawUnlockedDeposit(clusterId);\n   *\n   * console.log(txHash);\n   * ```\n   * */\n  async withdrawUnlockedDeposit(clusterId: ClusterId) {\n    this.logger.info('Withdrawing unlocked deposit for cluster %s', clusterId);\n    const tx = this.blockchain.ddcCustomers.withdrawUnlockedDeposit(clusterId);\n    return this.blockchain.send(tx, { account: this.signer });\n  }\n\n  /**\n   * Creates a new bucket on a specified cluster.\n   *\n   * @param clusterId - The ID of the cluster where the bucket will be created.\n   * @param params - Optional parameters for the new bucket. Defaults to an empty object.\n   *                 Currently, the only parameter is `isPublic`, which defaults to `false`.\n   *\n   * @returns A promise that resolves to the ID of the newly created bucket.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId: ClusterId = '0x...';\n   * const bucketId: BucketId = await ddcClient.createBucket(clusterId, {\n   *   isPublic: true,\n   * });\n   * ```\n   */\n  async createBucket(clusterId: ClusterId, params: Partial<BucketParams> = {}) {\n    this.logger.info('Creating bucket on cluster %s', clusterId);\n    const defaultParams: BucketParams = {\n      isPublic: false,\n    };\n\n    const response = await this.blockchain.send(\n      this.blockchain.ddcCustomers.createBucket(clusterId, { ...defaultParams, ...params }),\n      { account: this.signer },\n    );\n\n    const [bucketId] = this.blockchain.ddcCustomers.extractCreatedBucketIds(response.events);\n    this.logger.info('Bucket %s created in cluster %s in TX: %s', bucketId, clusterId, response.txHash);\n\n    return bucketId;\n  }\n\n  /**\n   * Retrieves information about a specific bucket by its ID.\n   *\n   * @param bucketId - The ID of the bucket to retrieve.\n   *\n   * @returns A promise that resolves to the bucket information.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: BucketId = 1n;\n   * const bucket = await ddcClient.getBucket(bucketId);\n   *\n   * console.log(bucket);\n   * ```\n   */\n  async getBucket(bucketId: BucketId) {\n    this.logger.info('Getting bucket %s', bucketId);\n    const bucket = await this.blockchain.ddcCustomers.getBucket(bucketId);\n    this.logger.info('Got bucket %s', bucketId);\n\n    return bucket;\n  }\n\n  /**\n   * Retrieves a list of all available buckets.\n   *\n   * @returns A promise that resolves to an array of buckets.\n   *\n   * @example\n   *\n   * ```typescript\n   * const buckets = await ddcClient.getBucketList();\n   *\n   * console.log(buckets);\n   * ```\n   */\n  async getBucketList() {\n    this.logger.info('Getting bucket list');\n    const list = await this.blockchain.ddcCustomers.listBuckets();\n    this.logger.info('Got bucket list of lenght %s', list.length);\n\n    return list;\n  }\n\n  /**\n   * Mark existing buckets with specified bucket ids as removed.\n   *\n   * @param bucketIds - The IDs of the buckets to remove.\n   * @returns A promise that resolves to the IDs of the removed buckets.\n   *\n   * @example\n   *\n   * ```typescript\n   * const removedBucketIds = await ddcClient.removeBucket(1, 2, 3);\n   * ```\n   */\n  async removeBuckets(...bucketIds: BucketId[]) {\n    this.logger.info('Removing buckets %s', bucketIds);\n\n    const response = await this.blockchain.send(this.blockchain.ddcCustomers.removeBuckets(...bucketIds), {\n      account: this.signer,\n    });\n\n    const removedBucketIds = this.blockchain.ddcCustomers.extractRemovedBucketIds(response.events);\n    this.logger.info('Buckets %s removed in TX: %s', removedBucketIds, response.txHash);\n\n    return removedBucketIds;\n  }\n\n  /**\n   * @deprecated Use `getBucket` instead\n   */\n  bucketGet(bucketId: BucketId) {\n    return this.getBucket(bucketId);\n  }\n\n  /**\n   * @deprecated Use `getBucketList` instead\n   */\n  bucketList() {\n    return this.getBucketList();\n  }\n\n  /**\n   * Grants access to a bucket to a specific account.\n   *\n   * @param subject - The account ID to grant access to.\n   * @param params - The parameters for the access being granted.\n   *\n   * @returns A new AuthToken that the subject account can use to access the bucket.\n   *\n   * @example\n   *\n   * ```typescript\n   * const subject: AccountId = '0x...';\n   * const authToken = await ddcClient.grantAccess(subject, {\n   *   bucketId: 1n,\n   *   operations: [AuthTokenOperation.GET],\n   * });\n   *\n   * console.log(authToken.toString());\n   * ```\n   */\n  async grantAccess(subject: AccountId, params: Omit<AuthTokenParams, 'subject'>) {\n    this.logger.info('Granting access to account %s', subject);\n    this.logger.debug({ params }, 'Grant access params');\n\n    return new AuthToken({ ...params, subject }).sign(this.signer);\n  }\n\n  /**\n   * Stores a file or DAG node in a specific bucket.\n   *\n   * @param bucketId - The ID of the bucket to store the entity in.\n   * @param entity - The file or DAG node to store.\n   * @param options - Optional parameters for storing the entity.\n   *\n   * @returns A promise that resolves to a URI for the stored entity.\n   *\n   * @throws Will throw an error if the `entity` argument is neither a File nor a DagNode.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: BucketId = 1n;\n   * const fileContent = ...;\n   * const file: File = new File(fileContent, { size: 1000 });\n   * const fileUri = await ddcClient.store(bucketId, file);\n   *\n   * console.log(fileUri);\n   * ```\n   */\n  async store(bucketId: BucketId, entity: File, options?: FileStoreOptions): Promise<FileUri>;\n  async store(bucketId: BucketId, entity: DagNode, options?: DagNodeStoreOptions): Promise<DagNodeUri>;\n  async store(bucketId: BucketId, entity: File | DagNode, options?: FileStoreOptions | DagNodeStoreOptions) {\n    this.logger.debug({ entity, options }, 'Storing entity');\n\n    if (File.isFile(entity)) {\n      const cid = await this.fileStorage.store(bucketId, entity, options);\n\n      return new FileUri(bucketId, cid, options);\n    }\n\n    if (DagNode.isDagNode(entity)) {\n      const cid = await this.storeDagNode(bucketId, entity, options);\n\n      return new DagNodeUri(bucketId, cid, options);\n    }\n\n    throw new Error('`entity` argument is neither File nor DagNode');\n  }\n\n  private async storeDagNode(bucketId: BucketId, node: DagNode, options?: DagNodeStoreOptions) {\n    return this.ddcNode.storeDagNode(bucketId, node, options);\n  }\n\n  /**\n   * Reads a file or DAG node from a specific URI.\n   *\n   * @param uri - The URI of the file or DAG node to read.\n   * @param options - Optional parameters for reading the entity.\n   *\n   * @returns A promise that resolves to the file or DAG node response.\n   *\n   * @example\n   *\n   * ```typescript\n   * const fileUri = new FileUri(bucketId, cid);\n   * const fileResponse = await ddcClient.read(fileUri);\n   * const textContent = await fileResponse.text();\n   *\n   * console.log(textContent);\n   * ```\n   */\n  async read(uri: FileUri, options?: FileReadOptions): Promise<FileResponse>;\n  async read(uri: DagNodeUri, options?: DagNodeGetOptions): Promise<DagNodeResponse>;\n  async read(uri: DdcUri, options?: FileReadOptions | DagNodeGetOptions) {\n    this.logger.debug({ uri, options }, 'Reading entity');\n\n    if (uri.entity === 'file') {\n      return this.fileStorage.read(uri.bucketId, uri.cidOrName, options as FileReadOptions);\n    }\n\n    if (uri.entity === 'dag-node') {\n      return this.ddcNode.getDagNode(uri.bucketId, uri.cidOrName, options as DagNodeGetOptions);\n    }\n\n    throw new Error('`uri` argument is neither FileUri or DagNodeUri');\n  }\n\n  /**\n   * Resolves a CNS name to a specific CID.\n   *\n   * @param bucketId - The ID of the bucket to resolve the CNS name in.\n   * @param cnsName - The CNS name to resolve.\n   *\n   * @returns A promise that resolves to the CID of the CNS name.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: BucketId = 1n;\n   * const cnsName = 'my-file';\n   * const cid = await ddcClient.resolveName(bucketId, cnsName);\n   *\n   * console.log(cid);\n   * ```\n   */\n  async resolveName(bucketId: BucketId, cnsName: string, options?: CnsRecordGetOptions) {\n    return this.ddcNode.resolveName(bucketId, cnsName, options);\n  }\n}\n"],"names":["DdcUri","constructor","bucketId","cidOrName","entity","options","this","cid","name","Cid","isCid","Error","FileUri","super","DagNodeUri","DdcClient","uriOrSigner","config","DEFAULT_PRESET","ddcNode","blockchain","fileStorage","signer","logger","createLogger","Blockchain","wsEndpoint","UriSigner","router","Router","nodes","BalancedNode","_extends","FileStorage","debug","logErrors","bindErrorLogger","create","connect","isReady","disconnect","getBalance","info","address","balance","getAccountFreeBalance","depositBalance","clusterId","amount","tx","allowExtra","ddcCustomers","getStackingInfo","deposit","depositExtra","send","account","depositBalanceFor","targetAddress","depositFor","getDeposit","accountId","targetAccountId","BigInt","active","unlockDeposit","withdrawUnlockedDeposit","createBucket","params","response","defaultParams","isPublic","extractCreatedBucketIds","events","txHash","getBucket","bucket","getBucketList","list","listBuckets","length","removeBuckets","bucketIds","removedBucketIds","extractRemovedBucketIds","bucketGet","bucketList","grantAccess","subject","AuthToken","sign","store","File","isFile","DagNode","isDagNode","storeDagNode","node","read","uri","getDagNode","resolveName","cnsName"],"mappings":"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"}