import { Options as RetryOptions } from 'async-retry';
import { BucketId } from '@cere-ddc-sdk/blockchain';
import { Router } from '../routing';
import { Piece, MultipartPiece } from '../Piece';
import { DagNode } from '../DagNode';
import { CnsRecord } from '../CnsRecord';
import { LoggerOptions } from '../logger';
import { DagNodeGetOptions, DagNodeStoreOptions, PieceReadOptions, PieceStoreOptions, NodeInterface, CnsRecordGetOptions } from './NodeInterface';
/**
 * The timeouts bettween retries are exponential, starting at `minTimeout` and increasing each time until `maxTimeout`.
 *
 * The formuka for the timeout between retries is:
 *
 * ```typescript
 * const timeout = Math.min(random * minTimeout * Math.pow(factor, attempt), maxTimeout);
 * ```
 */
export type OpperationRetryOptions = Omit<RetryOptions, 'retries'> & {
    attempts?: number;
};
export type BalancedNodeConfig = LoggerOptions & {
    router: Router;
    retries?: number | OpperationRetryOptions;
};
/**
 * The `BalancedNode` class implements the `NodeInterface` and provides methods for interacting with storage nodes.
 *
 * A balanced node is a node that distributes operations across multiple underlying nodes to balance the load.
 *
 * @group Storage Node
 * @example
 *
 * ```typescript
 * const router = new Router(...);
 * const balancedNode = new BalancedNode({ router });
 * ```
 */
export declare class BalancedNode implements NodeInterface {
    readonly nodeId = "BalancedNode";
    readonly displayName = "BalancedNode";
    private router;
    private logger;
    private retryOptions;
    constructor({ router, ...config }: BalancedNodeConfig);
    /**
     * Executes a function with automatic retry on failure.
     *
     * @param fn - The function to execute.
     * @param options - Optional parameters for retrying the function.
     *
     * @returns A promise that resolves to the result of the function.
     */
    private withRetry;
    storePiece(bucketId: BucketId, piece: Piece | MultipartPiece, storeOptions?: PieceStoreOptions): Promise<string>;
    readPiece(bucketId: BucketId, cidOrName: string, readOptions?: PieceReadOptions): Promise<import("../Piece").PieceResponse>;
    storeDagNode(bucketId: BucketId, dagNode: DagNode, storeOptions?: DagNodeStoreOptions): Promise<string>;
    getDagNode(bucketId: BucketId, cidOrName: string, getOptions?: DagNodeGetOptions): Promise<import("../DagNode").DagNodeResponse | undefined>;
    storeCnsRecord(bucketId: BucketId, record: CnsRecord, storeOptions?: DagNodeStoreOptions): Promise<import("../CnsApi").Record>;
    getCnsRecord(bucketId: BucketId, name: string, getOptions?: CnsRecordGetOptions): Promise<import("../CnsRecord").CnsRecordResponse | undefined>;
    resolveName(bucketId: BucketId, cidOrName: string, resolveOptions?: CnsRecordGetOptions): Promise<import("..").Cid>;
}
//# sourceMappingURL=BalancedNode.d.ts.map