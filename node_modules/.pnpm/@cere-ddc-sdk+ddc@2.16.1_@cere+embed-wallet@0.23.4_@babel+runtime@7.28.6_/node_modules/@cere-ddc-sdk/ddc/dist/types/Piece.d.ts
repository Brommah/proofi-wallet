import { Content, ContentStream } from './streams';
import { ReadFileRange } from './FileApi';
import { Cid } from './Cid';
type StaticPieceMeta = {
    multipartOffset?: number;
    size?: number;
};
type StreamPieceMeta = {
    multipartOffset?: number;
    size: number;
};
export type PieceMeta = StaticPieceMeta;
export type MultipartPieceMeta = {
    partSize: number;
    totalSize: number;
};
export type PieceResponseMeta = {
    range?: ReadFileRange;
};
/**
 * The `Piece` class represents a piece of content.
 *
 * @group Files
 *
 * @example
 *
 * ```typescript
 * const content = new Uint8Array([1, 2, 3]);
 * const piece = new Piece(content, { size: 3 });
 *
 * console.log(Piece.isPiece(piece)); // true
 * ```
 */
export declare class Piece {
    private contentLength?;
    protected content: Content;
    /**
     * The offset of the piece in a multipart upload.
     */
    offset?: number;
    /**
     * The content of the piece as a stream.
     */
    readonly body: ContentStream;
    /**
     * The metadata for the piece.
     */
    readonly meta: PieceMeta;
    constructor(content: Content, meta: StreamPieceMeta);
    constructor(content: Uint8Array, meta?: StaticPieceMeta);
    /**
     * Checks if the piece is part of a multipart upload.
     */
    get isPart(): boolean;
    /**
     * The size of the piece.
     */
    get size(): number;
    /**
     * Checks if an object is an instance of `Piece`.
     *
     * @param object - The object to check.
     *
     * @returns `true` if the object is an instance of `Piece` or has the same properties as a `Piece`, `false` otherwise.
     */
    static isPiece(object: unknown): object is Piece;
    /**
     * Checks if an object is an instance of `Piece` with static content.
     *
     * @param object - The object to check.
     *
     * @returns `true` if the object is an instance of `Piece` and its content is a `Uint8Array`, `false` otherwise.
     */
    static isStaticPiece(object: unknown): object is Piece;
    /**
     * Creates a new `Piece` from an existing one.
     *
     * @param piece - The existing `Piece` to create a new one from.
     *
     * @returns A new `Piece` with the same content and metadata as the existing one.
     */
    static from(piece: Piece): Piece;
}
/**
 * The `MultipartPiece` class represents a piece cobined from multiple parts (raw pieces).
 *
 * @group Files
 *
 * @example
 *
 * ```typescript
 * const parts = ['CID1', 'CID2'];
 * const multipartPiece = new MultipartPiece(parts, {
 *  partSize: 1024,
 *  totalSize: 2048,
 * });
 *
 * console.log(MultipartPiece.isMultipartPiece(multipartPiece)); // true
 * ```
 */
export declare class MultipartPiece {
    /**
     * The hashes of the parts of the multipart piece.
     */
    readonly partHashes: Uint8Array[];
    /**
     * The metadata of the multipart piece.
     */
    readonly meta: MultipartPieceMeta;
    /**
     * The parts of the multipart piece.
     */
    readonly parts: string[];
    constructor(parts: string[], meta: MultipartPieceMeta);
    /**
     * Checks if an object is an instance of `MultipartPiece`.
     *
     * @param object - The object to check.
     *
     * @returns `true` if the object is an instance of `MultipartPiece` or has the same properties as a `MultipartPiece`, `false` otherwise.
     */
    static isMultipartPiece(object: unknown): object is MultipartPiece;
}
/**
 * The `PieceResponse` class represents a response for a piece content.
 *
 * @group Files
 */
export declare class PieceResponse {
    protected cidObject: Cid;
    protected meta?: PieceResponseMeta;
    /**
     * The content of the piece response as a stream.
     */
    readonly body: ContentStream;
    constructor(cid: string | Uint8Array | Cid, body: ContentStream, meta?: PieceResponseMeta);
    /**
     * The range of the piece response.
     */
    get range(): ReadFileRange;
    /**
     * The hash of the piece response content.
     */
    get hash(): Uint8Array<ArrayBuffer>;
    /**
     * The content identifier (CID) of the piece.
     */
    get cid(): string;
    /**
     * Converts the body stream of the piece to an `ArrayBuffer`.
     *
     * @returns The piece content as an `ArrayBuffer`.
     */
    arrayBuffer(): Promise<ArrayBuffer>;
    /**
     * Converts the body stream of the piece to a string.
     *
     * @returns The piece content as a string.
     */
    text(): Promise<string>;
    /**
     * Converts the body stream of the piece to a JSON object.
     *
     * @returns The piece content as a JSON object.
     */
    json(): Promise<unknown>;
}
export {};
//# sourceMappingURL=Piece.d.ts.map