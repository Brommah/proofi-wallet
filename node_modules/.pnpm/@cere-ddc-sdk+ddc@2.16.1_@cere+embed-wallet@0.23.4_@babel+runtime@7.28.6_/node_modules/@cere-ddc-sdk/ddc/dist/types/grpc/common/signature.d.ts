import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message common.Signature
 */
export interface Signature {
    /**
     * @generated from protobuf field: common.Signature.Algorithm algorithm = 1;
     */
    algorithm: Signature_Algorithm;
    /**
     * @generated from protobuf field: bytes signer = 2;
     */
    signer: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 3;
     */
    value: Uint8Array;
}
/**
 * @generated from protobuf enum common.Signature.Algorithm
 */
export declare enum Signature_Algorithm {
    /**
     * @generated from protobuf enum value: ED_25519 = 0;
     */
    ED_25519 = 0,
    /**
     * @generated from protobuf enum value: SR_25519 = 1;
     */
    SR_25519 = 1
}
declare class Signature$Type extends MessageType<Signature> {
    constructor();
    create(value?: PartialMessage<Signature>): Signature;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Signature): Signature;
    internalBinaryWrite(message: Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message common.Signature
 */
export declare const Signature: Signature$Type;
export {};
//# sourceMappingURL=signature.d.ts.map