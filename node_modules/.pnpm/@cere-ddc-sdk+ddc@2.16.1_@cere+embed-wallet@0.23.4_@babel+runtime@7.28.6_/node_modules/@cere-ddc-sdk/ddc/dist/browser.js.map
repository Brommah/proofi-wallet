{"version":3,"file":"browser.js","sources":["../src/auth/createRpcMeta.ts","../src/grpc/status.ts","../src/constants.ts","../src/grpc/common/signature.ts","../src/signature/mapSignature.ts","../src/signature/createSignature.ts","../src/grpc/auth_token.ts","../../../node_modules/multiformats/dist/src/bases/base.js","../../../node_modules/multiformats/dist/src/bases/base32.js","../src/Cid.ts","../src/auth/AuthToken.ts","../src/auth/sdkToken.ts","../src/logger/createLogger.web.ts","../src/logger/bindErrorLogger.ts","../src/grpc/cns_api.ts","../src/grpc/cns_api.client.ts","../src/grpc/activity_report/activity_report.ts","../src/activity/createActivityRequest.ts","../src/activity/createAck.ts","../src/activity/createRpcMeta.ts","../src/activity/createCorrelationId.ts","../src/CnsApi/CnsApi.ts","../src/grpc/dag_api.ts","../src/grpc/dag_api.client.ts","../src/validators/CidValidator.ts","../src/validators/FileValidator.ts","../src/validators/DagNodeValidator.ts","../src/DagApi/DagApi.ts","../src/streams/streams.web.ts","../src/streams/createStream.ts","../src/streams/consumers.web.ts","../src/grpc/file_api.ts","../src/grpc/file_api.client.ts","../src/FileApi/FileApi.ts","../src/transports/GrpcTransport.web.ts","../../../node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js","../src/transports/TimeoutInterceptor.ts","../src/transports/WebsocketTransport.ts","../src/transports/DefaultTransport.web.ts","../src/Piece.ts","../src/DagNode.ts","../src/CnsRecord.ts","../src/nodes/StorageNode.ts","../src/routing/RoutingStrategy.ts","../src/routing/BaseStrategy.web.ts","../src/routing/NodeTypeStrategy.ts","../src/routing/PingStrategy.ts","../src/routing/RandomStrategy.ts","../src/routing/BlockchainStrategy.ts","../src/routing/StaticStrategy.ts","../src/routing/Router.ts","../src/nodes/NodeError.ts","../src/nodes/BalancedNode.ts","../src/presets.ts"],"sourcesContent":["import { RpcMetadata } from '@protobuf-ts/runtime-rpc';\nimport { AuthToken } from './AuthToken';\n\nexport type AuthMetaParams = { token?: AuthToken };\n\nexport const createRpcMeta = (token?: AuthToken, meta?: RpcMetadata): RpcMetadata => {\n  const authMeta: RpcMetadata = {};\n  if (token) {\n    authMeta.token = token.toString();\n  }\n\n  return { ...meta, ...authMeta };\n};\n","export enum GrpcStatus {\n  OK = 0,\n  CANCELLED = 1,\n  UNKNOWN = 2,\n  INVALID_ARGUMENT = 3,\n  DEADLINE_EXCEEDED = 4,\n  NOT_FOUND = 5,\n  ALREADY_EXISTS = 6,\n  PERMISSION_DENIED = 7,\n  RESOURCE_EXHAUSTED = 8,\n  FAILED_PRECONDITION = 9,\n  ABORTED = 10,\n  OUT_OF_RANGE = 11,\n  UNIMPLEMENTED = 12,\n  INTERNAL = 13,\n  UNAVAILABLE = 14,\n  DATA_LOSS = 15,\n  UNAUTHENTICATED = 16,\n}\n","import { GrpcStatus } from './grpc/status';\n\nexport const KB = 1024;\nexport const MB = 1024 * KB;\n\n/**\n * Minimum size of a piece of content, in bytes.\n *\n * @hidden\n */\nexport const MIN_PIECE_SIZE = 4 * MB;\n\n/**\n * Maximum size of a piece of content, in bytes.\n *\n * @hidden\n */\nexport const MAX_PIECE_SIZE = 128 * MB;\n\n/**\n * Size of a chunk of a content stream, in bytes.\n * 4 MB (recomended gRPC message size) minus 100 KB reserved for the message structure.\n */\nexport const CONTENT_CHUNK_SIZE = 4 * MB - 100 * KB;\n\n/**\n * Default port for HTTPS connections.\n */\nexport const HTTPS_DEFAULT_PORT = 443;\n\n/**\n * Expiration time for an authentication token, in milliseconds.\n * This is set to one month.\n */\nexport const AUTH_TOKEN_EXPIRATION_TIME = 30 * 24 * 60 * 60 * 1000;\n\n/**\n * Default inactivity timeout for gRPC requests, in milliseconds.\n * This is set to 30 seconds.\n */\nexport const GRPC_REQUEST_INACTIVITY_TIMEOUT = 30 * 1000;\n\n/**\n * gRPC error codes that should trigger a retry of the operation.\n */\nexport const RETRYABLE_GRPC_ERROR_CODES = [\n  GrpcStatus.UNAVAILABLE,\n  GrpcStatus.DEADLINE_EXCEEDED,\n  GrpcStatus.RESOURCE_EXHAUSTED,\n  GrpcStatus.ABORTED,\n  GrpcStatus.INTERNAL,\n  GrpcStatus.UNKNOWN,\n\n  /**\n   * GRPC library uses this error code when a request is cancelled using abort signals, and it does not respect `AbortSignal.reason`.\n   * Currently there is no way to cancel a request using the SDK API. So the only possible source of this errors is internal timeout logic.\n   *\n   * TODO: If we let developers to cancel requests, we should handle this error code or figure out a way to avoid re-trying.\n   */\n  GrpcStatus.CANCELLED,\n];\n\n/**\n * Maximum number of attempts to retry an operation.\n */\nexport const RETRY_MAX_ATTEPTS = 5;\n\n/**\n * Minimum number of nodes to ping before any DDC operation.\n */\nexport const PING_THRESHOLD = 10;\n\n/**\n * Number of additional nodes to ping in the background after each operation.\n */\nexport const PING_THRESHOLD_INC = 2;\n\n/**\n * Coefficient in milliseconds to group nodes by latency.\n */\nexport const PING_LATENCY_GROUP = 100;\n\n/**\n * Delay in milliseconds before starting background pings after an operation.\n */\nexport const PING_BACKGROUND_DELAY = 100;\n\n/**\n * Timeout in milliseconds for aborting a ping request.\n */\nexport const PING_ABORT_TIMEOUT = 1000;\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"common/signature.proto\" (package \"common\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message common.Signature\n */\nexport interface Signature {\n    /**\n     * @generated from protobuf field: common.Signature.Algorithm algorithm = 1;\n     */\n    algorithm: Signature_Algorithm;\n    /**\n     * @generated from protobuf field: bytes signer = 2;\n     */\n    signer: Uint8Array;\n    /**\n     * @generated from protobuf field: bytes value = 3;\n     */\n    value: Uint8Array;\n}\n/**\n * @generated from protobuf enum common.Signature.Algorithm\n */\nexport enum Signature_Algorithm {\n    /**\n     * @generated from protobuf enum value: ED_25519 = 0;\n     */\n    ED_25519 = 0,\n    /**\n     * @generated from protobuf enum value: SR_25519 = 1;\n     */\n    SR_25519 = 1\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Signature$Type extends MessageType<Signature> {\n    constructor() {\n        super(\"common.Signature\", [\n            { no: 1, name: \"algorithm\", kind: \"enum\", T: () => [\"common.Signature.Algorithm\", Signature_Algorithm] },\n            { no: 2, name: \"signer\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"value\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Signature>): Signature {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.algorithm = 0;\n        message.signer = new Uint8Array(0);\n        message.value = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<Signature>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Signature): Signature {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* common.Signature.Algorithm algorithm */ 1:\n                    message.algorithm = reader.int32();\n                    break;\n                case /* bytes signer */ 2:\n                    message.signer = reader.bytes();\n                    break;\n                case /* bytes value */ 3:\n                    message.value = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* common.Signature.Algorithm algorithm = 1; */\n        if (message.algorithm !== 0)\n            writer.tag(1, WireType.Varint).int32(message.algorithm);\n        /* bytes signer = 2; */\n        if (message.signer.length)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.signer);\n        /* bytes value = 3; */\n        if (message.value.length)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.value);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message common.Signature\n */\nexport const Signature = new Signature$Type();\n","import { type SignerType, encodeAddress } from '@cere-ddc-sdk/blockchain';\n\nimport { Signature as ApiSignature, Signature_Algorithm as SigAlg } from '../grpc/common/signature';\n\nexport type Signature = Omit<ApiSignature, 'algorithm' | 'signer'> & {\n  signer: string;\n  algorithm: SignerType;\n};\n\nexport const mapSignature = (signature: ApiSignature): Signature => ({\n  algorithm: signature.algorithm === SigAlg.SR_25519 ? 'sr25519' : 'ed25519',\n  signer: encodeAddress(signature.signer),\n  value: new Uint8Array(signature.value),\n});\n","import type { Signer } from '@cere-ddc-sdk/blockchain';\n\nimport { Signature, Signature_Algorithm as SigAlg } from '../grpc/common/signature';\nimport { AuthToken, maybeSdkSigner } from '../auth';\n\nexport type ApiSignature = Signature;\n\nexport type CreateSignatureOptions = {\n  token?: string | AuthToken;\n};\n\nexport const createSignature = async (signer: Signer, message: Uint8Array, { token }: CreateSignatureOptions = {}) => {\n  const proxySigner = maybeSdkSigner(signer, token);\n\n  await proxySigner.isReady();\n\n  if (proxySigner.type !== 'ed25519' && proxySigner.type !== 'sr25519') {\n    throw new Error(`Signer type ${proxySigner.type} is not allowed in DDC`);\n  }\n\n  return Signature.create({\n    algorithm: proxySigner.type === 'ed25519' ? SigAlg.ED_25519 : SigAlg.SR_25519,\n    signer: proxySigner.publicKey,\n    value: await proxySigner.sign(message),\n  });\n};\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"auth_token.proto\" (syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Signature } from \"./common/signature\";\n/**\n * Token represents trust chain of tokens where first token is verifiable by bucket access on chain and last token is generated by the client that sends a request\n *\n * @generated from protobuf message AuthToken\n */\nexport interface AuthToken {\n    /**\n     * @generated from protobuf field: common.Signature signature = 1;\n     */\n    signature?: Signature; // signature signer is an issuer. issuer of first token should have an access on pallet level and subsequent tokens can skip 'issuer' and take 'subject' from previous token to verify signature\n    /**\n     * @generated from protobuf field: Payload payload = 2;\n     */\n    payload?: Payload;\n}\n/**\n * @generated from protobuf message Payload\n */\nexport interface Payload {\n    /**\n     * @generated from protobuf field: optional AuthToken prev = 1;\n     */\n    prev?: AuthToken; // prev token in trust chain (based on known use cases max depth can be limited to 3 or increase to 5 to support more potential use cases)\n    /**\n     * @generated from protobuf field: optional bytes subject = 2;\n     */\n    subject?: Uint8Array; // whom. every except last token should be non empty. next token should be signed by this subject\n    /**\n     * @generated from protobuf field: optional bool canDelegate = 3;\n     */\n    canDelegate?: boolean; // subject can be prohibited to delegate access to anyone else (next token should be last)\n    /**\n     * @generated from protobuf field: optional uint64 bucketId = 4 [jstype = JS_NORMAL];\n     */\n    bucketId?: bigint; // mentioned only once in trust chain (or even not mentioned at all if bucket owner decided to share access to all his buckets)\n    /**\n     * @generated from protobuf field: repeated Operation operations = 5;\n     */\n    operations: Operation[]; // each next token in trust chain should have less or equal privileges (e.g. token restricted to 'get' operation can't have 'put' in next token)\n    /**\n     * @generated from protobuf field: optional int64 expiresAt = 6;\n     */\n    expiresAt?: number; // each next token should expires earlier or at the same time as previous one (e.g. token can't have lower expiresAt than in next token)\n    /**\n     * @generated from protobuf field: optional bytes pieceCid = 7;\n     */\n    pieceCid?: Uint8Array; // mentioned only once in trust chain (in DAG API nested pieces can be accessed by path)\n}\n/**\n * @generated from protobuf enum Operation\n */\nexport enum Operation {\n    /**\n     * @generated from protobuf enum value: UNKNOWN = 0;\n     */\n    UNKNOWN = 0,\n    /**\n     * @generated from protobuf enum value: PUT = 1;\n     */\n    PUT = 1,\n    /**\n     * @generated from protobuf enum value: GET = 2;\n     */\n    GET = 2,\n    /**\n     * @generated from protobuf enum value: DELETE = 3;\n     */\n    DELETE = 3\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass AuthToken$Type extends MessageType<AuthToken> {\n    constructor() {\n        super(\"AuthToken\", [\n            { no: 1, name: \"signature\", kind: \"message\", T: () => Signature },\n            { no: 2, name: \"payload\", kind: \"message\", T: () => Payload }\n        ]);\n    }\n    create(value?: PartialMessage<AuthToken>): AuthToken {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<AuthToken>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthToken): AuthToken {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* common.Signature signature */ 1:\n                    message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);\n                    break;\n                case /* Payload payload */ 2:\n                    message.payload = Payload.internalBinaryRead(reader, reader.uint32(), options, message.payload);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: AuthToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* common.Signature signature = 1; */\n        if (message.signature)\n            Signature.internalBinaryWrite(message.signature, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* Payload payload = 2; */\n        if (message.payload)\n            Payload.internalBinaryWrite(message.payload, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message AuthToken\n */\nexport const AuthToken = new AuthToken$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Payload$Type extends MessageType<Payload> {\n    constructor() {\n        super(\"Payload\", [\n            { no: 1, name: \"prev\", kind: \"message\", T: () => AuthToken },\n            { no: 2, name: \"subject\", kind: \"scalar\", opt: true, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"canDelegate\", kind: \"scalar\", opt: true, T: 8 /*ScalarType.BOOL*/ },\n            { no: 4, name: \"bucketId\", kind: \"scalar\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 5, name: \"operations\", kind: \"enum\", repeat: 1 /*RepeatType.PACKED*/, T: () => [\"Operation\", Operation] },\n            { no: 6, name: \"expiresAt\", kind: \"scalar\", opt: true, T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 7, name: \"pieceCid\", kind: \"scalar\", opt: true, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Payload>): Payload {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.operations = [];\n        if (value !== undefined)\n            reflectionMergePartial<Payload>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payload): Payload {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* optional AuthToken prev */ 1:\n                    message.prev = AuthToken.internalBinaryRead(reader, reader.uint32(), options, message.prev);\n                    break;\n                case /* optional bytes subject */ 2:\n                    message.subject = reader.bytes();\n                    break;\n                case /* optional bool canDelegate */ 3:\n                    message.canDelegate = reader.bool();\n                    break;\n                case /* optional uint64 bucketId = 4 [jstype = JS_NORMAL];*/ 4:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* repeated Operation operations */ 5:\n                    if (wireType === WireType.LengthDelimited)\n                        for (let e = reader.int32() + reader.pos; reader.pos < e;)\n                            message.operations.push(reader.int32());\n                    else\n                        message.operations.push(reader.int32());\n                    break;\n                case /* optional int64 expiresAt */ 6:\n                    message.expiresAt = reader.int64().toNumber();\n                    break;\n                case /* optional bytes pieceCid */ 7:\n                    message.pieceCid = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Payload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* optional AuthToken prev = 1; */\n        if (message.prev)\n            AuthToken.internalBinaryWrite(message.prev, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* optional bytes subject = 2; */\n        if (message.subject !== undefined)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.subject);\n        /* optional bool canDelegate = 3; */\n        if (message.canDelegate !== undefined)\n            writer.tag(3, WireType.Varint).bool(message.canDelegate);\n        /* optional uint64 bucketId = 4 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== undefined)\n            writer.tag(4, WireType.Varint).uint64(message.bucketId);\n        /* repeated Operation operations = 5; */\n        if (message.operations.length) {\n            writer.tag(5, WireType.LengthDelimited).fork();\n            for (let i = 0; i < message.operations.length; i++)\n                writer.int32(message.operations[i]);\n            writer.join();\n        }\n        /* optional int64 expiresAt = 6; */\n        if (message.expiresAt !== undefined)\n            writer.tag(6, WireType.Varint).int64(message.expiresAt);\n        /* optional bytes pieceCid = 7; */\n        if (message.pieceCid !== undefined)\n            writer.tag(7, WireType.LengthDelimited).bytes(message.pieceCid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message Payload\n */\nexport const Payload = new Payload$Type();\n","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        const prefixCodePoint = prefix.codePointAt(0);\n        /* c8 ignore next 3 */\n        if (prefixCodePoint === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefixCodePoint;\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabetIdx, bitsPerChar, name) {\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = alphabetIdx[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\nfunction createAlphabetIdx(alphabet) {\n    // Build the character lookup table:\n    const alphabetIdx = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        alphabetIdx[alphabet[i]] = i;\n    }\n    return alphabetIdx;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    const alphabetIdx = createAlphabetIdx(alphabet);\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabetIdx, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","import { base32 } from 'multiformats/bases/base32';\n\nexport type CidContentType = 'dag-node' | 'raw-piece' | 'multipart-piece' | 'none';\n\nconst cidContentTypeMap: CidContentType[] = ['none', 'dag-node', 'raw-piece', 'multipart-piece'];\n\n/**\n * The `Cid` class represents a Content Identifier (CID) in DDC.\n *\n * @internal\n */\nexport class Cid {\n  private cid: Uint8Array | string;\n\n  constructor(cid: string | Uint8Array | Cid) {\n    this.cid = cid instanceof Cid ? cid.toBytes() : cid;\n  }\n\n  /**\n   * The content hash of the CID.\n   */\n  get contentHash() {\n    return this.toBytes().slice(-32);\n  }\n\n  get contentType() {\n    return cidContentTypeMap[this.toBytes()[1]];\n  }\n\n  /**\n   * Converts the CID to a string.\n   *\n   * @returns The CID as a string.\n   */\n  toString(): string {\n    return typeof this.cid === 'string' ? this.cid : base32.encode(this.cid);\n  }\n\n  /**\n   * Converts the CID to a `Uint8Array`.\n   *\n   * @returns The CID as a `Uint8Array`.\n   */\n  toBytes(): Uint8Array {\n    return typeof this.cid === 'string' ? base32.decode(this.cid) : this.cid;\n  }\n\n  /**\n   * Checks if an object is an instance of `Cid`.\n   *\n   * @param object - The object to check.\n   *\n   * @returns `true` if the object is an instance of `Cid` or has the same properties as a `Cid`, `false` otherwise.\n   */\n  static isCid(cid: string | Uint8Array) {\n    try {\n      const bytes = new Cid(cid).toBytes();\n\n      return bytes.byteLength > 32; // TODO: Implement proper CID parsing and detection\n    } catch {\n      return false;\n    }\n  }\n}\n","import base58 from 'bs58';\nimport { AccountId, Signer, decodeAddress, encodeAddress } from '@cere-ddc-sdk/blockchain';\n\nimport { AUTH_TOKEN_EXPIRATION_TIME } from '../constants';\nimport { createSignature, mapSignature, Signature } from '../signature';\nimport { AuthToken as Token, Payload, Operation } from '../grpc/auth_token';\nimport { Cid } from '../Cid';\n\nexport { Operation as AuthTokenOperation };\n\n/**\n * The `AuthTokenParams` type represents the parameters for creating an `AuthToken`.\n *\n * @hidden\n */\nexport type AuthTokenParams = Omit<Payload, 'subject' | 'prev' | 'pieceCid'> & {\n  pieceCid?: string | Uint8Array;\n  expiresIn?: number;\n  subject?: AccountId;\n  prev?: AuthToken | string;\n};\n\n/**\n * The `AuthToken` class represents an authentication token.\n *\n * @group Authentication\n *\n * @example\n *\n * ```typescript\n * const authToken = new AuthToken({\n *   bucketId: 1n,\n *   operations: [AuthTokenOperation.GET],\n * });\n *\n * await authToken.sign(signer);\n *\n * const sharebleToken = authToken.toString();\n * console.log(sharebleToken);\n *\n * const authTokenFromSharebleToken = AuthToken.from(sharebleToken);\n * console.log(authTokenFromSharebleToken);\n * ```\n */\nexport class AuthToken {\n  protected token: Token;\n\n  constructor(params: AuthTokenParams) {\n    const expiresIn = params.expiresIn ?? AUTH_TOKEN_EXPIRATION_TIME;\n    const payload: Payload = {\n      bucketId: params.bucketId,\n      operations: params.operations,\n      canDelegate: params.canDelegate ?? false,\n      expiresAt: params.expiresAt ?? Date.now() + expiresIn,\n      subject: params.subject ? decodeAddress(params.subject) : undefined,\n      pieceCid: params.pieceCid ? new Cid(params.pieceCid).toBytes() : undefined,\n      prev: AuthToken.maybeToken(params.prev)?.token,\n    };\n\n    this.token = Token.create({ payload });\n  }\n\n  /*\n   * The subject of the token.\n   */\n  get subject() {\n    return this.token.payload?.subject && encodeAddress(this.token.payload.subject);\n  }\n\n  /**\n   * The signature of the token\n   */\n  get signature(): Signature | undefined {\n    return this.token.signature && mapSignature(this.token.signature);\n  }\n\n  /**\n   * Whether the token can delegate access.\n   */\n  get canDelegate() {\n    return this.token.payload!.canDelegate ?? false;\n  }\n\n  /**\n   * The bucket identifier that the token grants access to.\n   */\n  get bucketId() {\n    return this.token.payload!.bucketId;\n  }\n\n  /**\n   * The operations that the token grants access to.\n   */\n  get operations() {\n    return this.token.payload!.operations;\n  }\n\n  /**\n   * The piece CID that the token grants access to.\n   */\n  get pieceCid() {\n    return this.token.payload!.pieceCid && new Cid(this.token.payload!.pieceCid).toString();\n  }\n\n  /**\n   * The expiration time of the token.\n   */\n  get expiresAt() {\n    return this.token.payload!.expiresAt!;\n  }\n\n  /**\n   * Whether the token is properly signed.\n   */\n  get isSigned() {\n    return this.subject ? this.signature?.signer === this.subject : !!this.signature;\n  }\n\n  private toBinary() {\n    return Token.toBinary(this.token);\n  }\n\n  private static fromProto(protoToken: Token) {\n    const newToken = new AuthToken({ operations: [] });\n\n    newToken.token = protoToken;\n\n    return newToken;\n  }\n\n  /**\n   * Converts the authentication token to a string.\n   *\n   * @returns The authentication token as a base58-encoded string.\n   */\n  toString() {\n    return base58.encode(this.toBinary());\n  }\n\n  /**\n   * Signs the authentication token using the provided signer.\n   *\n   * @param signer - The instance of Signer to use for signing the token.\n   *\n   * @example\n   *\n   * ```typescript\n   * const signer: Signer = ...;\n   * const authToken = new AuthToken(...);\n   *\n   * await authToken.sign(signer);\n   * ```\n   */\n  async sign(signer: Signer) {\n    this.token.signature = await createSignature(signer, this.toBinary());\n\n    return this;\n  }\n\n  /**\n   * Creates an `AuthToken` from a string or another `AuthToken`.\n   *\n   * @param token - The token as a string or an `AuthToken`.\n   *\n   * @returns An instance of the `AuthToken` class.\n   *\n   * @throws Will throw an error if the token is invalid.\n   *\n   * @example\n   *\n   * ```typescript\n   * const token: string = '...';\n   * const authToken = AuthToken.from(token);\n   *\n   * console.log(authToken);\n   * ```\n   */\n  static from(token: string | AuthToken) {\n    const parent = this.maybeToken(token);\n\n    if (!parent?.token.payload) {\n      throw new Error('Invalid token');\n    }\n\n    const { subject, ...params } = parent.token.payload;\n\n    return new AuthToken({\n      ...params,\n      prev: subject && parent, // Set `prev` only if `subject` is provided\n    });\n  }\n\n  /**\n   * This static method is used to convert a token into an AuthToken object.\n   *\n   * @param token - The input token, which can be either a string or an AuthToken object.\n   * @returns - If the input token is a string, returns an AuthToken object created from the string.\n   *            If the input token is already an AuthToken object, returns the input token as is.\n   *\n   * @example\n   *\n   * ```typescript\n   * const token: string = '...';\n   * const authToken = AuthToken.maybeToken(token);\n   *\n   * console.log(authToken);\n   * ```\n   */\n  static maybeToken(token?: string | AuthToken) {\n    if (typeof token !== 'string') {\n      return token;\n    }\n\n    return this.fromProto(Token.fromBinary(base58.decode(token)));\n  }\n\n  /**\n   * Creates an `AuthToken` with full access (GET, PUT, DELETE operations).\n   *\n   * @param params - The parameters of the token access.\n   *\n   * @returns An instance of the `AuthToken` class with full access.\n   *\n   * @example\n   *\n   * ```typescript\n   * const authToken = AuthToken.fullAccess({\n   *   bucketId: 1n,\n   * });\n   * ```\n   */\n  static fullAccess(params: Omit<AuthTokenParams, 'operations'> = {}) {\n    return new AuthToken({ ...params, operations: [Operation.GET, Operation.PUT, Operation.DELETE] });\n  }\n}\n","import { Signer, Web3Signer, createRandomSigner } from '@cere-ddc-sdk/blockchain';\n\nimport { AuthToken } from './AuthToken';\n\nconst signerRegistry = new WeakMap<Signer, Map<string, Signer>>();\n\nconst isWeb3Signer = (signer: Signer): signer is Web3Signer => {\n  return signer instanceof Web3Signer;\n};\n\nconst getRegestry = (signer: Signer) => {\n  if (!signerRegistry.has(signer)) {\n    signerRegistry.set(signer, new Map());\n  }\n\n  return signerRegistry.get(signer)!;\n};\n\nconst createSdkSigner = async (signer: Signer) => {\n  const randomSigner = createRandomSigner({ type: signer.type });\n  await randomSigner.isReady();\n\n  getRegestry(signer).set(randomSigner.address, randomSigner);\n\n  return randomSigner;\n};\n\nexport const getSdkSigner = (signer: Signer, address: string) => {\n  return getRegestry(signer).get(address);\n};\n\nexport const isValidSdkToken = (signer: Signer, token: AuthToken) => {\n  return signer.address === token.signature?.signer;\n};\n\nexport const createSdkToken = async (signer: Signer) => {\n  if (!isWeb3Signer(signer)) {\n    return AuthToken.fullAccess().sign(signer);\n  }\n\n  const sdkSigner = await createSdkSigner(signer);\n\n  return AuthToken.fullAccess({ subject: sdkSigner.address }).sign(signer);\n};\n\nexport const maybeSdkSigner = (signer: Signer, token?: AuthToken | string) => {\n  const finalToken = AuthToken.maybeToken(token);\n\n  return (finalToken?.signature && getSdkSigner(signer, finalToken.signature.signer)) || signer;\n};\n","import format from 'format-util';\nimport { LogFn, Level, levels } from 'pino';\nimport { Logger, LoggerOptions } from './types';\n\nconst globalConsole = globalThis.console;\n\nconst getLogLevel = (options: LoggerOptions) =>\n  (options.logLevel || options.logger?.level || 'warn') as Required<LoggerOptions>['logLevel'];\n\nconst getLogFn =\n  (level: Exclude<Level, 'fatal'>, defaultPrefix: string, options: LoggerOptions): LogFn =>\n  (...rawArgs: any[]) => {\n    const logLevel = getLogLevel(options);\n\n    if (logLevel === 'silent' || levels.values[level] < levels.values[logLevel]) {\n      return;\n    }\n\n    const msgPrefix = options.logOptions?.msgPrefix ?? `[${defaultPrefix}] `;\n    const args = rawArgs.filter((arg) => arg !== undefined);\n    const log = globalConsole[level];\n    const [debug, message, ...rest] = args;\n\n    if (typeof debug === 'string') {\n      const [message, ...rest] = args;\n\n      return log(format(`${msgPrefix}${message}`, ...rest));\n    }\n\n    return log(format(`${msgPrefix}${message}`, ...rest), debug);\n  };\n\nexport const createLogger = (prefix: string, options: LoggerOptions = {}): Logger => ({\n  level: getLogLevel(options),\n  debug: getLogFn('debug', prefix, options),\n  info: getLogFn('info', prefix, options),\n  warn: getLogFn('warn', prefix, options),\n  error: getLogFn('error', prefix, options),\n  fatal: getLogFn('error', prefix, options),\n  trace: getLogFn('trace', prefix, options),\n  silent: () => {},\n});\n","import { Logger } from './types';\n\ntype AnyFunction = (this: object, ...args: unknown[]) => Promise<unknown>;\n\nconst loggedErrors = new WeakSet<Error>();\n\nexport const bindErrorLogger = <T extends object, M extends keyof T>(obj: T, logger: Logger, methods: M[]) => {\n  for (const method of methods.filter((method) => typeof obj[method] === 'function')) {\n    const original = obj[method] as AnyFunction;\n    const patched = async function (this: object, ...args: unknown[]) {\n      try {\n        return await original.apply(this, args);\n      } catch (err) {\n        const error = err as Error;\n\n        if (!loggedErrors.has(error)) {\n          loggedErrors.add(error);\n          logger.error(error, 'Error in %s', original.name || 'anonymous function');\n        }\n\n        throw error;\n      }\n    };\n\n    obj[method] = patched as T[M];\n  }\n};\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"cns_api.proto\" (package \"cns\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Signature } from \"./common/signature\";\n/**\n * @generated from protobuf message cns.PutRequest\n */\nexport interface PutRequest {\n    /**\n     * @generated from protobuf field: uint64 bucketId = 1 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint;\n    /**\n     * @generated from protobuf field: cns.Record record = 2;\n     */\n    record?: Record;\n}\n/**\n * @generated from protobuf message cns.PutResponse\n */\nexport interface PutResponse {\n}\n/**\n * @generated from protobuf message cns.GetRequest\n */\nexport interface GetRequest {\n    /**\n     * @generated from protobuf field: uint64 bucketId = 1 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint;\n    /**\n     * @generated from protobuf field: string name = 2;\n     */\n    name: string;\n}\n/**\n * @generated from protobuf message cns.GetResponse\n */\nexport interface GetResponse {\n    /**\n     * @generated from protobuf field: cns.Record record = 1;\n     */\n    record?: Record;\n}\n/**\n * @generated from protobuf message cns.Record\n */\nexport interface Record {\n    /**\n     * @generated from protobuf field: common.Signature signature = 1;\n     */\n    signature?: Signature; // signature of a CnsRecord serialised to protobuf (excluding Signature itself) by a client that have an access to a bucket so requester can verify the validity of the CNS record\n    /**\n     * @generated from protobuf field: bytes cid = 2;\n     */\n    cid: Uint8Array;\n    /**\n     * @generated from protobuf field: string name = 3;\n     */\n    name: string;\n    /**\n     * TTL in seconds specifies how long it takes for record updates to reach your end users (time-to-live in cache layer).\n     * Default value is 300 (applied in case ttl isn't set). Min value is 30 and max value is 86400 (24 hours).\n     *\n     * @generated from protobuf field: optional uint32 ttl = 4;\n     */\n    ttl?: number;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutRequest$Type extends MessageType<PutRequest> {\n    constructor() {\n        super(\"cns.PutRequest\", [\n            { no: 1, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"record\", kind: \"message\", T: () => Record }\n        ]);\n    }\n    create(value?: PartialMessage<PutRequest>): PutRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.bucketId = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<PutRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutRequest): PutRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/ 1:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* cns.Record record */ 2:\n                    message.record = Record.internalBinaryRead(reader, reader.uint32(), options, message.record);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.bucketId);\n        /* cns.Record record = 2; */\n        if (message.record)\n            Record.internalBinaryWrite(message.record, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message cns.PutRequest\n */\nexport const PutRequest = new PutRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutResponse$Type extends MessageType<PutResponse> {\n    constructor() {\n        super(\"cns.PutResponse\", []);\n    }\n    create(value?: PartialMessage<PutResponse>): PutResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<PutResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutResponse): PutResponse {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message: PutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message cns.PutResponse\n */\nexport const PutResponse = new PutResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetRequest$Type extends MessageType<GetRequest> {\n    constructor() {\n        super(\"cns.GetRequest\", [\n            { no: 1, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetRequest>): GetRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.bucketId = 0n;\n        message.name = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<GetRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequest): GetRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/ 1:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.bucketId);\n        /* string name = 2; */\n        if (message.name !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.name);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message cns.GetRequest\n */\nexport const GetRequest = new GetRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetResponse$Type extends MessageType<GetResponse> {\n    constructor() {\n        super(\"cns.GetResponse\", [\n            { no: 1, name: \"record\", kind: \"message\", T: () => Record }\n        ]);\n    }\n    create(value?: PartialMessage<GetResponse>): GetResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<GetResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetResponse): GetResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* cns.Record record */ 1:\n                    message.record = Record.internalBinaryRead(reader, reader.uint32(), options, message.record);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* cns.Record record = 1; */\n        if (message.record)\n            Record.internalBinaryWrite(message.record, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message cns.GetResponse\n */\nexport const GetResponse = new GetResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Record$Type extends MessageType<Record> {\n    constructor() {\n        super(\"cns.Record\", [\n            { no: 1, name: \"signature\", kind: \"message\", T: () => Signature },\n            { no: 2, name: \"cid\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 4, name: \"ttl\", kind: \"scalar\", opt: true, T: 13 /*ScalarType.UINT32*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Record>): Record {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.cid = new Uint8Array(0);\n        message.name = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<Record>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Record): Record {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* common.Signature signature */ 1:\n                    message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);\n                    break;\n                case /* bytes cid */ 2:\n                    message.cid = reader.bytes();\n                    break;\n                case /* string name */ 3:\n                    message.name = reader.string();\n                    break;\n                case /* optional uint32 ttl */ 4:\n                    message.ttl = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Record, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* common.Signature signature = 1; */\n        if (message.signature)\n            Signature.internalBinaryWrite(message.signature, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* bytes cid = 2; */\n        if (message.cid.length)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.cid);\n        /* string name = 3; */\n        if (message.name !== \"\")\n            writer.tag(3, WireType.LengthDelimited).string(message.name);\n        /* optional uint32 ttl = 4; */\n        if (message.ttl !== undefined)\n            writer.tag(4, WireType.Varint).uint32(message.ttl);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message cns.Record\n */\nexport const Record = new Record$Type();\n/**\n * @generated ServiceType for protobuf service cns.CnsApi\n */\nexport const CnsApi = new ServiceType(\"cns.CnsApi\", [\n    { name: \"Put\", options: { \"google.api.http\": { post: \"/v1/cns/{bucketId}\", body: \"*\" } }, I: PutRequest, O: PutResponse },\n    { name: \"Get\", options: { \"google.api.http\": { get: \"/v1/cns/{bucketId}/{name}\" } }, I: GetRequest, O: GetResponse }\n]);\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"cns_api.proto\" (package \"cns\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { CnsApi } from \"./cns_api\";\nimport type { GetResponse } from \"./cns_api\";\nimport type { GetRequest } from \"./cns_api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { PutResponse } from \"./cns_api\";\nimport type { PutRequest } from \"./cns_api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service cns.CnsApi\n */\nexport interface ICnsApiClient {\n    /**\n     * @generated from protobuf rpc: Put(cns.PutRequest) returns (cns.PutResponse);\n     */\n    put(input: PutRequest, options?: RpcOptions): UnaryCall<PutRequest, PutResponse>;\n    /**\n     * @generated from protobuf rpc: Get(cns.GetRequest) returns (cns.GetResponse);\n     */\n    get(input: GetRequest, options?: RpcOptions): UnaryCall<GetRequest, GetResponse>;\n}\n/**\n * @generated from protobuf service cns.CnsApi\n */\nexport class CnsApiClient implements ICnsApiClient, ServiceInfo {\n    typeName = CnsApi.typeName;\n    methods = CnsApi.methods;\n    options = CnsApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: Put(cns.PutRequest) returns (cns.PutResponse);\n     */\n    put(input: PutRequest, options?: RpcOptions): UnaryCall<PutRequest, PutResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<PutRequest, PutResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Get(cns.GetRequest) returns (cns.GetResponse);\n     */\n    get(input: GetRequest, options?: RpcOptions): UnaryCall<GetRequest, GetResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetRequest, GetResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"activity_report/activity_report.proto\" (package \"activity_report\", syntax proto3)\n// tslint:disable\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { Signature } from \"../common/signature\";\n/**\n * @generated from protobuf message activity_report.ActivityRecord\n */\nexport interface ActivityRecord {\n    /**\n     * @generated from protobuf field: activity_report.ActivityFulfillment upstream = 1;\n     */\n    upstream?: ActivityFulfillment;\n    /**\n     * @generated from protobuf field: repeated activity_report.ActivityFulfillment downstream = 2;\n     */\n    downstream: ActivityFulfillment[];\n    /**\n     * @generated from protobuf field: uint64 timestamp = 3;\n     */\n    timestamp: number;\n    /**\n     * @generated from protobuf field: common.Signature signature = 10;\n     */\n    signature?: Signature;\n}\n/**\n * @generated from protobuf message activity_report.ActivityRequest\n */\nexport interface ActivityRequest {\n    /**\n     * @generated from protobuf field: optional activity_report.ActivityRequest parentRequest = 1;\n     */\n    parentRequest?: ActivityRequest;\n    /**\n     * @generated from protobuf field: string requestId = 2;\n     */\n    requestId: string;\n    /**\n     * @generated from protobuf field: activity_report.ActivityRequest.RequestType requestType = 3;\n     */\n    requestType: ActivityRequest_RequestType;\n    /**\n     * @generated from protobuf field: activity_report.ActivityRequest.ContentType contentType = 4;\n     */\n    contentType: ActivityRequest_ContentType;\n    /**\n     * @generated from protobuf field: uint64 bucketId = 5 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint; // set only when content type is PIECE\n    /**\n     * @generated from protobuf field: bytes id = 6;\n     */\n    id: Uint8Array; // either cid or segment id or merkle tree root hash\n    /**\n     * @generated from protobuf field: uint64 offset = 7;\n     */\n    offset: number; // offset of data requested (set only when RecordType = GET)\n    /**\n     * @generated from protobuf field: uint64 size = 8;\n     */\n    size: number; // size of content stored or delivered\n    /**\n     * @generated from protobuf field: uint64 timestamp = 9;\n     */\n    timestamp: number;\n    /**\n     * @generated from protobuf field: common.Signature signature = 10;\n     */\n    signature?: Signature;\n}\n/**\n * @generated from protobuf enum activity_report.ActivityRequest.RequestType\n */\nexport enum ActivityRequest_RequestType {\n    /**\n     * @generated from protobuf enum value: REQUEST_TYPE_STORE = 0;\n     */\n    STORE = 0,\n    /**\n     * @generated from protobuf enum value: REQUEST_TYPE_GET = 1;\n     */\n    GET = 1\n}\n/**\n * @generated from protobuf enum activity_report.ActivityRequest.ContentType\n */\nexport enum ActivityRequest_ContentType {\n    /**\n     * @generated from protobuf enum value: CONTENT_TYPE_PIECE = 0;\n     */\n    PIECE = 0,\n    /**\n     * @generated from protobuf enum value: CONTENT_TYPE_SEGMENT = 1;\n     */\n    SEGMENT = 1,\n    /**\n     * @generated from protobuf enum value: CONTENT_TYPE_MERKLE_TREE = 2;\n     */\n    MERKLE_TREE = 2\n}\n// we will get this on the server side streaming\n\n/**\n * @generated from protobuf message activity_report.ActivityAcknowledgment\n */\nexport interface ActivityAcknowledgment {\n    /**\n     * @generated from protobuf field: string requestId = 1;\n     */\n    requestId: string;\n    /**\n     * @generated from protobuf field: uint64 bytesStoredOrDelivered = 2;\n     */\n    bytesStoredOrDelivered: number;\n    /**\n     * @generated from protobuf field: uint64 timestamp = 3;\n     */\n    timestamp: number;\n    /**\n     * @generated from protobuf field: common.Signature signature = 4;\n     */\n    signature?: Signature;\n}\n/**\n * @generated from protobuf message activity_report.ActivityFulfillment\n */\nexport interface ActivityFulfillment {\n    /**\n     * @generated from protobuf field: activity_report.ActivityRequest request = 1;\n     */\n    request?: ActivityRequest;\n    /**\n     * @generated from protobuf field: optional activity_report.ActivityAcknowledgment ack = 2;\n     */\n    ack?: ActivityAcknowledgment;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass ActivityRecord$Type extends MessageType<ActivityRecord> {\n    constructor() {\n        super(\"activity_report.ActivityRecord\", [\n            { no: 1, name: \"upstream\", kind: \"message\", T: () => ActivityFulfillment },\n            { no: 2, name: \"downstream\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => ActivityFulfillment },\n            { no: 3, name: \"timestamp\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 10, name: \"signature\", kind: \"message\", T: () => Signature }\n        ]);\n    }\n    create(value?: PartialMessage<ActivityRecord>): ActivityRecord {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.downstream = [];\n        message.timestamp = 0;\n        if (value !== undefined)\n            reflectionMergePartial<ActivityRecord>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityRecord): ActivityRecord {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* activity_report.ActivityFulfillment upstream */ 1:\n                    message.upstream = ActivityFulfillment.internalBinaryRead(reader, reader.uint32(), options, message.upstream);\n                    break;\n                case /* repeated activity_report.ActivityFulfillment downstream */ 2:\n                    message.downstream.push(ActivityFulfillment.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* uint64 timestamp */ 3:\n                    message.timestamp = reader.uint64().toNumber();\n                    break;\n                case /* common.Signature signature */ 10:\n                    message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ActivityRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* activity_report.ActivityFulfillment upstream = 1; */\n        if (message.upstream)\n            ActivityFulfillment.internalBinaryWrite(message.upstream, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* repeated activity_report.ActivityFulfillment downstream = 2; */\n        for (let i = 0; i < message.downstream.length; i++)\n            ActivityFulfillment.internalBinaryWrite(message.downstream[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* uint64 timestamp = 3; */\n        if (message.timestamp !== 0)\n            writer.tag(3, WireType.Varint).uint64(message.timestamp);\n        /* common.Signature signature = 10; */\n        if (message.signature)\n            Signature.internalBinaryWrite(message.signature, writer.tag(10, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message activity_report.ActivityRecord\n */\nexport const ActivityRecord = new ActivityRecord$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ActivityRequest$Type extends MessageType<ActivityRequest> {\n    constructor() {\n        super(\"activity_report.ActivityRequest\", [\n            { no: 1, name: \"parentRequest\", kind: \"message\", T: () => ActivityRequest },\n            { no: 2, name: \"requestId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"requestType\", kind: \"enum\", T: () => [\"activity_report.ActivityRequest.RequestType\", ActivityRequest_RequestType, \"REQUEST_TYPE_\"] },\n            { no: 4, name: \"contentType\", kind: \"enum\", T: () => [\"activity_report.ActivityRequest.ContentType\", ActivityRequest_ContentType, \"CONTENT_TYPE_\"] },\n            { no: 5, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 6, name: \"id\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 7, name: \"offset\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 8, name: \"size\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 9, name: \"timestamp\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 10, name: \"signature\", kind: \"message\", T: () => Signature }\n        ]);\n    }\n    create(value?: PartialMessage<ActivityRequest>): ActivityRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.requestId = \"\";\n        message.requestType = 0;\n        message.contentType = 0;\n        message.bucketId = 0n;\n        message.id = new Uint8Array(0);\n        message.offset = 0;\n        message.size = 0;\n        message.timestamp = 0;\n        if (value !== undefined)\n            reflectionMergePartial<ActivityRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityRequest): ActivityRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* optional activity_report.ActivityRequest parentRequest */ 1:\n                    message.parentRequest = ActivityRequest.internalBinaryRead(reader, reader.uint32(), options, message.parentRequest);\n                    break;\n                case /* string requestId */ 2:\n                    message.requestId = reader.string();\n                    break;\n                case /* activity_report.ActivityRequest.RequestType requestType */ 3:\n                    message.requestType = reader.int32();\n                    break;\n                case /* activity_report.ActivityRequest.ContentType contentType */ 4:\n                    message.contentType = reader.int32();\n                    break;\n                case /* uint64 bucketId = 5 [jstype = JS_NORMAL];*/ 5:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* bytes id */ 6:\n                    message.id = reader.bytes();\n                    break;\n                case /* uint64 offset */ 7:\n                    message.offset = reader.uint64().toNumber();\n                    break;\n                case /* uint64 size */ 8:\n                    message.size = reader.uint64().toNumber();\n                    break;\n                case /* uint64 timestamp */ 9:\n                    message.timestamp = reader.uint64().toNumber();\n                    break;\n                case /* common.Signature signature */ 10:\n                    message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ActivityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* optional activity_report.ActivityRequest parentRequest = 1; */\n        if (message.parentRequest)\n            ActivityRequest.internalBinaryWrite(message.parentRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* string requestId = 2; */\n        if (message.requestId !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.requestId);\n        /* activity_report.ActivityRequest.RequestType requestType = 3; */\n        if (message.requestType !== 0)\n            writer.tag(3, WireType.Varint).int32(message.requestType);\n        /* activity_report.ActivityRequest.ContentType contentType = 4; */\n        if (message.contentType !== 0)\n            writer.tag(4, WireType.Varint).int32(message.contentType);\n        /* uint64 bucketId = 5 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(5, WireType.Varint).uint64(message.bucketId);\n        /* bytes id = 6; */\n        if (message.id.length)\n            writer.tag(6, WireType.LengthDelimited).bytes(message.id);\n        /* uint64 offset = 7; */\n        if (message.offset !== 0)\n            writer.tag(7, WireType.Varint).uint64(message.offset);\n        /* uint64 size = 8; */\n        if (message.size !== 0)\n            writer.tag(8, WireType.Varint).uint64(message.size);\n        /* uint64 timestamp = 9; */\n        if (message.timestamp !== 0)\n            writer.tag(9, WireType.Varint).uint64(message.timestamp);\n        /* common.Signature signature = 10; */\n        if (message.signature)\n            Signature.internalBinaryWrite(message.signature, writer.tag(10, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message activity_report.ActivityRequest\n */\nexport const ActivityRequest = new ActivityRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ActivityAcknowledgment$Type extends MessageType<ActivityAcknowledgment> {\n    constructor() {\n        super(\"activity_report.ActivityAcknowledgment\", [\n            { no: 1, name: \"requestId\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"bytesStoredOrDelivered\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 3, name: \"timestamp\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 4, name: \"signature\", kind: \"message\", T: () => Signature }\n        ]);\n    }\n    create(value?: PartialMessage<ActivityAcknowledgment>): ActivityAcknowledgment {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.requestId = \"\";\n        message.bytesStoredOrDelivered = 0;\n        message.timestamp = 0;\n        if (value !== undefined)\n            reflectionMergePartial<ActivityAcknowledgment>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityAcknowledgment): ActivityAcknowledgment {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string requestId */ 1:\n                    message.requestId = reader.string();\n                    break;\n                case /* uint64 bytesStoredOrDelivered */ 2:\n                    message.bytesStoredOrDelivered = reader.uint64().toNumber();\n                    break;\n                case /* uint64 timestamp */ 3:\n                    message.timestamp = reader.uint64().toNumber();\n                    break;\n                case /* common.Signature signature */ 4:\n                    message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ActivityAcknowledgment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string requestId = 1; */\n        if (message.requestId !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.requestId);\n        /* uint64 bytesStoredOrDelivered = 2; */\n        if (message.bytesStoredOrDelivered !== 0)\n            writer.tag(2, WireType.Varint).uint64(message.bytesStoredOrDelivered);\n        /* uint64 timestamp = 3; */\n        if (message.timestamp !== 0)\n            writer.tag(3, WireType.Varint).uint64(message.timestamp);\n        /* common.Signature signature = 4; */\n        if (message.signature)\n            Signature.internalBinaryWrite(message.signature, writer.tag(4, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message activity_report.ActivityAcknowledgment\n */\nexport const ActivityAcknowledgment = new ActivityAcknowledgment$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ActivityFulfillment$Type extends MessageType<ActivityFulfillment> {\n    constructor() {\n        super(\"activity_report.ActivityFulfillment\", [\n            { no: 1, name: \"request\", kind: \"message\", T: () => ActivityRequest },\n            { no: 2, name: \"ack\", kind: \"message\", T: () => ActivityAcknowledgment }\n        ]);\n    }\n    create(value?: PartialMessage<ActivityFulfillment>): ActivityFulfillment {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<ActivityFulfillment>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityFulfillment): ActivityFulfillment {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* activity_report.ActivityRequest request */ 1:\n                    message.request = ActivityRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);\n                    break;\n                case /* optional activity_report.ActivityAcknowledgment ack */ 2:\n                    message.ack = ActivityAcknowledgment.internalBinaryRead(reader, reader.uint32(), options, message.ack);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: ActivityFulfillment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* activity_report.ActivityRequest request = 1; */\n        if (message.request)\n            ActivityRequest.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* optional activity_report.ActivityAcknowledgment ack = 2; */\n        if (message.ack)\n            ActivityAcknowledgment.internalBinaryWrite(message.ack, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message activity_report.ActivityFulfillment\n */\nexport const ActivityFulfillment = new ActivityFulfillment$Type();\n","import { v4 as uuid } from 'uuid';\nimport { Buffer } from 'buffer';\nimport type { Signer } from '@cere-ddc-sdk/blockchain';\n\nimport type { Logger } from '../logger';\nimport { createSignature, CreateSignatureOptions } from '../signature';\nimport {\n  ActivityRequest,\n  ActivityRequest_ContentType,\n  ActivityRequest_RequestType,\n} from '../grpc/activity_report/activity_report';\n\nexport { ActivityRequest_RequestType as ActivityRequestType };\nexport type CreateActivityRequestOptions = CreateSignatureOptions & {\n  signer?: Signer;\n  logger?: Logger;\n};\n\n/**\n * Creates an activity request.\n */\nexport const createActivityRequest = async (\n  request: Partial<Omit<ActivityRequest, 'contentType' | 'signature'>>,\n  { signer, logger, ...options }: CreateActivityRequestOptions,\n) => {\n  if (!signer) {\n    throw new Error('Activity capturing cannot be enabled. Signer requred!');\n  }\n\n  const activityRequest = ActivityRequest.create({\n    timestamp: Date.now(),\n    requestId: createRequestId(),\n    ...request,\n    contentType: ActivityRequest_ContentType.PIECE,\n  });\n\n  activityRequest.signature = await createSignature(signer, ActivityRequest.toBinary(activityRequest), options);\n\n  logger?.debug({ activityRequest }, 'Activity request');\n\n  return Buffer.from(ActivityRequest.toBinary(activityRequest)).toString('base64');\n};\n\n/**\n * Generates a unique request ID.\n */\nexport const createRequestId = () => uuid();\n","import type { Signer } from '@cere-ddc-sdk/blockchain';\n\nimport type { Logger } from '../logger';\nimport { ActivityAcknowledgment } from '../grpc/activity_report/activity_report';\nimport { createSignature, CreateSignatureOptions } from '../signature';\n\nexport type CreateAckOptions = CreateSignatureOptions & {\n  signer?: Signer;\n  logger?: Logger;\n};\n\n/**\n * Creates an activity acknowledgment.\n */\nexport const createAck = async (\n  ack: Omit<ActivityAcknowledgment, 'signature'>,\n  { signer, logger, ...options }: CreateAckOptions,\n) => {\n  if (!signer) {\n    throw new Error('Cannot sign acknowledgment. Signer requred!');\n  }\n\n  const signedAck = ActivityAcknowledgment.create({\n    ...ack,\n    signature: await createSignature(signer, ActivityAcknowledgment.toBinary(ack), options),\n  });\n\n  logger?.debug({ signedAck }, 'Activity acknowledgment');\n\n  return signedAck;\n};\n","import { v4 as uuid } from 'uuid';\nimport { RpcMetadata } from '@protobuf-ts/runtime-rpc';\n\nexport type CorrelationMetaParams = { correlationId?: string };\n\nconst CORRELATION_ID_META_KEY = 'correlation-id';\n\nexport const createRpcMeta = (correlationId?: string, meta?: RpcMetadata): RpcMetadata => {\n  return { ...meta, [CORRELATION_ID_META_KEY]: correlationId || uuid() };\n};\n","import { v4 as uuid } from 'uuid';\n\n/**\n * Generate a random correlation ID.\n */\nexport const createCorrelationId = () => uuid();\n","import { RpcError } from '@protobuf-ts/runtime-rpc';\nimport type { Signer } from '@cere-ddc-sdk/blockchain';\n\nimport { RpcTransport } from '../transports';\nimport { createRpcMeta as createAuthRpcMeta, AuthMetaParams } from '../auth';\nimport { Logger, LoggerOptions, createLogger } from '../logger';\nimport { GrpcStatus } from '../grpc/status';\nimport { createSignature, mapSignature, Signature } from '../signature';\nimport { CnsApiClient } from '../grpc/cns_api.client';\nimport { GetRequest as ProtoGetRequest, PutRequest as ProtoPutRequest, Record as ProtoRecord } from '../grpc/cns_api';\nimport {\n  ActivityRequestType,\n  createActivityRequest,\n  CorrelationMetaParams,\n  createRpcMeta as createCorrelationRpcMeta,\n} from '../activity';\n\nexport type Record = Omit<ProtoRecord, 'signature'> & {\n  signature: Signature;\n};\n\ntype PutRequest = Omit<ProtoPutRequest, 'record'> &\n  CorrelationMetaParams &\n  AuthMetaParams & {\n    record: Omit<Record, 'signature'>;\n  };\n\ntype GetRequest = CorrelationMetaParams &\n  ProtoGetRequest &\n  AuthMetaParams & {\n    cacheControl?: 'no-cache';\n  };\n\nconst createSignatureMessage = (record: Omit<Record, 'signature'>) => {\n  const message = ProtoRecord.create(record);\n\n  return ProtoRecord.toBinary(message);\n};\n\nexport type CnsApiOptions = LoggerOptions & {\n  signer?: Signer;\n\n  /**\n   * TODO: Remove this option in the next major version.\n   *\n   * @deprecated There is no acknowledgment mechanism in the CNS API anymore.\n   * */\n  enableAcks?: boolean;\n};\n\n/**\n * The `CnsApi` class provides methods to interact with the DDC CNS API.\n *\n * @group Content Name System (CNS)\n * @example\n *\n * ```typescript\n * import { CnsApi, GrpcTransport } from '@cere-ddc-sdk/ddc';\n *\n * const transport = new GrpcTransport(...);\n * const cnsApi = new CnsApi(transport);\n * ```\n */\nexport class CnsApi {\n  private logger: Logger;\n  private api: CnsApiClient;\n\n  constructor(\n    transport: RpcTransport,\n    private options: CnsApiOptions = {},\n  ) {\n    this.api = new CnsApiClient(transport);\n    this.logger = createLogger('CnsApi', options);\n  }\n\n  /**\n   * Stores a CNS record to DDC.\n   *\n   * @param request - An object that includes the token, bucket ID, and record to store.\n   *\n   * @returns The stored record with its signature.\n   *\n   * @example\n   *\n   * ```typescript\n   * const request: PutRequest = {\n   *   token: '...',\n   *   bucketId: '...',\n   *   record: { ... }\n   * };\n   *\n   * const record = await cnsApi.putRecord(request);\n   *\n   * console.log(record); //\n   * ```\n   */\n  async putRecord({ token, bucketId, record, correlationId }: PutRequest): Promise<Record> {\n    this.logger.debug({ bucketId, record, token, correlationId }, 'Storing CNS record');\n\n    const meta = createCorrelationRpcMeta(correlationId, createAuthRpcMeta(token));\n    const { signer } = this.options;\n\n    if (!signer) {\n      throw new Error('Unnable to store CNS record. Signer required!');\n    }\n\n    const signature = await createSignature(signer, createSignatureMessage(record), { token });\n\n    meta.request = await createActivityRequest(\n      { bucketId, size: ProtoRecord.toBinary(record).byteLength, requestType: ActivityRequestType.STORE },\n      { logger: this.logger, signer },\n    );\n\n    await this.api.put({ bucketId, record: { ...record, signature } }, { meta });\n\n    this.logger.debug({ record, correlationId }, 'CNS record stored');\n\n    return {\n      ...record,\n      signature: mapSignature(signature),\n    };\n  }\n\n  /**\n   * Retrieves a CNS record from DDC.\n   *\n   * @param request - An object that includes the token, bucket ID, and record name to retrieve.\n   *\n   * @returns The retrieved record with its signature.\n   *\n   * @example\n   *\n   * ```typescript\n   * const request: GetRequest = {\n   *   token: '...',\n   *   bucketId: '...',\n   *   name: 'example'\n   * };\n   *\n   * const record = await cnsApi.getRecord(getRequest);\n   *\n   * console.log(record);\n   * ```\n   */\n  async getRecord({ token, name, bucketId, correlationId, cacheControl }: GetRequest): Promise<Record | undefined> {\n    this.logger.debug({ name, bucketId, token, correlationId, cacheControl }, 'Retrieving CNS record');\n\n    let record: ProtoRecord | undefined;\n    const meta = createCorrelationRpcMeta(correlationId, createAuthRpcMeta(token));\n\n    if (cacheControl) {\n      meta['cache-control'] = cacheControl;\n    }\n\n    if (this.options.signer) {\n      meta.request = await createActivityRequest(\n        { bucketId, requestType: ActivityRequestType.GET },\n        { token, logger: this.logger, signer: this.options.signer },\n      );\n    }\n\n    try {\n      const { response } = await this.api.get({ name, bucketId }, { meta });\n\n      record = response.record;\n    } catch (error) {\n      /**\n       * TODO: replace error.message === 'no result' with error.code === GrpcStatus[GrpcStatus.NOT_FOUND] when the status is fixed on stroage node side\n       */\n      const isNotFound =\n        error instanceof RpcError && error.code === GrpcStatus[GrpcStatus.UNKNOWN] && error.message === 'no result'; // error.code === GrpcStatus[GrpcStatus.NOT_FOUND];\n\n      if (!isNotFound) {\n        throw error;\n      }\n    }\n\n    if (!record?.signature) {\n      this.logger.debug({ name, bucketId, correlationId }, 'CNS record not found');\n\n      return undefined;\n    }\n\n    this.logger.debug({ record, correlationId }, 'CNS record retrieved');\n\n    return {\n      ...record,\n      signature: mapSignature(record.signature),\n      cid: new Uint8Array(record.cid),\n    };\n  }\n}\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"dag_api.proto\" (package \"dag\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\n/**\n * @generated from protobuf message dag.PutRequest\n */\nexport interface PutRequest {\n    /**\n     * @generated from protobuf field: uint64 bucketId = 1 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint;\n    /**\n     * @generated from protobuf field: dag.Node node = 2;\n     */\n    node?: Node;\n    /**\n     * @generated from protobuf field: optional bytes cid = 3;\n     */\n    cid?: Uint8Array;\n}\n/**\n * @generated from protobuf message dag.PutResponse\n */\nexport interface PutResponse {\n    /**\n     * @generated from protobuf field: bytes cid = 1;\n     */\n    cid: Uint8Array;\n}\n/**\n * @generated from protobuf message dag.GetRequest\n */\nexport interface GetRequest {\n    /**\n     * @generated from protobuf field: uint64 bucketId = 1 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint;\n    /**\n     * @generated from protobuf field: bytes cid = 2;\n     */\n    cid: Uint8Array;\n    /**\n     * @generated from protobuf field: optional string path = 3;\n     */\n    path?: string;\n}\n/**\n * @generated from protobuf message dag.GetResponse\n */\nexport interface GetResponse {\n    /**\n     * @generated from protobuf field: dag.Node node = 1;\n     */\n    node?: Node;\n}\n/**\n * @generated from protobuf message dag.Node\n */\nexport interface Node {\n    /**\n     * @generated from protobuf field: bytes data = 1;\n     */\n    data: Uint8Array;\n    /**\n     * @generated from protobuf field: repeated dag.Link links = 2;\n     */\n    links: Link[];\n    /**\n     * @generated from protobuf field: repeated dag.Tag tags = 3;\n     */\n    tags: Tag[];\n}\n/**\n * @generated from protobuf message dag.Link\n */\nexport interface Link {\n    /**\n     * CID of the target object\n     *\n     * @generated from protobuf field: bytes cid = 1;\n     */\n    cid: Uint8Array;\n    /**\n     * UTF-8 string name\n     *\n     * @generated from protobuf field: string name = 2;\n     */\n    name: string;\n    /**\n     * cumulative size of target object\n     *\n     * @generated from protobuf field: uint64 size = 3;\n     */\n    size: number;\n}\n/**\n * @generated from protobuf message dag.Tag\n */\nexport interface Tag {\n    /**\n     * @generated from protobuf field: string key = 1;\n     */\n    key: string;\n    /**\n     * @generated from protobuf field: string value = 2;\n     */\n    value: string;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutRequest$Type extends MessageType<PutRequest> {\n    constructor() {\n        super(\"dag.PutRequest\", [\n            { no: 1, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"node\", kind: \"message\", T: () => Node },\n            { no: 3, name: \"cid\", kind: \"scalar\", opt: true, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PutRequest>): PutRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.bucketId = 0n;\n        if (value !== undefined)\n            reflectionMergePartial<PutRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutRequest): PutRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/ 1:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* dag.Node node */ 2:\n                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);\n                    break;\n                case /* optional bytes cid */ 3:\n                    message.cid = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.bucketId);\n        /* dag.Node node = 2; */\n        if (message.node)\n            Node.internalBinaryWrite(message.node, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* optional bytes cid = 3; */\n        if (message.cid !== undefined)\n            writer.tag(3, WireType.LengthDelimited).bytes(message.cid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message dag.PutRequest\n */\nexport const PutRequest = new PutRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutResponse$Type extends MessageType<PutResponse> {\n    constructor() {\n        super(\"dag.PutResponse\", [\n            { no: 1, name: \"cid\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PutResponse>): PutResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.cid = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<PutResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutResponse): PutResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes cid */ 1:\n                    message.cid = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes cid = 1; */\n        if (message.cid.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.cid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message dag.PutResponse\n */\nexport const PutResponse = new PutResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetRequest$Type extends MessageType<GetRequest> {\n    constructor() {\n        super(\"dag.GetRequest\", [\n            { no: 1, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"cid\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"path\", kind: \"scalar\", opt: true, T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetRequest>): GetRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.bucketId = 0n;\n        message.cid = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<GetRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequest): GetRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/ 1:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* bytes cid */ 2:\n                    message.cid = reader.bytes();\n                    break;\n                case /* optional string path */ 3:\n                    message.path = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.bucketId);\n        /* bytes cid = 2; */\n        if (message.cid.length)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.cid);\n        /* optional string path = 3; */\n        if (message.path !== undefined)\n            writer.tag(3, WireType.LengthDelimited).string(message.path);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message dag.GetRequest\n */\nexport const GetRequest = new GetRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetResponse$Type extends MessageType<GetResponse> {\n    constructor() {\n        super(\"dag.GetResponse\", [\n            { no: 1, name: \"node\", kind: \"message\", T: () => Node }\n        ]);\n    }\n    create(value?: PartialMessage<GetResponse>): GetResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        if (value !== undefined)\n            reflectionMergePartial<GetResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetResponse): GetResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* dag.Node node */ 1:\n                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* dag.Node node = 1; */\n        if (message.node)\n            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message dag.GetResponse\n */\nexport const GetResponse = new GetResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Node$Type extends MessageType<Node> {\n    constructor() {\n        super(\"dag.Node\", [\n            { no: 1, name: \"data\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"links\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Link },\n            { no: 3, name: \"tags\", kind: \"message\", repeat: 1 /*RepeatType.PACKED*/, T: () => Tag }\n        ]);\n    }\n    create(value?: PartialMessage<Node>): Node {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.data = new Uint8Array(0);\n        message.links = [];\n        message.tags = [];\n        if (value !== undefined)\n            reflectionMergePartial<Node>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Node): Node {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes data */ 1:\n                    message.data = reader.bytes();\n                    break;\n                case /* repeated dag.Link links */ 2:\n                    message.links.push(Link.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated dag.Tag tags */ 3:\n                    message.tags.push(Tag.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes data = 1; */\n        if (message.data.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.data);\n        /* repeated dag.Link links = 2; */\n        for (let i = 0; i < message.links.length; i++)\n            Link.internalBinaryWrite(message.links[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        /* repeated dag.Tag tags = 3; */\n        for (let i = 0; i < message.tags.length; i++)\n            Tag.internalBinaryWrite(message.tags[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message dag.Node\n */\nexport const Node = new Node$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Link$Type extends MessageType<Link> {\n    constructor() {\n        super(\"dag.Link\", [\n            { no: 1, name: \"cid\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"name\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 3, name: \"size\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Link>): Link {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.cid = new Uint8Array(0);\n        message.name = \"\";\n        message.size = 0;\n        if (value !== undefined)\n            reflectionMergePartial<Link>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Link): Link {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes cid */ 1:\n                    message.cid = reader.bytes();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* uint64 size */ 3:\n                    message.size = reader.uint64().toNumber();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Link, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes cid = 1; */\n        if (message.cid.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.cid);\n        /* string name = 2; */\n        if (message.name !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.name);\n        /* uint64 size = 3; */\n        if (message.size !== 0)\n            writer.tag(3, WireType.Varint).uint64(message.size);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message dag.Link\n */\nexport const Link = new Link$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Tag$Type extends MessageType<Tag> {\n    constructor() {\n        super(\"dag.Tag\", [\n            { no: 1, name: \"key\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ },\n            { no: 2, name: \"value\", kind: \"scalar\", T: 9 /*ScalarType.STRING*/ }\n        ]);\n    }\n    create(value?: PartialMessage<Tag>): Tag {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.key = \"\";\n        message.value = \"\";\n        if (value !== undefined)\n            reflectionMergePartial<Tag>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tag): Tag {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* string key */ 1:\n                    message.key = reader.string();\n                    break;\n                case /* string value */ 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* string key = 1; */\n        if (message.key !== \"\")\n            writer.tag(1, WireType.LengthDelimited).string(message.key);\n        /* string value = 2; */\n        if (message.value !== \"\")\n            writer.tag(2, WireType.LengthDelimited).string(message.value);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message dag.Tag\n */\nexport const Tag = new Tag$Type();\n/**\n * @generated ServiceType for protobuf service dag.DagApi\n */\nexport const DagApi = new ServiceType(\"dag.DagApi\", [\n    { name: \"Put\", options: { \"google.api.http\": { post: \"/v1/dag/{bucketId}\", body: \"*\" } }, I: PutRequest, O: PutResponse },\n    { name: \"Get\", options: { \"google.api.http\": { get: \"/v1/dag/{bucketId}/{cid}/{path}\", additionalBindings: [{ get: \"/v1/dag/{bucketId}/{cid}\" }] } }, I: GetRequest, O: GetResponse }\n]);\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"dag_api.proto\" (package \"dag\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { DagApi } from \"./dag_api\";\nimport type { GetResponse } from \"./dag_api\";\nimport type { GetRequest } from \"./dag_api\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { PutResponse } from \"./dag_api\";\nimport type { PutRequest } from \"./dag_api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service dag.DagApi\n */\nexport interface IDagApiClient {\n    /**\n     * @generated from protobuf rpc: Put(dag.PutRequest) returns (dag.PutResponse);\n     */\n    put(input: PutRequest, options?: RpcOptions): UnaryCall<PutRequest, PutResponse>;\n    /**\n     * @generated from protobuf rpc: Get(dag.GetRequest) returns (dag.GetResponse);\n     */\n    get(input: GetRequest, options?: RpcOptions): UnaryCall<GetRequest, GetResponse>;\n}\n/**\n * @generated from protobuf service dag.DagApi\n */\nexport class DagApiClient implements IDagApiClient, ServiceInfo {\n    typeName = DagApi.typeName;\n    methods = DagApi.methods;\n    options = DagApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: Put(dag.PutRequest) returns (dag.PutResponse);\n     */\n    put(input: PutRequest, options?: RpcOptions): UnaryCall<PutRequest, PutResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<PutRequest, PutResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: Get(dag.GetRequest) returns (dag.GetResponse);\n     */\n    get(input: GetRequest, options?: RpcOptions): UnaryCall<GetRequest, GetResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetRequest, GetResponse>(\"unary\", this._transport, method, opt, input);\n    }\n}\n","import { createBLAKE3 } from 'hash-wasm';\n\nimport { Logger } from '../logger';\nimport { Cid } from '../Cid';\n\nexport type CidValidatorOptions = {\n  logger?: Logger;\n  enable?: boolean;\n};\n\nexport class CidValidator {\n  private hasherPromise?: ReturnType<typeof createBLAKE3>;\n  private cid: Cid;\n  protected logger?: Logger;\n  protected readonly enable: boolean;\n\n  constructor(cid: Uint8Array, { logger, enable = true }: CidValidatorOptions = {}) {\n    this.cid = new Cid(cid);\n    this.logger = logger;\n    this.enable = enable;\n  }\n\n  protected async getHasher() {\n    this.hasherPromise ||= createBLAKE3();\n\n    return this.hasherPromise;\n  }\n\n  async update(chunk: Uint8Array) {\n    if (!this.enable) {\n      return this;\n    }\n\n    const hasher = await this.getHasher();\n\n    hasher.update(chunk);\n\n    return this;\n  }\n\n  async validate() {\n    if (!this.enable) {\n      return;\n    }\n\n    const hasher = await this.getHasher();\n\n    const receivedHash = hasher.digest('hex');\n    const expectedHash = Buffer.from(this.cid.contentHash).toString('hex');\n\n    this.logger?.debug({ expectedHash, receivedHash }, 'Validating content hash');\n\n    if (receivedHash !== expectedHash) {\n      throw new Error('Received content is not valid - hash does not match');\n    }\n  }\n}\n","import { GetFileResponse_Proof } from '../grpc/file_api';\nimport type { ReadFileRange } from '../FileApi';\nimport { CidValidator, CidValidatorOptions } from './CidValidator';\n\nexport type FileValidatorOptions = CidValidatorOptions & {\n  range?: ReadFileRange;\n};\n\nexport class FileValidator extends CidValidator {\n  private range?: ReadFileRange;\n  private isProved = false;\n\n  constructor(cid: Uint8Array, { range, ...options }: FileValidatorOptions = {}) {\n    super(cid, options);\n\n    this.range = range;\n  }\n\n  /**\n   * TODO: Implement proof verification\n   */\n  async prove({ proof }: GetFileResponse_Proof) {\n    this.isProved = proof.length > 0;\n  }\n\n  async validate() {\n    if (this.isProved || this.range) {\n      return;\n    }\n\n    await super.validate();\n  }\n}\n","import { CidValidator, CidValidatorOptions } from './CidValidator';\n\nexport type DagNodeValidatorOptions = CidValidatorOptions;\n\nexport class DagNodeValidator extends CidValidator {}\n","import { Signer } from '@cere-ddc-sdk/blockchain';\n\nimport { RpcTransport } from '../transports';\nimport { PutRequest as ProtoPutRequest, GetRequest as ProtoGetRequest, Node } from '../grpc/dag_api';\nimport { DagApiClient } from '../grpc/dag_api.client';\nimport { createRpcMeta as createAuthRpcMeta, AuthMetaParams } from '../auth';\nimport { DagNodeValidator } from '../validators';\nimport { createLogger, Logger, LoggerOptions } from '../logger';\nimport {\n  createActivityRequest,\n  ActivityRequestType,\n  CorrelationMetaParams,\n  createRpcMeta as createCorrelationRpcMeta,\n} from '../activity';\n\ntype PutRequest = ProtoPutRequest & AuthMetaParams & CorrelationMetaParams;\ntype GetRequest = ProtoGetRequest & AuthMetaParams & CorrelationMetaParams;\n\nexport type DagApiOptions = LoggerOptions & {\n  signer?: Signer;\n  authenticate?: boolean;\n  /**\n   * TODO: Remove this option in the next major version.\n   *\n   * @deprecated There is no acknowledgment mechanism in the DAG API anymore.\n   */\n  enableAcks?: boolean;\n};\n\n/**\n * The `DagApi` class provides methods to interact with the DDC DAG API.\n *\n * @group Directed Acyclic Graph (DAG)\n * @example\n *\n * ```typescript\n * import { DagApi, GrpcTransport } from '@cere-ddc-sdk/ddc';\n *\n * const transport = new GrpcTransport(...);\n * const dagApi = new DagApi(transport);\n * ```\n */\nexport class DagApi {\n  private logger: Logger;\n  private api: DagApiClient;\n  private options: DagApiOptions;\n\n  constructor(transport: RpcTransport, options: DagApiOptions = {}) {\n    this.api = new DagApiClient(transport);\n    this.logger = createLogger('DagApi', options);\n\n    this.options = {\n      ...options,\n      authenticate: options.authenticate ?? false,\n    };\n  }\n\n  /**\n   * Stores a node in DDC DAG.\n   *\n   * @param request - An object that includes the access token and the node to store.\n   *\n   * @returns The CID of the stored node as a `Uint8Array`.\n   *\n   * @example\n   *\n   * ```typescript\n   * const request: PutRequest = { token: '...', node: { ... } };\n   * const cid = await dagApi.putNode(request);\n   *\n   * console.log(cid);\n   * ```\n   */\n  async putNode({ token, bucketId, node, cid, correlationId }: PutRequest) {\n    const meta = createCorrelationRpcMeta(correlationId, createAuthRpcMeta(token));\n\n    this.logger.debug({ token, correlationId, bucketId, node, cid }, 'Storing DAG Node');\n\n    if (this.options.signer && node) {\n      meta.request = await createActivityRequest(\n        { id: cid, bucketId, size: Node.toBinary(node).byteLength, requestType: ActivityRequestType.STORE },\n        { token, logger: this.logger, signer: this.options.signer },\n      );\n    }\n\n    const { response } = await this.api.put({ bucketId, node, cid }, { meta });\n\n    this.logger.debug({ cid, correlationId }, 'DAG Node stored');\n\n    return new Uint8Array(response.cid);\n  }\n\n  /**\n   * Retrieves a DAG node from DDC.\n   *\n   * @group Low level API\n   * @param request - An object that includes the access token and the CID of the node to retrieve.\n   *\n   * @returns The retrieved node as a `Node` object, or `undefined` if the node does not exist.\n   *\n   * @example\n   *\n   * ```typescript\n   * const request: GetRequest = { token: '...', cid: '...' };\n   * const node = await dagApi.getNode(request);\n   *\n   * console.log(node);\n   * ```\n   */\n  async getNode({ token, correlationId, ...request }: GetRequest): Promise<Node | undefined> {\n    this.logger.debug({ ...request, token, correlationId }, 'Retrieving DAG Node');\n\n    /**\n     * In case a sub-node requested using root CID + path - we don't have the target node CID, so we can't authenticate it.\n     */\n    const authenticate = this.options.authenticate && !request.path;\n    const meta = createCorrelationRpcMeta(correlationId, createAuthRpcMeta(token));\n\n    const validator = new DagNodeValidator(request.cid, {\n      enable: authenticate,\n      logger: this.logger,\n    });\n\n    if (this.options.signer) {\n      meta.request = await createActivityRequest(\n        { id: request.cid, bucketId: request.bucketId, requestType: ActivityRequestType.GET },\n        { token, logger: this.logger, signer: this.options.signer },\n      );\n    }\n\n    const { response } = await this.api.get(request, { meta });\n\n    if (response.node && authenticate) {\n      await validator.update(Node.toBinary(response.node));\n    }\n\n    await validator.validate();\n\n    this.logger.debug({ node: response.node, correlationId }, 'DAG Node retrieved');\n\n    return (\n      response.node && {\n        ...response.node,\n        data: new Uint8Array(response.node.data),\n      }\n    );\n  }\n}\n","export class TransformStream<T = any> extends globalThis.TransformStream<T> {}\nexport class WritableStreamDefaultWriter<T = any> extends globalThis.WritableStreamDefaultWriter<T> {}\nexport class ReadableStreamDefaultReader<T = any> extends globalThis.ReadableStreamDefaultReader<T> {}\nexport class ReadableStream<T = any> extends globalThis.ReadableStream<T> {}\n\n/**\n * Apply polyfill for `ReadableStream[Symbol.asyncIterator]`\n * https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n *\n * TODO: Revise it later\n */\n\ndeclare global {\n  interface ReadableStream {\n    [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n  }\n}\n\nglobalThis.ReadableStream.prototype[Symbol.asyncIterator] ??= async function* <T = any>(this: ReadableStream<T>) {\n  const reader = this.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        return undefined;\n      }\n\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n};\n","import { Buffer } from 'buffer';\nimport { ReadableStream, TransformStream, ReadableStreamDefaultReader } from './streams';\n\nimport { CONTENT_CHUNK_SIZE } from '../constants';\n\ntype InputStream = Omit<ReadableStream<Uint8Array>, 'getReader'> & {\n  /**\n   * Browser's ReadableStream provides overloads to `getReader` which breaks types, so have to use `any` here and later cast the type\n   */\n  getReader: () => any;\n};\n\n/**\n * The `Content` type represents the content of a file or a piece.\n *\n * It can be a `Uint8Array`, an iterable of `Uint8Array`, an async iterable of `Uint8Array`, or an `InputStream`.\n *\n * @hidden\n */\nexport type Content = Uint8Array | Iterable<Uint8Array> | AsyncIterable<Uint8Array> | InputStream;\n\n/**\n * The `ContentStream` type represents a stream of content.\n *\n * @hidden\n */\nexport type ContentStream = ReadableStream<Uint8Array> & {\n  readonly [ContentStreamSymbol]?: boolean;\n};\n\nexport const withChunkSize = (chunkSize: number) => {\n  let buffer: Buffer | undefined;\n  const slice = Uint8Array.prototype.slice;\n\n  return new TransformStream<Uint8Array>({\n    transform(data, controller) {\n      buffer = buffer ? Buffer.concat([buffer, data]) : Buffer.from(data);\n\n      while (buffer.byteLength >= chunkSize) {\n        controller.enqueue(slice.call(buffer, 0, chunkSize));\n        buffer = Buffer.from(slice.call(buffer, chunkSize));\n      }\n    },\n\n    flush(controller) {\n      if (buffer?.byteLength) {\n        controller.enqueue(slice.call(buffer));\n      }\n\n      buffer = undefined;\n    },\n  });\n};\n\n/**\n * Not all browsers support async iterators on ReadableStream, so we need to convert it manualy in some cases\n */\nconst isInputStream = (input: Content | InputStream): input is InputStream => {\n  return 'getReader' in input;\n};\n\nasync function* toIterable(input: Content | ContentStream) {\n  if (!isInputStream(input)) {\n    return yield* input;\n  }\n\n  const reader: ReadableStreamDefaultReader<Uint8Array> = input.getReader();\n\n  while (true) {\n    const { done, value } = await reader.read();\n\n    if (done) {\n      break;\n    }\n\n    yield value;\n  }\n}\n\nexport const getContentSize = (content: Content, defaultSize?: number) => {\n  return 'byteLength' in content ? content.byteLength : defaultSize;\n};\n\nconst ContentStreamSymbol = Symbol('ContentStream');\nexport const isContentStream = (input: unknown): input is ContentStream => {\n  return !!input && typeof input === 'object' && ContentStreamSymbol in input;\n};\n\nexport const createContentStream = (\n  input: Content | ContentStream,\n  chunkSize: number | null = CONTENT_CHUNK_SIZE,\n): ContentStream => {\n  const asyncIterator = toIterable(input instanceof Uint8Array ? [input] : input);\n\n  const stream = new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await asyncIterator.next();\n\n      if (value) {\n        controller.enqueue(value);\n      }\n\n      if (done) {\n        controller.close();\n      }\n    },\n  });\n\n  return Object.assign(chunkSize ? stream.pipeThrough<Uint8Array>(withChunkSize(chunkSize)) : stream, {\n    [ContentStreamSymbol]: true,\n  });\n};\n","export const json = (body: ReadableStream) => new Response(body).json();\nexport const arrayBuffer = (body: ReadableStream) => new Response(body).arrayBuffer();\nexport const text = (body: ReadableStream) => new Response(body).text();\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"file_api.proto\" (package \"file\", syntax proto3)\n// tslint:disable\nimport { ServiceType } from \"@protobuf-ts/runtime-rpc\";\nimport type { BinaryWriteOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryWriter } from \"@protobuf-ts/runtime\";\nimport { WireType } from \"@protobuf-ts/runtime\";\nimport type { BinaryReadOptions } from \"@protobuf-ts/runtime\";\nimport type { IBinaryReader } from \"@protobuf-ts/runtime\";\nimport { UnknownFieldHandler } from \"@protobuf-ts/runtime\";\nimport type { PartialMessage } from \"@protobuf-ts/runtime\";\nimport { reflectionMergePartial } from \"@protobuf-ts/runtime\";\nimport { MessageType } from \"@protobuf-ts/runtime\";\nimport { ActivityAcknowledgment } from \"./activity_report/activity_report\";\n/**\n * @generated from protobuf message file.PutRawPieceRequest\n */\nexport interface PutRawPieceRequest {\n    /**\n     * @generated from protobuf oneof: body\n     */\n    body: {\n        oneofKind: \"metadata\";\n        /**\n         * @generated from protobuf field: file.PutRawPieceRequest.Metadata metadata = 1;\n         */\n        metadata: PutRawPieceRequest_Metadata; // first message contains piece metadata\n    } | {\n        oneofKind: \"content\";\n        /**\n         * @generated from protobuf field: file.PutRawPieceRequest.Content content = 2;\n         */\n        content: PutRawPieceRequest_Content; // subsequent messages contain only part of a raw piece data\n    } | {\n        oneofKind: undefined;\n    };\n}\n/**\n * @generated from protobuf message file.PutRawPieceRequest.Metadata\n */\nexport interface PutRawPieceRequest_Metadata {\n    /**\n     * @generated from protobuf field: uint64 bucketId = 1 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint;\n    /**\n     * @generated from protobuf field: optional bytes cid = 2;\n     */\n    cid?: Uint8Array;\n    /**\n     * @generated from protobuf field: optional uint64 offset = 3;\n     */\n    offset?: number; // starting offset of the piece inside a file. Should be set only if isMultipart = true\n    /**\n     * @generated from protobuf field: bool isMultipart = 4;\n     */\n    isMultipart: boolean; // whether the piece is part of a file or not\n    /**\n     * @generated from protobuf field: uint64 size = 5;\n     */\n    size: number; // indicates the size of the content, in bytes\n}\n/**\n * @generated from protobuf message file.PutRawPieceRequest.Content\n */\nexport interface PutRawPieceRequest_Content {\n    /**\n     * @generated from protobuf field: bytes data = 1;\n     */\n    data: Uint8Array;\n}\n/**\n * @generated from protobuf message file.PutRawPieceResponse\n */\nexport interface PutRawPieceResponse {\n    /**\n     * @generated from protobuf field: bytes cid = 1;\n     */\n    cid: Uint8Array; // TBD\n}\n/**\n * @generated from protobuf message file.PutMultiPartPieceRequest\n */\nexport interface PutMultiPartPieceRequest {\n    /**\n     * @generated from protobuf field: uint64 bucketId = 1 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint; // bucket where file is stored\n    /**\n     * @generated from protobuf field: optional bytes cid = 2;\n     */\n    cid?: Uint8Array; // root hash of the file hash tree\n    /**\n     * @generated from protobuf field: uint64 totalSize = 3;\n     */\n    totalSize: number; // size of the multi-part piece (large file total size)\n    /**\n     * @generated from protobuf field: uint64 partSize = 4;\n     */\n    partSize: number; // size of the raw piece (large file part size)\n    /**\n     * @generated from protobuf field: repeated bytes partHashes = 5;\n     */\n    partHashes: Uint8Array[]; // ordered list of the raw piece hashes\n}\n/**\n * @generated from protobuf message file.PutMultiPartPieceResponse\n */\nexport interface PutMultiPartPieceResponse {\n    /**\n     * @generated from protobuf field: bytes cid = 1;\n     */\n    cid: Uint8Array; // TBD\n}\n/**\n * @generated from protobuf message file.GetFileRequest\n */\nexport interface GetFileRequest {\n    /**\n     * @generated from protobuf oneof: Body\n     */\n    body: {\n        oneofKind: \"request\";\n        /**\n         * @generated from protobuf field: file.GetFileRequest.Request request = 1;\n         */\n        request: GetFileRequest_Request;\n    } | {\n        oneofKind: \"ack\";\n        /**\n         * @generated from protobuf field: activity_report.ActivityAcknowledgment ack = 2;\n         */\n        ack: ActivityAcknowledgment;\n    } | {\n        oneofKind: undefined;\n    };\n}\n/**\n * @generated from protobuf message file.GetFileRequest.Request\n */\nexport interface GetFileRequest_Request {\n    /**\n     * @generated from protobuf field: bytes cid = 1;\n     */\n    cid: Uint8Array; // CID of either raw or multi-part piece\n    /**\n     * @generated from protobuf field: uint64 bucketId = 2 [jstype = JS_NORMAL];\n     */\n    bucketId: bigint;\n    /**\n     * @generated from protobuf field: optional file.GetFileRequest.Request.Range range = 3;\n     */\n    range?: GetFileRequest_Request_Range; // indicates part of the file to be returned (return whole file if range is missing)\n    /**\n     * @generated from protobuf field: bool authenticate = 4;\n     */\n    authenticate: boolean;\n}\n/**\n * @generated from protobuf message file.GetFileRequest.Request.Range\n */\nexport interface GetFileRequest_Request_Range {\n    /**\n     * @generated from protobuf field: uint64 start = 1;\n     */\n    start: number;\n    /**\n     * @generated from protobuf field: uint64 end = 2;\n     */\n    end: number;\n}\n/**\n * @generated from protobuf message file.GetFileResponse\n */\nexport interface GetFileResponse {\n    /**\n     * @generated from protobuf oneof: body\n     */\n    body: {\n        oneofKind: \"proof\";\n        /**\n         * @generated from protobuf field: file.GetFileResponse.Proof proof = 1;\n         */\n        proof: GetFileResponse_Proof; // first message contains only merkle proof of requested content for the root (CID)\n    } | {\n        oneofKind: \"data\";\n        /**\n         * @generated from protobuf field: bytes data = 2;\n         */\n        data: Uint8Array; // subsequent messages contain only part of a requested content\n    } | {\n        oneofKind: undefined;\n    };\n}\n/**\n * @generated from protobuf message file.GetFileResponse.Proof\n */\nexport interface GetFileResponse_Proof {\n    /**\n     * @generated from protobuf field: repeated bytes proof = 1;\n     */\n    proof: Uint8Array[];\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutRawPieceRequest$Type extends MessageType<PutRawPieceRequest> {\n    constructor() {\n        super(\"file.PutRawPieceRequest\", [\n            { no: 1, name: \"metadata\", kind: \"message\", oneof: \"body\", T: () => PutRawPieceRequest_Metadata },\n            { no: 2, name: \"content\", kind: \"message\", oneof: \"body\", T: () => PutRawPieceRequest_Content }\n        ]);\n    }\n    create(value?: PartialMessage<PutRawPieceRequest>): PutRawPieceRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.body = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<PutRawPieceRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutRawPieceRequest): PutRawPieceRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* file.PutRawPieceRequest.Metadata metadata */ 1:\n                    message.body = {\n                        oneofKind: \"metadata\",\n                        metadata: PutRawPieceRequest_Metadata.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).metadata)\n                    };\n                    break;\n                case /* file.PutRawPieceRequest.Content content */ 2:\n                    message.body = {\n                        oneofKind: \"content\",\n                        content: PutRawPieceRequest_Content.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).content)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutRawPieceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* file.PutRawPieceRequest.Metadata metadata = 1; */\n        if (message.body.oneofKind === \"metadata\")\n            PutRawPieceRequest_Metadata.internalBinaryWrite(message.body.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* file.PutRawPieceRequest.Content content = 2; */\n        if (message.body.oneofKind === \"content\")\n            PutRawPieceRequest_Content.internalBinaryWrite(message.body.content, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.PutRawPieceRequest\n */\nexport const PutRawPieceRequest = new PutRawPieceRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutRawPieceRequest_Metadata$Type extends MessageType<PutRawPieceRequest_Metadata> {\n    constructor() {\n        super(\"file.PutRawPieceRequest.Metadata\", [\n            { no: 1, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"cid\", kind: \"scalar\", opt: true, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"offset\", kind: \"scalar\", opt: true, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 4, name: \"isMultipart\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ },\n            { no: 5, name: \"size\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PutRawPieceRequest_Metadata>): PutRawPieceRequest_Metadata {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.bucketId = 0n;\n        message.isMultipart = false;\n        message.size = 0;\n        if (value !== undefined)\n            reflectionMergePartial<PutRawPieceRequest_Metadata>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutRawPieceRequest_Metadata): PutRawPieceRequest_Metadata {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/ 1:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* optional bytes cid */ 2:\n                    message.cid = reader.bytes();\n                    break;\n                case /* optional uint64 offset */ 3:\n                    message.offset = reader.uint64().toNumber();\n                    break;\n                case /* bool isMultipart */ 4:\n                    message.isMultipart = reader.bool();\n                    break;\n                case /* uint64 size */ 5:\n                    message.size = reader.uint64().toNumber();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutRawPieceRequest_Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.bucketId);\n        /* optional bytes cid = 2; */\n        if (message.cid !== undefined)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.cid);\n        /* optional uint64 offset = 3; */\n        if (message.offset !== undefined)\n            writer.tag(3, WireType.Varint).uint64(message.offset);\n        /* bool isMultipart = 4; */\n        if (message.isMultipart !== false)\n            writer.tag(4, WireType.Varint).bool(message.isMultipart);\n        /* uint64 size = 5; */\n        if (message.size !== 0)\n            writer.tag(5, WireType.Varint).uint64(message.size);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.PutRawPieceRequest.Metadata\n */\nexport const PutRawPieceRequest_Metadata = new PutRawPieceRequest_Metadata$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutRawPieceRequest_Content$Type extends MessageType<PutRawPieceRequest_Content> {\n    constructor() {\n        super(\"file.PutRawPieceRequest.Content\", [\n            { no: 1, name: \"data\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PutRawPieceRequest_Content>): PutRawPieceRequest_Content {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.data = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<PutRawPieceRequest_Content>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutRawPieceRequest_Content): PutRawPieceRequest_Content {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes data */ 1:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutRawPieceRequest_Content, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes data = 1; */\n        if (message.data.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.data);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.PutRawPieceRequest.Content\n */\nexport const PutRawPieceRequest_Content = new PutRawPieceRequest_Content$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutRawPieceResponse$Type extends MessageType<PutRawPieceResponse> {\n    constructor() {\n        super(\"file.PutRawPieceResponse\", [\n            { no: 1, name: \"cid\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PutRawPieceResponse>): PutRawPieceResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.cid = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<PutRawPieceResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutRawPieceResponse): PutRawPieceResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes cid */ 1:\n                    message.cid = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutRawPieceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes cid = 1; */\n        if (message.cid.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.cid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.PutRawPieceResponse\n */\nexport const PutRawPieceResponse = new PutRawPieceResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutMultiPartPieceRequest$Type extends MessageType<PutMultiPartPieceRequest> {\n    constructor() {\n        super(\"file.PutMultiPartPieceRequest\", [\n            { no: 1, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 2, name: \"cid\", kind: \"scalar\", opt: true, T: 12 /*ScalarType.BYTES*/ },\n            { no: 3, name: \"totalSize\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 4, name: \"partSize\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 5, name: \"partHashes\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PutMultiPartPieceRequest>): PutMultiPartPieceRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.bucketId = 0n;\n        message.totalSize = 0;\n        message.partSize = 0;\n        message.partHashes = [];\n        if (value !== undefined)\n            reflectionMergePartial<PutMultiPartPieceRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutMultiPartPieceRequest): PutMultiPartPieceRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/ 1:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* optional bytes cid */ 2:\n                    message.cid = reader.bytes();\n                    break;\n                case /* uint64 totalSize */ 3:\n                    message.totalSize = reader.uint64().toNumber();\n                    break;\n                case /* uint64 partSize */ 4:\n                    message.partSize = reader.uint64().toNumber();\n                    break;\n                case /* repeated bytes partHashes */ 5:\n                    message.partHashes.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutMultiPartPieceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(1, WireType.Varint).uint64(message.bucketId);\n        /* optional bytes cid = 2; */\n        if (message.cid !== undefined)\n            writer.tag(2, WireType.LengthDelimited).bytes(message.cid);\n        /* uint64 totalSize = 3; */\n        if (message.totalSize !== 0)\n            writer.tag(3, WireType.Varint).uint64(message.totalSize);\n        /* uint64 partSize = 4; */\n        if (message.partSize !== 0)\n            writer.tag(4, WireType.Varint).uint64(message.partSize);\n        /* repeated bytes partHashes = 5; */\n        for (let i = 0; i < message.partHashes.length; i++)\n            writer.tag(5, WireType.LengthDelimited).bytes(message.partHashes[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.PutMultiPartPieceRequest\n */\nexport const PutMultiPartPieceRequest = new PutMultiPartPieceRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PutMultiPartPieceResponse$Type extends MessageType<PutMultiPartPieceResponse> {\n    constructor() {\n        super(\"file.PutMultiPartPieceResponse\", [\n            { no: 1, name: \"cid\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<PutMultiPartPieceResponse>): PutMultiPartPieceResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.cid = new Uint8Array(0);\n        if (value !== undefined)\n            reflectionMergePartial<PutMultiPartPieceResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutMultiPartPieceResponse): PutMultiPartPieceResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes cid */ 1:\n                    message.cid = reader.bytes();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: PutMultiPartPieceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes cid = 1; */\n        if (message.cid.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.cid);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.PutMultiPartPieceResponse\n */\nexport const PutMultiPartPieceResponse = new PutMultiPartPieceResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetFileRequest$Type extends MessageType<GetFileRequest> {\n    constructor() {\n        super(\"file.GetFileRequest\", [\n            { no: 1, name: \"request\", kind: \"message\", oneof: \"body\", T: () => GetFileRequest_Request },\n            { no: 2, name: \"ack\", kind: \"message\", oneof: \"body\", T: () => ActivityAcknowledgment }\n        ]);\n    }\n    create(value?: PartialMessage<GetFileRequest>): GetFileRequest {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.body = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<GetFileRequest>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFileRequest): GetFileRequest {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* file.GetFileRequest.Request request */ 1:\n                    message.body = {\n                        oneofKind: \"request\",\n                        request: GetFileRequest_Request.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).request)\n                    };\n                    break;\n                case /* activity_report.ActivityAcknowledgment ack */ 2:\n                    message.body = {\n                        oneofKind: \"ack\",\n                        ack: ActivityAcknowledgment.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).ack)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* file.GetFileRequest.Request request = 1; */\n        if (message.body.oneofKind === \"request\")\n            GetFileRequest_Request.internalBinaryWrite(message.body.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* activity_report.ActivityAcknowledgment ack = 2; */\n        if (message.body.oneofKind === \"ack\")\n            ActivityAcknowledgment.internalBinaryWrite(message.body.ack, writer.tag(2, WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.GetFileRequest\n */\nexport const GetFileRequest = new GetFileRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetFileRequest_Request$Type extends MessageType<GetFileRequest_Request> {\n    constructor() {\n        super(\"file.GetFileRequest.Request\", [\n            { no: 1, name: \"cid\", kind: \"scalar\", T: 12 /*ScalarType.BYTES*/ },\n            { no: 2, name: \"bucketId\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },\n            { no: 3, name: \"range\", kind: \"message\", T: () => GetFileRequest_Request_Range },\n            { no: 4, name: \"authenticate\", kind: \"scalar\", T: 8 /*ScalarType.BOOL*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetFileRequest_Request>): GetFileRequest_Request {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.cid = new Uint8Array(0);\n        message.bucketId = 0n;\n        message.authenticate = false;\n        if (value !== undefined)\n            reflectionMergePartial<GetFileRequest_Request>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFileRequest_Request): GetFileRequest_Request {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* bytes cid */ 1:\n                    message.cid = reader.bytes();\n                    break;\n                case /* uint64 bucketId = 2 [jstype = JS_NORMAL];*/ 2:\n                    message.bucketId = reader.uint64().toBigInt();\n                    break;\n                case /* optional file.GetFileRequest.Request.Range range */ 3:\n                    message.range = GetFileRequest_Request_Range.internalBinaryRead(reader, reader.uint32(), options, message.range);\n                    break;\n                case /* bool authenticate */ 4:\n                    message.authenticate = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetFileRequest_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* bytes cid = 1; */\n        if (message.cid.length)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.cid);\n        /* uint64 bucketId = 2 [jstype = JS_NORMAL]; */\n        if (message.bucketId !== 0n)\n            writer.tag(2, WireType.Varint).uint64(message.bucketId);\n        /* optional file.GetFileRequest.Request.Range range = 3; */\n        if (message.range)\n            GetFileRequest_Request_Range.internalBinaryWrite(message.range, writer.tag(3, WireType.LengthDelimited).fork(), options).join();\n        /* bool authenticate = 4; */\n        if (message.authenticate !== false)\n            writer.tag(4, WireType.Varint).bool(message.authenticate);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.GetFileRequest.Request\n */\nexport const GetFileRequest_Request = new GetFileRequest_Request$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetFileRequest_Request_Range$Type extends MessageType<GetFileRequest_Request_Range> {\n    constructor() {\n        super(\"file.GetFileRequest.Request.Range\", [\n            { no: 1, name: \"start\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },\n            { no: 2, name: \"end\", kind: \"scalar\", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetFileRequest_Request_Range>): GetFileRequest_Request_Range {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.start = 0;\n        message.end = 0;\n        if (value !== undefined)\n            reflectionMergePartial<GetFileRequest_Request_Range>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFileRequest_Request_Range): GetFileRequest_Request_Range {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* uint64 start */ 1:\n                    message.start = reader.uint64().toNumber();\n                    break;\n                case /* uint64 end */ 2:\n                    message.end = reader.uint64().toNumber();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetFileRequest_Request_Range, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* uint64 start = 1; */\n        if (message.start !== 0)\n            writer.tag(1, WireType.Varint).uint64(message.start);\n        /* uint64 end = 2; */\n        if (message.end !== 0)\n            writer.tag(2, WireType.Varint).uint64(message.end);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.GetFileRequest.Request.Range\n */\nexport const GetFileRequest_Request_Range = new GetFileRequest_Request_Range$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetFileResponse$Type extends MessageType<GetFileResponse> {\n    constructor() {\n        super(\"file.GetFileResponse\", [\n            { no: 1, name: \"proof\", kind: \"message\", oneof: \"body\", T: () => GetFileResponse_Proof },\n            { no: 2, name: \"data\", kind: \"scalar\", oneof: \"body\", T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetFileResponse>): GetFileResponse {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.body = { oneofKind: undefined };\n        if (value !== undefined)\n            reflectionMergePartial<GetFileResponse>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFileResponse): GetFileResponse {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* file.GetFileResponse.Proof proof */ 1:\n                    message.body = {\n                        oneofKind: \"proof\",\n                        proof: GetFileResponse_Proof.internalBinaryRead(reader, reader.uint32(), options, (message.body as any).proof)\n                    };\n                    break;\n                case /* bytes data */ 2:\n                    message.body = {\n                        oneofKind: \"data\",\n                        data: reader.bytes()\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* file.GetFileResponse.Proof proof = 1; */\n        if (message.body.oneofKind === \"proof\")\n            GetFileResponse_Proof.internalBinaryWrite(message.body.proof, writer.tag(1, WireType.LengthDelimited).fork(), options).join();\n        /* bytes data = 2; */\n        if (message.body.oneofKind === \"data\")\n            writer.tag(2, WireType.LengthDelimited).bytes(message.body.data);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.GetFileResponse\n */\nexport const GetFileResponse = new GetFileResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GetFileResponse_Proof$Type extends MessageType<GetFileResponse_Proof> {\n    constructor() {\n        super(\"file.GetFileResponse.Proof\", [\n            { no: 1, name: \"proof\", kind: \"scalar\", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }\n        ]);\n    }\n    create(value?: PartialMessage<GetFileResponse_Proof>): GetFileResponse_Proof {\n        const message = globalThis.Object.create((this.messagePrototype!));\n        message.proof = [];\n        if (value !== undefined)\n            reflectionMergePartial<GetFileResponse_Proof>(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFileResponse_Proof): GetFileResponse_Proof {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while (reader.pos < end) {\n            let [fieldNo, wireType] = reader.tag();\n            switch (fieldNo) {\n                case /* repeated bytes proof */ 1:\n                    message.proof.push(reader.bytes());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\")\n                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false)\n                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message: GetFileResponse_Proof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {\n        /* repeated bytes proof = 1; */\n        for (let i = 0; i < message.proof.length; i++)\n            writer.tag(1, WireType.LengthDelimited).bytes(message.proof[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false)\n            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message file.GetFileResponse.Proof\n */\nexport const GetFileResponse_Proof = new GetFileResponse_Proof$Type();\n/**\n * @generated ServiceType for protobuf service file.FileApi\n */\nexport const FileApi = new ServiceType(\"file.FileApi\", [\n    { name: \"putRawPiece\", clientStreaming: true, options: {}, I: PutRawPieceRequest, O: PutRawPieceResponse },\n    { name: \"putMultipartPiece\", options: {}, I: PutMultiPartPieceRequest, O: PutMultiPartPieceResponse },\n    { name: \"getFile\", serverStreaming: true, clientStreaming: true, options: {}, I: GetFileRequest, O: GetFileResponse }\n]);\n","/* eslint-disable */\n// @generated by protobuf-ts 2.9.3 with parameter long_type_number,generate_dependencies,eslint_disable\n// @generated from protobuf file \"file_api.proto\" (package \"file\", syntax proto3)\n// tslint:disable\nimport type { RpcTransport } from \"@protobuf-ts/runtime-rpc\";\nimport type { ServiceInfo } from \"@protobuf-ts/runtime-rpc\";\nimport { FileApi } from \"./file_api\";\nimport type { GetFileResponse } from \"./file_api\";\nimport type { GetFileRequest } from \"./file_api\";\nimport type { DuplexStreamingCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { PutMultiPartPieceResponse } from \"./file_api\";\nimport type { PutMultiPartPieceRequest } from \"./file_api\";\nimport type { UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport { stackIntercept } from \"@protobuf-ts/runtime-rpc\";\nimport type { PutRawPieceResponse } from \"./file_api\";\nimport type { PutRawPieceRequest } from \"./file_api\";\nimport type { ClientStreamingCall } from \"@protobuf-ts/runtime-rpc\";\nimport type { RpcOptions } from \"@protobuf-ts/runtime-rpc\";\n/**\n * @generated from protobuf service file.FileApi\n */\nexport interface IFileApiClient {\n    /**\n     * @generated from protobuf rpc: putRawPiece(stream file.PutRawPieceRequest) returns (file.PutRawPieceResponse);\n     */\n    putRawPiece(options?: RpcOptions): ClientStreamingCall<PutRawPieceRequest, PutRawPieceResponse>;\n    /**\n     * @generated from protobuf rpc: putMultipartPiece(file.PutMultiPartPieceRequest) returns (file.PutMultiPartPieceResponse);\n     */\n    putMultipartPiece(input: PutMultiPartPieceRequest, options?: RpcOptions): UnaryCall<PutMultiPartPieceRequest, PutMultiPartPieceResponse>;\n    /**\n     * @generated from protobuf rpc: getFile(stream file.GetFileRequest) returns (stream file.GetFileResponse);\n     */\n    getFile(options?: RpcOptions): DuplexStreamingCall<GetFileRequest, GetFileResponse>;\n}\n/**\n * @generated from protobuf service file.FileApi\n */\nexport class FileApiClient implements IFileApiClient, ServiceInfo {\n    typeName = FileApi.typeName;\n    methods = FileApi.methods;\n    options = FileApi.options;\n    constructor(private readonly _transport: RpcTransport) {\n    }\n    /**\n     * @generated from protobuf rpc: putRawPiece(stream file.PutRawPieceRequest) returns (file.PutRawPieceResponse);\n     */\n    putRawPiece(options?: RpcOptions): ClientStreamingCall<PutRawPieceRequest, PutRawPieceResponse> {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return stackIntercept<PutRawPieceRequest, PutRawPieceResponse>(\"clientStreaming\", this._transport, method, opt);\n    }\n    /**\n     * @generated from protobuf rpc: putMultipartPiece(file.PutMultiPartPieceRequest) returns (file.PutMultiPartPieceResponse);\n     */\n    putMultipartPiece(input: PutMultiPartPieceRequest, options?: RpcOptions): UnaryCall<PutMultiPartPieceRequest, PutMultiPartPieceResponse> {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return stackIntercept<PutMultiPartPieceRequest, PutMultiPartPieceResponse>(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: getFile(stream file.GetFileRequest) returns (stream file.GetFileResponse);\n     */\n    getFile(options?: RpcOptions): DuplexStreamingCall<GetFileRequest, GetFileResponse> {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return stackIntercept<GetFileRequest, GetFileResponse>(\"duplex\", this._transport, method, opt);\n    }\n}\n","import { Signer } from '@cere-ddc-sdk/blockchain';\n\nimport { MAX_PIECE_SIZE, MB } from '../constants';\nimport { FileValidator } from '../validators';\nimport { RpcTransport } from '../transports';\nimport { Content, createContentStream, getContentSize, isContentStream } from '../streams';\nimport { createLogger, Logger, LoggerOptions } from '../logger';\nimport { createRpcMeta as createAuthRpcMeta, AuthMetaParams } from '../auth';\nimport {\n  PutMultiPartPieceRequest as ProtoPutMultiPartPieceRequest,\n  GetFileRequest_Request,\n  PutRawPieceRequest_Metadata,\n} from '../grpc/file_api';\nimport { FileApiClient } from '../grpc/file_api.client';\nimport {\n  ActivityRequestType,\n  createAck,\n  createActivityRequest,\n  createRequestId,\n  CorrelationMetaParams,\n  createRpcMeta as createCorrelationRpcMeta,\n} from '../activity';\n\nexport type ReadFileRange = GetFileRequest_Request['range'];\nexport type GetFileRequest = Omit<GetFileRequest_Request, 'authenticate'> & AuthMetaParams & CorrelationMetaParams;\nexport type PutMultiPartPieceRequest = ProtoPutMultiPartPieceRequest & AuthMetaParams & CorrelationMetaParams;\nexport type PutRawPieceMetadata = Omit<PutRawPieceRequest_Metadata, 'size'> &\n  AuthMetaParams &\n  CorrelationMetaParams & {\n    size?: number;\n  };\n\nexport type FileApiOptions = LoggerOptions & {\n  signer?: Signer;\n  authenticate?: boolean;\n  enableAcks?: boolean;\n};\n\nconst ceilToPowerOf2 = (n: number) => Math.pow(2, Math.ceil(Math.log2(n)));\n\n/**\n * The `FileApi` class provides methods to interact with the DDC File API.\n *\n * @group Files\n * @example\n *\n * ```typescript\n * import { FileApi, GrpcTransport } from '@cere-ddc-sdk/ddc';\n *\n * const transport = new GrpcTransport(...);\n * const fileApi = new FileApi(transport);\n * ```\n */\nexport class FileApi {\n  private logger: Logger;\n  private api: FileApiClient;\n  private options: FileApiOptions;\n\n  constructor(transport: RpcTransport, options: FileApiOptions = {}) {\n    this.api = new FileApiClient(transport);\n    this.logger = createLogger('FileApi', options);\n\n    this.options = {\n      ...options,\n      enableAcks: options.enableAcks ?? !!options.signer, // ACKs are enabled by default if signer is provided\n      authenticate: options.authenticate ?? false,\n    };\n  }\n\n  /**\n   * Stores a multipart piece in DDC.\n   *\n   * @param request - An object that includes the access token, the part size, and the piece to store.\n   *\n   * @returns The CID of the stored piece as a `Uint8Array`.\n   *\n   * @example\n   *\n   * ```typescript\n   * const request: PutMultiPartPieceRequest = {\n   *   token: '...',\n   *   partSize: 1024,\n   *   piece: { ... }\n   * };\n   *\n   * const cid = await fileApi.putMultipartPiece(request);\n   *\n   * console.log(cid);\n   * ```\n   */\n  async putMultipartPiece({ token, correlationId, ...request }: PutMultiPartPieceRequest) {\n    const { signer } = this.options;\n    const meta = createCorrelationRpcMeta(correlationId, createAuthRpcMeta(token));\n    const partSize = ceilToPowerOf2(request.partSize);\n    this.logger.debug({ ...request, partSize, token, correlationId }, 'Storing multipart piece');\n\n    if (signer) {\n      meta.request = await createActivityRequest(\n        {\n          bucketId: request.bucketId,\n          size: ProtoPutMultiPartPieceRequest.toBinary(request).byteLength,\n          requestType: ActivityRequestType.STORE,\n        },\n        { token, signer, logger: this.logger },\n      );\n    }\n\n    const { response } = await this.api.putMultipartPiece({ ...request, partSize }, { meta });\n\n    this.logger.debug({ response, correlationId }, 'Multipart piece stored');\n\n    return new Uint8Array(response.cid);\n  }\n\n  /**\n   * Stores a raw piece in DDC.\n   *\n   * @param metadata - An object that includes the access token and the metadata for the raw piece.\n   * @param content - The content of the raw piece as a `Content` object.\n   *\n   * @returns The CID of the stored piece as a `Uint8Array`.\n   *\n   * @throws Will throw an error if the size of the raw piece cannot be determined, or if it exceeds the maximum size.\n   *\n   * @example\n   *\n   * ```typescript\n   * const content: Content = ...;\n   * const metadata: PutRawPieceMetadata = {\n   *   token: '...',\n   *   bucketId: '...',\n   *   ...\n   * };\n   *\n   * const cid = await fileApi.putRawPiece(metadata, content);\n   *\n   * console.log(cid);\n   * ```\n   */\n  async putRawPiece({ token, correlationId, ...metadata }: PutRawPieceMetadata, content: Content) {\n    const meta = createCorrelationRpcMeta(correlationId, createAuthRpcMeta(token));\n    const size = getContentSize(content, metadata.size);\n    const { signer } = this.options;\n\n    this.logger.debug({ metadata, token, correlationId }, 'Storing raw piece of size %d', size);\n\n    if (!size) {\n      throw new Error('Cannot determine the raw piece size');\n    }\n\n    if (size > MAX_PIECE_SIZE) {\n      throw new Error(`Raw piece size should not be greather then ${MAX_PIECE_SIZE / MB} MB`);\n    }\n\n    if (signer) {\n      meta.request = await createActivityRequest(\n        { size, bucketId: metadata.bucketId, requestType: ActivityRequestType.STORE },\n        { token, signer, logger: this.logger },\n      );\n    }\n\n    const call = this.api.putRawPiece({ meta });\n\n    /**\n     * Send none-blocking request message.\n     */\n    call.requests.send({\n      body: {\n        oneofKind: 'metadata',\n        metadata: { ...metadata, size },\n      },\n    });\n\n    /**\n     * Wait for responce headers before start streaming piece content.\n     */\n    const headers = await call.headers;\n    this.logger.debug({ headers, correlationId }, 'Server responded with headers');\n\n    let bytesSent = 0;\n    const contentStream = isContentStream(content) ? content : createContentStream(content);\n    const reader = contentStream.getReader();\n\n    while (bytesSent < MAX_PIECE_SIZE) {\n      const { done, value } = await reader.read();\n\n      if (done || !value) {\n        break;\n      }\n\n      await Promise.race([\n        call.status,\n        call.requests.send({\n          body: { oneofKind: 'content', content: { data: value } },\n        }),\n      ]);\n\n      bytesSent += value.byteLength;\n    }\n\n    reader.releaseLock();\n\n    await call.requests.complete();\n    const { cid } = await call.response;\n    this.logger.debug({ cid, correlationId }, 'Raw piece stored');\n\n    return new Uint8Array(cid);\n  }\n\n  /**\n   * Retrieves a file from DDC.\n   *\n   * @param request - An object that includes the access token, the CID of the file to retrieve, and an optional range.\n   *\n   * @returns A stream of the file's content as a `ContentStream`.\n   *\n   * @example\n   *\n   * ```typescript\n   * const request: GetFileRequest = { token: '...', cid: '...' };\n   *\n   * const contentStream = await fileApi.getFile(request);\n   *\n   * for await (const chunk of contentStream) {\n   *   console.log(chunk);\n   * }\n   * ```\n   */\n  async getFile({ token, correlationId, ...request }: GetFileRequest) {\n    const { enableAcks, signer, authenticate = false } = this.options;\n\n    this.logger.debug({ request, token, correlationId }, 'Started reading data');\n\n    const requestId = createRequestId();\n    const meta = createCorrelationRpcMeta(correlationId, createAuthRpcMeta(token));\n    const validator = new FileValidator(request.cid, {\n      logger: this.logger,\n      enable: authenticate,\n      range: request.range,\n    });\n\n    if (signer) {\n      meta.request = await createActivityRequest(\n        {\n          requestId,\n          id: request.cid,\n          bucketId: request.bucketId,\n          offset: request.range?.start,\n          size: request.range && request.range.end - request.range.start + 1,\n          requestType: ActivityRequestType.GET,\n        },\n        { token, signer, logger: this.logger },\n      );\n    }\n\n    const call = this.api.getFile({ meta });\n\n    /**\n     * Send none-blocking request message.\n     */\n    call.requests.send({\n      body: {\n        oneofKind: 'request',\n        request: { ...request, authenticate },\n      },\n    });\n\n    /**\n     * Wait for responce headers to be received.\n     */\n    const headers = await call.headers;\n    this.logger.debug({ headers, correlationId }, 'Server responded with headers');\n\n    /**\n     * Create data stream from responce messages.\n     */\n    async function* toDataStream(this: FileApi) {\n      let bytesStoredOrDelivered = 0;\n\n      try {\n        for await (const { body } of call.responses) {\n          if (body.oneofKind === 'data') {\n            yield body.data;\n\n            bytesStoredOrDelivered += body.data.byteLength;\n\n            if (enableAcks) {\n              call.requests\n                .send({\n                  body: {\n                    oneofKind: 'ack',\n                    ack: await createAck(\n                      { requestId, bytesStoredOrDelivered, timestamp: Date.now() },\n                      { token, signer, logger: this.logger },\n                    ),\n                  },\n                })\n                .then(() => {\n                  this.logger.info(\n                    'Acknowledgment sent with request ID: %s (%d bytes)',\n                    requestId,\n                    bytesStoredOrDelivered,\n                  );\n                })\n                .catch(() => {\n                  this.logger.warn(\n                    'Failed to send acknowledgment with request ID: %s (%d bytes)',\n                    requestId,\n                    bytesStoredOrDelivered,\n                  );\n                });\n            }\n\n            await validator.update(body.data);\n          }\n\n          if (body.oneofKind === 'proof') {\n            await validator.prove(body.proof);\n          }\n        }\n\n        await call.requests.complete();\n        await validator.validate();\n      } catch (error) {\n        this.logger.error(error, 'An error occurred while reading file stream');\n\n        throw error;\n      }\n    }\n\n    /**\n     * Create content stream from Iterator using original chunk size to avoid unnecessary buffering.\n     */\n    return createContentStream(toDataStream.call(this), null);\n  }\n}\n","import { RpcTransportOptions, RpcTransport } from './RpcTransport';\n\nexport type GrpcTransportOptions = Pick<RpcTransportOptions, 'grpcUrl'>;\n\n// @ts-ignore\nexport class GrpcTransport implements RpcTransport {\n  constructor() {\n    throw new Error('GrpcTransport in not supported in browser environment');\n  }\n}\n","!function(e,t){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=t();else if(\"function\"==typeof define&&define.amd)define([],t);else{var r=t();for(var n in r)(\"object\"==typeof exports?exports:e)[n]=r[n]}}(this,(function(){return e={418:function(e,t){!function(e,t){for(var r in t)e[r]=t[r]}(t,function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.i=function(e){return e},r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=1)}([function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(3),o=function(){function e(e,t){void 0===e&&(e={}),void 0===t&&(t={splitValues:!1});var r,o=this;this.headersMap={},e&&(\"undefined\"!=typeof Headers&&e instanceof Headers?n.getHeaderKeys(e).forEach((function(r){n.getHeaderValues(e,r).forEach((function(e){t.splitValues?o.append(r,n.splitHeaderValue(e)):o.append(r,e)}))})):\"object\"==typeof(r=e)&&\"object\"==typeof r.headersMap&&\"function\"==typeof r.forEach?e.forEach((function(e,t){o.append(e,t)})):\"undefined\"!=typeof Map&&e instanceof Map?e.forEach((function(e,t){o.append(t,e)})):\"string\"==typeof e?this.appendFromString(e):\"object\"==typeof e&&Object.getOwnPropertyNames(e).forEach((function(t){var r=e[t];Array.isArray(r)?r.forEach((function(e){o.append(t,e)})):o.append(t,r)})))}return e.prototype.appendFromString=function(e){for(var t=e.split(\"\\r\\n\"),r=0;r<t.length;r++){var n=t[r],o=n.indexOf(\":\");if(o>0){var s=n.substring(0,o).trim(),i=n.substring(o+1).trim();this.append(s,i)}}},e.prototype.delete=function(e,t){var r=n.normalizeName(e);if(void 0===t)delete this.headersMap[r];else{var o=this.headersMap[r];if(o){var s=o.indexOf(t);s>=0&&o.splice(s,1),0===o.length&&delete this.headersMap[r]}}},e.prototype.append=function(e,t){var r=this,o=n.normalizeName(e);Array.isArray(this.headersMap[o])||(this.headersMap[o]=[]),Array.isArray(t)?t.forEach((function(e){r.headersMap[o].push(n.normalizeValue(e))})):this.headersMap[o].push(n.normalizeValue(t))},e.prototype.set=function(e,t){var r=n.normalizeName(e);if(Array.isArray(t)){var o=[];t.forEach((function(e){o.push(n.normalizeValue(e))})),this.headersMap[r]=o}else this.headersMap[r]=[n.normalizeValue(t)]},e.prototype.has=function(e,t){var r=this.headersMap[n.normalizeName(e)];if(!Array.isArray(r))return!1;if(void 0!==t){var o=n.normalizeValue(t);return r.indexOf(o)>=0}return!0},e.prototype.get=function(e){var t=this.headersMap[n.normalizeName(e)];return void 0!==t?t.concat():[]},e.prototype.forEach=function(e){var t=this;Object.getOwnPropertyNames(this.headersMap).forEach((function(r){e(r,t.headersMap[r])}),this)},e.prototype.toHeaders=function(){if(\"undefined\"!=typeof Headers){var e=new Headers;return this.forEach((function(t,r){r.forEach((function(r){e.append(t,r)}))})),e}throw new Error(\"Headers class is not defined\")},e}();t.BrowserHeaders=o},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(0);t.BrowserHeaders=n.BrowserHeaders},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.iterateHeaders=function(e,t){for(var r=e[Symbol.iterator](),n=r.next();!n.done;)t(n.value[0]),n=r.next()},t.iterateHeadersKeys=function(e,t){for(var r=e.keys(),n=r.next();!n.done;)t(n.value),n=r.next()}},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(2);t.normalizeName=function(e){if(\"string\"!=typeof e&&(e=String(e)),/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(e))throw new TypeError(\"Invalid character in header field name\");return e.toLowerCase()},t.normalizeValue=function(e){return\"string\"!=typeof e&&(e=String(e)),e},t.getHeaderValues=function(e,t){var r=e;if(r instanceof Headers&&r.getAll)return r.getAll(t);var n=r.get(t);return n&&\"string\"==typeof n?[n]:n},t.getHeaderKeys=function(e){var t=e,r={},o=[];return t.keys?n.iterateHeadersKeys(t,(function(e){r[e]||(r[e]=!0,o.push(e))})):t.forEach?t.forEach((function(e,t){r[t]||(r[t]=!0,o.push(t))})):n.iterateHeaders(t,(function(e){var t=e[0];r[t]||(r[t]=!0,o.push(t))})),o},t.splitHeaderValue=function(e){var t=[];return e.split(\", \").forEach((function(e){e.split(\",\").forEach((function(e){t.push(e)}))})),t}}]))},617:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.ChunkParser=t.ChunkType=t.encodeASCII=t.decodeASCII=void 0;var n,o=r(65);function s(e){return 9===(t=e)||10===t||13===t||e>=32&&e<=126;var t}function i(e){for(var t=0;t!==e.length;++t)if(!s(e[t]))throw new Error(\"Metadata is not valid (printable) ASCII\");return String.fromCharCode.apply(String,Array.prototype.slice.call(e))}function a(e){return 128==(128&e.getUint8(0))}function u(e){return e.getUint32(1,!1)}function d(e,t,r){return e.byteLength-t>=r}function c(e,t,r){if(e.slice)return e.slice(t,r);var n=e.length;void 0!==r&&(n=r);for(var o=new Uint8Array(n-t),s=0,i=t;i<n;i++)o[s++]=e[i];return o}t.decodeASCII=i,t.encodeASCII=function(e){for(var t=new Uint8Array(e.length),r=0;r!==e.length;++r){var n=e.charCodeAt(r);if(!s(n))throw new Error(\"Metadata contains invalid ASCII\");t[r]=n}return t},function(e){e[e.MESSAGE=1]=\"MESSAGE\",e[e.TRAILERS=2]=\"TRAILERS\"}(n=t.ChunkType||(t.ChunkType={}));var p=function(){function e(){this.buffer=null,this.position=0}return e.prototype.parse=function(e,t){if(0===e.length&&t)return[];var r,s=[];if(null==this.buffer)this.buffer=e,this.position=0;else if(this.position===this.buffer.byteLength)this.buffer=e,this.position=0;else{var p=this.buffer.byteLength-this.position,h=new Uint8Array(p+e.byteLength),f=c(this.buffer,this.position);h.set(f,0);var l=new Uint8Array(e);h.set(l,p),this.buffer=h,this.position=0}for(;;){if(!d(this.buffer,this.position,5))return s;var g=c(this.buffer,this.position,this.position+5),b=new DataView(g.buffer,g.byteOffset,g.byteLength),y=u(b);if(!d(this.buffer,this.position,5+y))return s;var v=c(this.buffer,this.position+5,this.position+5+y);if(this.position+=5+y,a(b))return s.push({chunkType:n.TRAILERS,trailers:(r=v,new o.Metadata(i(r)))}),s;s.push({chunkType:n.MESSAGE,data:v})}},e}();t.ChunkParser=p},8:function(e,t){\"use strict\";var r;Object.defineProperty(t,\"__esModule\",{value:!0}),t.httpStatusToCode=t.Code=void 0,function(e){e[e.OK=0]=\"OK\",e[e.Canceled=1]=\"Canceled\",e[e.Unknown=2]=\"Unknown\",e[e.InvalidArgument=3]=\"InvalidArgument\",e[e.DeadlineExceeded=4]=\"DeadlineExceeded\",e[e.NotFound=5]=\"NotFound\",e[e.AlreadyExists=6]=\"AlreadyExists\",e[e.PermissionDenied=7]=\"PermissionDenied\",e[e.ResourceExhausted=8]=\"ResourceExhausted\",e[e.FailedPrecondition=9]=\"FailedPrecondition\",e[e.Aborted=10]=\"Aborted\",e[e.OutOfRange=11]=\"OutOfRange\",e[e.Unimplemented=12]=\"Unimplemented\",e[e.Internal=13]=\"Internal\",e[e.Unavailable=14]=\"Unavailable\",e[e.DataLoss=15]=\"DataLoss\",e[e.Unauthenticated=16]=\"Unauthenticated\"}(r=t.Code||(t.Code={})),t.httpStatusToCode=function(e){switch(e){case 0:return r.Internal;case 200:return r.OK;case 400:return r.InvalidArgument;case 401:return r.Unauthenticated;case 403:return r.PermissionDenied;case 404:return r.NotFound;case 409:return r.Aborted;case 412:return r.FailedPrecondition;case 429:return r.ResourceExhausted;case 499:return r.Canceled;case 500:return r.Unknown;case 501:return r.Unimplemented;case 503:return r.Unavailable;case 504:return r.DeadlineExceeded;default:return r.Unknown}}},934:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.client=void 0;var n=r(65),o=r(617),s=r(8),i=r(346),a=r(57),u=r(882);t.client=function(e,t){return new d(e,t)};var d=function(){function e(e,t){this.started=!1,this.sentFirstMessage=!1,this.completed=!1,this.closed=!1,this.finishedSending=!1,this.onHeadersCallbacks=[],this.onMessageCallbacks=[],this.onEndCallbacks=[],this.parser=new o.ChunkParser,this.methodDefinition=e,this.props=t,this.createTransport()}return e.prototype.createTransport=function(){var e=this.props.host+\"/\"+this.methodDefinition.service.serviceName+\"/\"+this.methodDefinition.methodName,t={methodDefinition:this.methodDefinition,debug:this.props.debug||!1,url:e,onHeaders:this.onTransportHeaders.bind(this),onChunk:this.onTransportChunk.bind(this),onEnd:this.onTransportEnd.bind(this)};this.props.transport?this.transport=this.props.transport(t):this.transport=a.makeDefaultTransport(t)},e.prototype.onTransportHeaders=function(e,t){if(this.props.debug&&i.debug(\"onHeaders\",e,t),this.closed)this.props.debug&&i.debug(\"grpc.onHeaders received after request was closed - ignoring\");else if(0===t);else{this.responseHeaders=e,this.props.debug&&i.debug(\"onHeaders.responseHeaders\",JSON.stringify(this.responseHeaders,null,2));var r=c(e);this.props.debug&&i.debug(\"onHeaders.gRPCStatus\",r);var n=r&&r>=0?r:s.httpStatusToCode(t);this.props.debug&&i.debug(\"onHeaders.code\",n);var o=e.get(\"grpc-message\")||[];if(this.props.debug&&i.debug(\"onHeaders.gRPCMessage\",o),this.rawOnHeaders(e),n!==s.Code.OK){var a=this.decodeGRPCStatus(o[0]);this.rawOnError(n,a,e)}}},e.prototype.onTransportChunk=function(e){var t=this;if(this.closed)this.props.debug&&i.debug(\"grpc.onChunk received after request was closed - ignoring\");else{var r=[];try{r=this.parser.parse(e)}catch(e){return this.props.debug&&i.debug(\"onChunk.parsing error\",e,e.message),void this.rawOnError(s.Code.Internal,\"parsing error: \"+e.message)}r.forEach((function(e){if(e.chunkType===o.ChunkType.MESSAGE){var r=t.methodDefinition.responseType.deserializeBinary(e.data);t.rawOnMessage(r)}else e.chunkType===o.ChunkType.TRAILERS&&(t.responseHeaders?(t.responseTrailers=new n.Metadata(e.trailers),t.props.debug&&i.debug(\"onChunk.trailers\",t.responseTrailers)):(t.responseHeaders=new n.Metadata(e.trailers),t.rawOnHeaders(t.responseHeaders)))}))}},e.prototype.onTransportEnd=function(){if(this.props.debug&&i.debug(\"grpc.onEnd\"),this.closed)this.props.debug&&i.debug(\"grpc.onEnd received after request was closed - ignoring\");else if(void 0!==this.responseTrailers){var e=c(this.responseTrailers);if(null!==e){var t=this.responseTrailers.get(\"grpc-message\"),r=this.decodeGRPCStatus(t[0]);this.rawOnEnd(e,r,this.responseTrailers)}else this.rawOnError(s.Code.Internal,\"Response closed without grpc-status (Trailers provided)\")}else{if(void 0===this.responseHeaders)return void this.rawOnError(s.Code.Unknown,\"Response closed without headers\");var n=c(this.responseHeaders),o=this.responseHeaders.get(\"grpc-message\");if(this.props.debug&&i.debug(\"grpc.headers only response \",n,o),null===n)return void this.rawOnEnd(s.Code.Unknown,\"Response closed without grpc-status (Headers only)\",this.responseHeaders);var a=this.decodeGRPCStatus(o[0]);this.rawOnEnd(n,a,this.responseHeaders)}},e.prototype.decodeGRPCStatus=function(e){if(!e)return\"\";try{return decodeURIComponent(e)}catch(t){return e}},e.prototype.rawOnEnd=function(e,t,r){var n=this;this.props.debug&&i.debug(\"rawOnEnd\",e,t,r),this.completed||(this.completed=!0,this.onEndCallbacks.forEach((function(o){if(!n.closed)try{o(e,t,r)}catch(e){setTimeout((function(){throw e}),0)}})))},e.prototype.rawOnHeaders=function(e){this.props.debug&&i.debug(\"rawOnHeaders\",e),this.completed||this.onHeadersCallbacks.forEach((function(t){try{t(e)}catch(e){setTimeout((function(){throw e}),0)}}))},e.prototype.rawOnError=function(e,t,r){var o=this;void 0===r&&(r=new n.Metadata),this.props.debug&&i.debug(\"rawOnError\",e,t),this.completed||(this.completed=!0,this.onEndCallbacks.forEach((function(n){if(!o.closed)try{n(e,t,r)}catch(e){setTimeout((function(){throw e}),0)}})))},e.prototype.rawOnMessage=function(e){var t=this;this.props.debug&&i.debug(\"rawOnMessage\",e.toObject()),this.completed||this.closed||this.onMessageCallbacks.forEach((function(r){if(!t.closed)try{r(e)}catch(e){setTimeout((function(){throw e}),0)}}))},e.prototype.onHeaders=function(e){this.onHeadersCallbacks.push(e)},e.prototype.onMessage=function(e){this.onMessageCallbacks.push(e)},e.prototype.onEnd=function(e){this.onEndCallbacks.push(e)},e.prototype.start=function(e){if(this.started)throw new Error(\"Client already started - cannot .start()\");this.started=!0;var t=new n.Metadata(e||{});t.set(\"content-type\",\"application/grpc-web+proto\"),t.set(\"x-grpc-web\",\"1\"),this.transport.start(t)},e.prototype.send=function(e){if(!this.started)throw new Error(\"Client not started - .start() must be called before .send()\");if(this.closed)throw new Error(\"Client already closed - cannot .send()\");if(this.finishedSending)throw new Error(\"Client already finished sending - cannot .send()\");if(!this.methodDefinition.requestStream&&this.sentFirstMessage)throw new Error(\"Message already sent for non-client-streaming method - cannot .send()\");this.sentFirstMessage=!0;var t=u.frameRequest(e);this.transport.sendMessage(t)},e.prototype.finishSend=function(){if(!this.started)throw new Error(\"Client not started - .finishSend() must be called before .close()\");if(this.closed)throw new Error(\"Client already closed - cannot .send()\");if(this.finishedSending)throw new Error(\"Client already finished sending - cannot .finishSend()\");this.finishedSending=!0,this.transport.finishSend()},e.prototype.close=function(){if(!this.started)throw new Error(\"Client not started - .start() must be called before .close()\");if(this.closed)throw new Error(\"Client already closed - cannot .close()\");this.closed=!0,this.props.debug&&i.debug(\"request.abort aborting request\"),this.transport.cancel()},e}();function c(e){var t=e.get(\"grpc-status\")||[];if(t.length>0)try{var r=t[0];return parseInt(r,10)}catch(e){return null}return null}},346:function(e,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.debug=void 0,t.debug=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];console.debug?console.debug.apply(null,e):console.log.apply(null,e)}},607:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.grpc=void 0;var n,o=r(418),s=r(57),i=r(229),a=r(540),u=r(210),d=r(859),c=r(8),p=r(938),h=r(35),f=r(934);(n=t.grpc||(t.grpc={})).setDefaultTransport=s.setDefaultTransportFactory,n.CrossBrowserHttpTransport=d.CrossBrowserHttpTransport,n.FetchReadableStreamTransport=i.FetchReadableStreamTransport,n.XhrTransport=u.XhrTransport,n.WebsocketTransport=a.WebsocketTransport,n.Code=c.Code,n.Metadata=o.BrowserHeaders,n.client=function(e,t){return f.client(e,t)},n.invoke=p.invoke,n.unary=h.unary},938:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.invoke=void 0;var n=r(934);t.invoke=function(e,t){if(e.requestStream)throw new Error(\".invoke cannot be used with client-streaming methods. Use .client instead.\");var r=n.client(e,{host:t.host,transport:t.transport,debug:t.debug});return t.onHeaders&&r.onHeaders(t.onHeaders),t.onMessage&&r.onMessage(t.onMessage),t.onEnd&&r.onEnd(t.onEnd),r.start(t.metadata),r.send(t.request),r.finishSend(),{close:function(){r.close()}}}},65:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.Metadata=void 0;var n=r(418);Object.defineProperty(t,\"Metadata\",{enumerable:!0,get:function(){return n.BrowserHeaders}})},57:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.makeDefaultTransport=t.setDefaultTransportFactory=void 0;var n=r(859),o=function(e){return n.CrossBrowserHttpTransport({withCredentials:!1})(e)};t.setDefaultTransportFactory=function(e){o=e},t.makeDefaultTransport=function(e){return o(e)}},229:function(e,t,r){\"use strict\";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var o in t=arguments[r])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)};Object.defineProperty(t,\"__esModule\",{value:!0}),t.detectFetchSupport=t.FetchReadableStreamTransport=void 0;var o=r(65),s=r(346);t.FetchReadableStreamTransport=function(e){return function(t){return function(e,t){return e.debug&&s.debug(\"fetchRequest\",e),new i(e,t)}(t,e)}};var i=function(){function e(e,t){this.cancelled=!1,this.controller=self.AbortController&&new AbortController,this.options=e,this.init=t}return e.prototype.pump=function(e,t){var r=this;if(this.reader=e,this.cancelled)return this.options.debug&&s.debug(\"Fetch.pump.cancel at first pump\"),void this.reader.cancel().catch((function(e){r.options.debug&&s.debug(\"Fetch.pump.reader.cancel exception\",e)}));this.reader.read().then((function(e){if(e.done)return r.options.onEnd(),t;r.options.onChunk(e.value),r.pump(r.reader,t)})).catch((function(e){r.cancelled?r.options.debug&&s.debug(\"Fetch.catch - request cancelled\"):(r.cancelled=!0,r.options.debug&&s.debug(\"Fetch.catch\",e.message),r.options.onEnd(e))}))},e.prototype.send=function(e){var t=this;fetch(this.options.url,n(n({},this.init),{headers:this.metadata.toHeaders(),method:\"POST\",body:e,signal:this.controller&&this.controller.signal})).then((function(e){if(t.options.debug&&s.debug(\"Fetch.response\",e),t.options.onHeaders(new o.Metadata(e.headers),e.status),!e.body)return e;t.pump(e.body.getReader(),e)})).catch((function(e){t.cancelled?t.options.debug&&s.debug(\"Fetch.catch - request cancelled\"):(t.cancelled=!0,t.options.debug&&s.debug(\"Fetch.catch\",e.message),t.options.onEnd(e))}))},e.prototype.sendMessage=function(e){this.send(e)},e.prototype.finishSend=function(){},e.prototype.start=function(e){this.metadata=e},e.prototype.cancel=function(){var e=this;this.cancelled?this.options.debug&&s.debug(\"Fetch.cancel already cancelled\"):(this.cancelled=!0,this.controller?(this.options.debug&&s.debug(\"Fetch.cancel.controller.abort\"),this.controller.abort()):this.options.debug&&s.debug(\"Fetch.cancel.missing abort controller\"),this.reader?(this.options.debug&&s.debug(\"Fetch.cancel.reader.cancel\"),this.reader.cancel().catch((function(t){e.options.debug&&s.debug(\"Fetch.cancel.reader.cancel exception\",t)}))):this.options.debug&&s.debug(\"Fetch.cancel before reader\"))},e}();t.detectFetchSupport=function(){return\"undefined\"!=typeof Response&&Response.prototype.hasOwnProperty(\"body\")&&\"function\"==typeof Headers}},859:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.CrossBrowserHttpTransport=void 0;var n=r(229),o=r(210);t.CrossBrowserHttpTransport=function(e){if(n.detectFetchSupport()){var t={credentials:e.withCredentials?\"include\":\"same-origin\"};return n.FetchReadableStreamTransport(t)}return o.XhrTransport({withCredentials:e.withCredentials})}},210:function(e,t,r){\"use strict\";var n,o=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,\"__esModule\",{value:!0}),t.stringToArrayBuffer=t.MozChunkedArrayBufferXHR=t.XHR=t.XhrTransport=void 0;var s=r(65),i=r(346),a=r(849);t.XhrTransport=function(e){return function(t){if(a.detectMozXHRSupport())return new d(t,e);if(a.detectXHROverrideMimeTypeSupport())return new u(t,e);throw new Error(\"This environment's XHR implementation cannot support binary transfer.\")}};var u=function(){function e(e,t){this.options=e,this.init=t}return e.prototype.onProgressEvent=function(){this.options.debug&&i.debug(\"XHR.onProgressEvent.length: \",this.xhr.response.length);var e=this.xhr.response.substr(this.index);this.index=this.xhr.response.length;var t=p(e);this.options.onChunk(t)},e.prototype.onLoadEvent=function(){this.options.debug&&i.debug(\"XHR.onLoadEvent\"),this.options.onEnd()},e.prototype.onStateChange=function(){this.options.debug&&i.debug(\"XHR.onStateChange\",this.xhr.readyState),this.xhr.readyState===XMLHttpRequest.HEADERS_RECEIVED&&this.options.onHeaders(new s.Metadata(this.xhr.getAllResponseHeaders()),this.xhr.status)},e.prototype.sendMessage=function(e){this.xhr.send(e)},e.prototype.finishSend=function(){},e.prototype.start=function(e){var t=this;this.metadata=e;var r=new XMLHttpRequest;this.xhr=r,r.open(\"POST\",this.options.url),this.configureXhr(),this.metadata.forEach((function(e,t){r.setRequestHeader(e,t.join(\", \"))})),r.withCredentials=Boolean(this.init.withCredentials),r.addEventListener(\"readystatechange\",this.onStateChange.bind(this)),r.addEventListener(\"progress\",this.onProgressEvent.bind(this)),r.addEventListener(\"loadend\",this.onLoadEvent.bind(this)),r.addEventListener(\"error\",(function(e){t.options.debug&&i.debug(\"XHR.error\",e),t.options.onEnd(e.error)}))},e.prototype.configureXhr=function(){this.xhr.responseType=\"text\",this.xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")},e.prototype.cancel=function(){this.options.debug&&i.debug(\"XHR.abort\"),this.xhr.abort()},e}();t.XHR=u;var d=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return o(t,e),t.prototype.configureXhr=function(){this.options.debug&&i.debug(\"MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'\"),this.xhr.responseType=\"moz-chunked-arraybuffer\"},t.prototype.onProgressEvent=function(){var e=this.xhr.response;this.options.debug&&i.debug(\"MozXHR.onProgressEvent: \",new Uint8Array(e)),this.options.onChunk(new Uint8Array(e))},t}(u);function c(e,t){var r=e.charCodeAt(t);if(r>=55296&&r<=56319){var n=e.charCodeAt(t+1);n>=56320&&n<=57343&&(r=65536+(r-55296<<10)+(n-56320))}return r}function p(e){for(var t=new Uint8Array(e.length),r=0,n=0;n<e.length;n++){var o=String.prototype.codePointAt?e.codePointAt(n):c(e,n);t[r++]=255&o}return t}t.MozChunkedArrayBufferXHR=d,t.stringToArrayBuffer=p},849:function(e,t){\"use strict\";var r;function n(){if(void 0!==r)return r;if(XMLHttpRequest){r=new XMLHttpRequest;try{r.open(\"GET\",\"https://localhost\")}catch(e){}}return r}function o(e){var t=n();if(!t)return!1;try{return t.responseType=e,t.responseType===e}catch(e){}return!1}Object.defineProperty(t,\"__esModule\",{value:!0}),t.detectXHROverrideMimeTypeSupport=t.detectMozXHRSupport=t.xhrSupportsResponseType=void 0,t.xhrSupportsResponseType=o,t.detectMozXHRSupport=function(){return\"undefined\"!=typeof XMLHttpRequest&&o(\"moz-chunked-arraybuffer\")},t.detectXHROverrideMimeTypeSupport=function(){return\"undefined\"!=typeof XMLHttpRequest&&XMLHttpRequest.prototype.hasOwnProperty(\"overrideMimeType\")}},540:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.WebsocketTransport=void 0;var n,o=r(346),s=r(617);!function(e){e[e.FINISH_SEND=1]=\"FINISH_SEND\"}(n||(n={}));var i=new Uint8Array([1]);t.WebsocketTransport=function(){return function(e){return function(e){e.debug&&o.debug(\"websocketRequest\",e);var t,r=function(e){if(\"https://\"===e.substr(0,8))return\"wss://\"+e.substr(8);if(\"http://\"===e.substr(0,7))return\"ws://\"+e.substr(7);throw new Error(\"Websocket transport constructed with non-https:// or http:// host.\")}(e.url),a=[];function u(e){if(e===n.FINISH_SEND)t.send(i);else{var r=e,o=new Int8Array(r.byteLength+1);o.set(new Uint8Array([0])),o.set(r,1),t.send(o)}}return{sendMessage:function(e){t&&t.readyState!==t.CONNECTING?u(e):a.push(e)},finishSend:function(){t&&t.readyState!==t.CONNECTING?u(n.FINISH_SEND):a.push(n.FINISH_SEND)},start:function(n){(t=new WebSocket(r,[\"grpc-websockets\"])).binaryType=\"arraybuffer\",t.onopen=function(){var r;e.debug&&o.debug(\"websocketRequest.onopen\"),t.send((r=\"\",n.forEach((function(e,t){r+=e+\": \"+t.join(\", \")+\"\\r\\n\"})),s.encodeASCII(r))),a.forEach((function(e){u(e)}))},t.onclose=function(t){e.debug&&o.debug(\"websocketRequest.onclose\",t),e.onEnd()},t.onerror=function(t){e.debug&&o.debug(\"websocketRequest.onerror\",t)},t.onmessage=function(t){e.onChunk(new Uint8Array(t.data))}},cancel:function(){e.debug&&o.debug(\"websocket.abort\"),t.close()}}}(e)}}},35:function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.unary=void 0;var n=r(65),o=r(934);t.unary=function(e,t){if(e.responseStream)throw new Error(\".unary cannot be used with server-streaming methods. Use .invoke or .client instead.\");if(e.requestStream)throw new Error(\".unary cannot be used with client-streaming methods. Use .client instead.\");var r=null,s=null,i=o.client(e,{host:t.host,transport:t.transport,debug:t.debug});return i.onHeaders((function(e){r=e})),i.onMessage((function(e){s=e})),i.onEnd((function(e,o,i){t.onEnd({status:e,statusMessage:o,headers:r||new n.Metadata,message:s,trailers:i})})),i.start(t.metadata),i.send(t.request),i.finishSend(),{close:function(){i.close()}}}},882:function(e,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.frameRequest=void 0,t.frameRequest=function(e){var t=e.serializeBinary(),r=new ArrayBuffer(t.byteLength+5);return new DataView(r,1,4).setUint32(0,t.length,!1),new Uint8Array(r,5).set(t),new Uint8Array(r)}}},t={},function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(607);var e,t}));","import {\n  MethodInfo,\n  NextClientStreamingFn,\n  NextDuplexStreamingFn,\n  NextServerStreamingFn,\n  NextUnaryFn,\n  RpcError,\n  RpcInterceptor,\n  RpcOptions,\n} from '@protobuf-ts/runtime-rpc';\n\nimport { GrpcStatus } from '../grpc/status';\n\nclass TimeoutAbortController extends AbortController {\n  private timeoutHandle: NodeJS.Timeout | undefined;\n\n  constructor(readonly timeout: number) {\n    super();\n\n    this.timeout = timeout;\n  }\n\n  stop = () => {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n\n  start = () => {\n    this.stop();\n\n    this.timeoutHandle = setTimeout(\n      () => this.abort(new RpcError('Request timed out', GrpcStatus[GrpcStatus.CANCELLED])),\n      this.timeout,\n    );\n\n    return this;\n  };\n}\n\nconst composeSignal = (sigA: AbortSignal, sigB?: AbortSignal) => {\n  if (!sigB) {\n    return sigA;\n  }\n\n  const controller = new AbortController();\n  const abortHandler = () => {\n    if (!controller.signal.aborted) {\n      controller.abort();\n    }\n  };\n\n  sigA.addEventListener('abort', abortHandler);\n  sigB.addEventListener('abort', abortHandler);\n\n  return controller.signal;\n};\n\n/**\n * An interceptor that adds a timeout to all RPC calls.\n *\n * TODO: This interceptor adds timeout to `headers` promise only for now, since the SDK cannot retry ongoing requests for now.\n */\nexport class TimeoutInterceptor implements RpcInterceptor {\n  constructor(readonly timeout: number) {}\n\n  private start(options: RpcOptions) {\n    const controller = new TimeoutAbortController(this.timeout);\n\n    return [controller.start(), composeSignal(controller.signal, options.abort)] as const;\n  }\n\n  interceptDuplex(next: NextDuplexStreamingFn, method: MethodInfo, options: RpcOptions) {\n    const [controller, abort] = this.start(options);\n    const call = next(method, { ...options, abort });\n\n    call.headers.then(controller.stop, controller.stop);\n\n    return call;\n  }\n\n  interceptServerStreaming(next: NextServerStreamingFn, method: MethodInfo, input: object, options: RpcOptions) {\n    const [controller, abort] = this.start(options);\n    const call = next(method, input, { ...options, abort });\n\n    call.headers.then(controller.stop, controller.stop);\n\n    return call;\n  }\n\n  interceptClientStreaming(next: NextClientStreamingFn, method: MethodInfo<any, any>, options: RpcOptions) {\n    const [controller, abort] = this.start(options);\n    const call = next(method, { ...options, abort });\n\n    call.headers.then(controller.stop, controller.stop);\n\n    return call;\n  }\n\n  interceptUnary(next: NextUnaryFn, method: MethodInfo, input: object, { timeout, ...options }: RpcOptions) {\n    return next(method, input, { ...options, timeout: timeout ?? this.timeout });\n  }\n}\n","import { grpc } from '@improbable-eng/grpc-web';\nimport { IMessageType } from '@protobuf-ts/runtime';\nimport { GrpcOptions } from '@protobuf-ts/grpc-transport';\nimport {\n  ClientStreamingCall,\n  DuplexStreamingCall,\n  MethodInfo,\n  RpcOptions,\n  ServerStreamingCall,\n  UnaryCall,\n  mergeRpcOptions,\n  Deferred,\n  RpcMetadata,\n  RpcStatus,\n  RpcError,\n  RpcInputStream,\n  RpcOutputStreamController,\n  DeferredState,\n} from '@protobuf-ts/runtime-rpc';\n\nimport { GrpcStatus } from '../grpc/status';\nimport { RpcTransport, RpcTransportOptions } from './RpcTransport';\nimport { TimeoutInterceptor } from './TimeoutInterceptor';\n\nexport type WebsocketTransportOptions = Pick<RpcTransportOptions, 'httpUrl' | 'ssl' | 'timeout'> &\n  Pick<GrpcOptions, 'interceptors'>;\n\nconst createHost = ({ httpUrl, ssl }: WebsocketTransportOptions) => {\n  const sanitizedUrl = /^https?:\\/\\//i.test(httpUrl) ? httpUrl : `http://${httpUrl}`;\n  const url = new URL(sanitizedUrl);\n\n  if (ssl) {\n    url.protocol = 'https:';\n  }\n\n  return url.href.replace(/\\/+$/, '');\n};\n\nconst getStatus = (headers: grpc.Metadata): RpcStatus | null => {\n  const [statusCode] = headers.get('grpc-status') || [];\n  const [message] = headers.get('grpc-message') || [];\n\n  return statusCode ? { code: GrpcStatus[Number(statusCode)], detail: message || '' } : null;\n};\n\n/**\n * The `WebsocketTransport` class represents a gRPC transport layer for RPC communication over WebSockets.\n *\n * @group RPC Transport\n */\nexport class WebsocketTransport implements RpcTransport {\n  private defaultOptions: RpcOptions = {};\n  private host: string;\n\n  constructor({ timeout, interceptors = [], ...options }: WebsocketTransportOptions) {\n    this.host = createHost(options);\n\n    this.defaultOptions = {\n      interceptors: timeout ? [new TimeoutInterceptor(timeout), ...interceptors] : interceptors,\n    };\n  }\n\n  clientStreaming<I extends object, O extends object>(\n    method: MethodInfo<I, O>,\n    options: RpcOptions,\n  ): ClientStreamingCall<I, O> {\n    const InputType = mapType(method.I);\n    const defHeader = new Deferred<RpcMetadata>();\n    const defMessage = new Deferred<O>();\n    const defStatus = new Deferred<RpcStatus>();\n    const defTrailer = new Deferred<RpcMetadata>();\n\n    const client = grpc.client(\n      {\n        methodName: method.name,\n        requestStream: true,\n        responseStream: false,\n        requestType: InputType,\n        responseType: mapType(method.O),\n        service: {\n          serviceName: method.service.typeName,\n        },\n      },\n      {\n        host: this.host,\n        transport: grpc.WebsocketTransport(),\n      },\n    );\n\n    const emitError = (error: RpcError) => {\n      defHeader.rejectPending(error);\n      defMessage.rejectPending(error);\n      defStatus.rejectPending(error);\n      defTrailer.rejectPending(error);\n    };\n\n    if (options.abort) {\n      options.abort.addEventListener('abort', () => {\n        emitError(options.abort!.reason || new RpcError('Canceled by client', GrpcStatus[GrpcStatus.CANCELLED]));\n\n        client.close();\n      });\n    }\n\n    client.onHeaders((meta) => {\n      const status = getStatus(meta);\n\n      if (status && status.code !== GrpcStatus[GrpcStatus.OK]) {\n        return defHeader.rejectPending(new RpcError(status.detail, status.code));\n      }\n\n      defHeader.resolvePending(meta.headersMap);\n    });\n\n    client.onMessage((message) => {\n      defMessage.resolvePending(message.toObject() as any);\n    });\n\n    client.onEnd((status, statusMessage, trailers) => {\n      if (status !== grpc.Code.OK) {\n        return emitError(new RpcError(statusMessage, GrpcStatus[status]));\n      }\n\n      defStatus.resolvePending({ code: GrpcStatus[status], detail: statusMessage });\n      defTrailer.resolvePending(trailers.headersMap);\n    });\n\n    client.start(new grpc.Metadata(options.meta));\n\n    const inputStream: RpcInputStream<any> = {\n      send: async (message) => client.send(new InputType(message)),\n      complete: async () => client.finishSend(),\n    };\n\n    return new ClientStreamingCall<I, O>(\n      method,\n      options.meta ?? {},\n      inputStream,\n      defHeader.promise,\n      defMessage.promise,\n      defStatus.promise,\n      defTrailer.promise,\n    );\n  }\n\n  duplex<I extends object, O extends object>(method: MethodInfo<I, O>, options: RpcOptions): DuplexStreamingCall<I, O> {\n    const InputType = mapType(method.I);\n    const defHeader = new Deferred<RpcMetadata>();\n    const outStream = new RpcOutputStreamController<O>();\n    const defStatus = new Deferred<RpcStatus>();\n    const defTrailer = new Deferred<RpcMetadata>();\n\n    const client = grpc.client(\n      {\n        methodName: method.name,\n        requestStream: true,\n        responseStream: true,\n        requestType: InputType,\n        responseType: mapType(method.O),\n        service: {\n          serviceName: method.service.typeName,\n        },\n      },\n      {\n        host: this.host,\n        transport: grpc.WebsocketTransport(),\n      },\n    );\n\n    const emitError = (error: RpcError) => {\n      defHeader.rejectPending(error);\n      defStatus.rejectPending(error);\n      defTrailer.rejectPending(error);\n\n      if (!outStream.closed) {\n        outStream.notifyError(error);\n      }\n    };\n\n    if (options.abort) {\n      options.abort.addEventListener('abort', () => {\n        emitError(options.abort!.reason || new RpcError('Canceled by client', GrpcStatus[GrpcStatus.CANCELLED]));\n\n        client.close();\n      });\n    }\n\n    client.onHeaders((meta) => {\n      const status = getStatus(meta);\n\n      if (status && status.code !== GrpcStatus[GrpcStatus.OK]) {\n        return defHeader.rejectPending(new RpcError(status.detail, status.code));\n      }\n\n      defHeader.resolvePending(meta.headersMap);\n    });\n\n    client.onMessage((message) => {\n      outStream.notifyMessage(message.toObject() as any);\n    });\n\n    client.onEnd((status, statusMessage, trailers) => {\n      if (status !== grpc.Code.OK) {\n        return emitError(new RpcError(statusMessage, GrpcStatus[status]));\n      }\n\n      defStatus.resolvePending({ code: GrpcStatus[status], detail: statusMessage });\n      defTrailer.resolvePending(trailers.headersMap);\n\n      if (!outStream.closed) {\n        outStream.notifyComplete();\n      }\n    });\n\n    client.start(new grpc.Metadata(options.meta));\n\n    const inputStream: RpcInputStream<any> = {\n      send: async (message) => {\n        client.send(new InputType(message));\n      },\n\n      complete: async () => {\n        if (defStatus.state === DeferredState.PENDING) {\n          client.finishSend();\n        }\n      },\n    };\n\n    return new DuplexStreamingCall(\n      method,\n      options.meta ?? {},\n      inputStream,\n      defHeader.promise,\n      outStream,\n      defStatus.promise,\n      defTrailer.promise,\n    );\n  }\n\n  mergeOptions(options?: Partial<RpcOptions>): RpcOptions {\n    return mergeRpcOptions(this.defaultOptions, options);\n  }\n\n  serverStreaming<I extends object, O extends object>(): ServerStreamingCall<I, O> {\n    throw new Error('Not implemented');\n  }\n\n  unary<I extends object, O extends object>(method: MethodInfo<I, O>, input: I, options: RpcOptions): UnaryCall<I, O> {\n    const InputType = mapType(method.I);\n    const defHeader = new Deferred<RpcMetadata>();\n    const defMessage = new Deferred<O>();\n    const defStatus = new Deferred<RpcStatus>();\n    const defTrailer = new Deferred<RpcMetadata>();\n\n    const request = new Promise<grpc.UnaryOutput<grpc.ProtobufMessage>>((onEnd, reject) => {\n      const client = grpc.unary(\n        {\n          methodName: method.name,\n          requestStream: false,\n          responseStream: false,\n          requestType: InputType,\n          responseType: mapType(method.O),\n          service: {\n            serviceName: method.service.typeName,\n          },\n        },\n        {\n          host: this.host,\n          transport: grpc.WebsocketTransport(),\n          metadata: new grpc.Metadata(options.meta),\n          request: new InputType(input),\n          onEnd,\n        },\n      );\n\n      if (options.abort) {\n        options.abort.addEventListener('abort', () => {\n          reject(options.abort?.reason || new RpcError('Canceled by client', GrpcStatus[GrpcStatus.CANCELLED]));\n\n          client.close();\n        });\n      }\n    });\n\n    request\n      .then((output) => {\n        defHeader.resolvePending(output.headers.headersMap);\n        defTrailer.resolvePending(output.headers.headersMap);\n        defStatus.resolvePending({\n          code: GrpcStatus[output.status],\n          detail: output.statusMessage,\n        });\n\n        if (output.status !== grpc.Code.OK) {\n          throw new RpcError(output.statusMessage, GrpcStatus[output.status]);\n        }\n\n        if (output.message) {\n          defMessage.resolvePending(output.message.toObject() as any);\n        }\n      })\n      .catch((error) => {\n        error.methodName = method.name;\n        error.serviceName = method.service.typeName;\n        defHeader.rejectPending(error);\n        defMessage.rejectPending(error);\n        defStatus.rejectPending(error);\n        defTrailer.rejectPending(error);\n      });\n\n    return new UnaryCall<I, O>(\n      method,\n      options.meta ?? {},\n      input,\n      defHeader.promise,\n      defMessage.promise,\n      defStatus.promise,\n      defTrailer.promise,\n    );\n  }\n}\n\nconst mapType = (NativeType: IMessageType<any>) => {\n  class WebType implements grpc.ProtobufMessage {\n    constructor(public payload = NativeType.create()) {}\n\n    serializeBinary(): Uint8Array {\n      return NativeType.toBinary(this.payload);\n    }\n\n    toObject(): any {\n      return this.payload;\n    }\n\n    static deserializeBinary = (bytes: Uint8Array): WebType => {\n      const message = NativeType.fromBinary(bytes);\n\n      return new WebType(message);\n    };\n  }\n\n  return WebType;\n};\n","import { WebsocketTransport } from './WebsocketTransport';\n\nexport class DefaultTransport extends WebsocketTransport {}\n","import { consumers, Content, ContentStream, createContentStream, isContentStream, getContentSize } from './streams';\n\nimport { ReadFileRange } from './FileApi';\nimport { Cid } from './Cid';\n\ntype StaticPieceMeta = {\n  multipartOffset?: number;\n  size?: number;\n};\n\ntype StreamPieceMeta = {\n  multipartOffset?: number;\n  size: number;\n};\n\nexport type PieceMeta = StaticPieceMeta;\nexport type MultipartPieceMeta = {\n  partSize: number;\n  totalSize: number;\n};\n\nexport type PieceResponseMeta = {\n  range?: ReadFileRange;\n};\n\n/**\n * The `Piece` class represents a piece of content.\n *\n * @group Files\n *\n * @example\n *\n * ```typescript\n * const content = new Uint8Array([1, 2, 3]);\n * const piece = new Piece(content, { size: 3 });\n *\n * console.log(Piece.isPiece(piece)); // true\n * ```\n */\nexport class Piece {\n  private contentLength?: number;\n  protected content: Content;\n\n  /**\n   * The offset of the piece in a multipart upload.\n   */\n  public offset?: number;\n\n  /**\n   * The content of the piece as a stream.\n   */\n  readonly body: ContentStream;\n\n  /**\n   * The metadata for the piece.\n   */\n  readonly meta: PieceMeta;\n\n  constructor(content: Content, meta: StreamPieceMeta);\n  constructor(content: Uint8Array, meta?: StaticPieceMeta);\n  constructor(content: Content, meta: PieceMeta = {}) {\n    this.offset = meta.multipartOffset;\n    this.body = isContentStream(content) ? content : createContentStream(content);\n    this.contentLength = getContentSize(content, meta.size);\n    this.meta = meta;\n    this.content = content;\n  }\n\n  /**\n   * Checks if the piece is part of a multipart upload.\n   */\n  get isPart() {\n    return this.offset !== undefined;\n  }\n\n  /**\n   * The size of the piece.\n   */\n  get size() {\n    if (!this.contentLength) {\n      throw new Error('The piece size can not be determined');\n    }\n\n    return this.contentLength;\n  }\n\n  /**\n   * Checks if an object is an instance of `Piece`.\n   *\n   * @param object - The object to check.\n   *\n   * @returns `true` if the object is an instance of `Piece` or has the same properties as a `Piece`, `false` otherwise.\n   */\n  static isPiece(object: unknown): object is Piece {\n    const maybePiece = object as Piece | null;\n\n    if (object instanceof Piece) {\n      return true;\n    }\n\n    return (\n      typeof maybePiece === 'object' &&\n      typeof maybePiece?.meta === 'object' &&\n      typeof maybePiece.isPart === 'boolean' &&\n      !!maybePiece.body\n    );\n  }\n\n  /**\n   * Checks if an object is an instance of `Piece` with static content.\n   *\n   * @param object - The object to check.\n   *\n   * @returns `true` if the object is an instance of `Piece` and its content is a `Uint8Array`, `false` otherwise.\n   */\n  static isStaticPiece(object: unknown): object is Piece {\n    return Piece.isPiece(object) && object.content instanceof Uint8Array;\n  }\n\n  /**\n   * Creates a new `Piece` from an existing one.\n   *\n   * @param piece - The existing `Piece` to create a new one from.\n   *\n   * @returns A new `Piece` with the same content and metadata as the existing one.\n   */\n  static from(piece: Piece) {\n    if (isContentStream(piece.content) && piece.content.locked) {\n      throw new Error('The content stream is locked and can not be reused');\n    }\n\n    return new Piece(piece.content, piece.meta as StreamPieceMeta);\n  }\n}\n\n/**\n * The `MultipartPiece` class represents a piece cobined from multiple parts (raw pieces).\n *\n * @group Files\n *\n * @example\n *\n * ```typescript\n * const parts = ['CID1', 'CID2'];\n * const multipartPiece = new MultipartPiece(parts, {\n *  partSize: 1024,\n *  totalSize: 2048,\n * });\n *\n * console.log(MultipartPiece.isMultipartPiece(multipartPiece)); // true\n * ```\n */\nexport class MultipartPiece {\n  /**\n   * The hashes of the parts of the multipart piece.\n   */\n  readonly partHashes: Uint8Array[];\n\n  /**\n   * The metadata of the multipart piece.\n   */\n  readonly meta: MultipartPieceMeta;\n\n  /**\n   * The parts of the multipart piece.\n   */\n  readonly parts: string[];\n\n  constructor(parts: string[], meta: MultipartPieceMeta) {\n    this.partHashes = parts.map((part) => new Cid(part).contentHash);\n    this.meta = meta;\n    this.parts = parts;\n  }\n\n  /**\n   * Checks if an object is an instance of `MultipartPiece`.\n   *\n   * @param object - The object to check.\n   *\n   * @returns `true` if the object is an instance of `MultipartPiece` or has the same properties as a `MultipartPiece`, `false` otherwise.\n   */\n  static isMultipartPiece(object: unknown): object is MultipartPiece {\n    const maybeMultipartPiece = object as MultipartPiece | null;\n\n    if (object instanceof MultipartPiece) {\n      return true;\n    }\n\n    return (\n      typeof maybeMultipartPiece === 'object' &&\n      typeof maybeMultipartPiece?.meta === 'object' &&\n      typeof maybeMultipartPiece.meta.partSize === 'number' &&\n      typeof maybeMultipartPiece.meta.totalSize === 'number' &&\n      Array.isArray(maybeMultipartPiece.parts) &&\n      Array.isArray(maybeMultipartPiece.partHashes)\n    );\n  }\n}\n\n/**\n * The `PieceResponse` class represents a response for a piece content.\n *\n * @group Files\n */\nexport class PieceResponse {\n  protected cidObject: Cid;\n  protected meta?: PieceResponseMeta;\n\n  /**\n   * The content of the piece response as a stream.\n   */\n  readonly body: ContentStream;\n\n  constructor(cid: string | Uint8Array | Cid, body: ContentStream, meta?: PieceResponseMeta) {\n    this.cidObject = cid instanceof Cid ? cid : new Cid(cid);\n    this.body = body;\n    this.meta = meta;\n  }\n\n  /**\n   * The range of the piece response.\n   */\n  get range(): ReadFileRange {\n    return this.meta?.range;\n  }\n\n  /**\n   * The hash of the piece response content.\n   */\n  get hash() {\n    return this.cidObject.contentHash;\n  }\n\n  /**\n   * The content identifier (CID) of the piece.\n   */\n  get cid() {\n    return this.cidObject.toString();\n  }\n\n  /**\n   * Converts the body stream of the piece to an `ArrayBuffer`.\n   *\n   * @returns The piece content as an `ArrayBuffer`.\n   */\n  async arrayBuffer() {\n    return consumers.arrayBuffer(this.body);\n  }\n\n  /**\n   * Converts the body stream of the piece to a string.\n   *\n   * @returns The piece content as a string.\n   */\n  async text() {\n    return consumers.text(this.body);\n  }\n\n  /**\n   * Converts the body stream of the piece to a JSON object.\n   *\n   * @returns The piece content as a JSON object.\n   */\n  async json() {\n    return consumers.json(this.body);\n  }\n}\n","import { Buffer } from 'buffer';\n\nimport * as dag from './DagApi';\nimport { Cid } from './Cid';\n\n/**\n * The `Link` class represents a link in a DAG.\n *\n * @group Directed Acyclic Graph (DAG)\n *\n * @example\n *\n * ```typescript\n * const cid = '...';\n * const size = 10;\n * const name = 'example';\n * const link = new Link(cid, size, name);\n *\n * console.log(link);\n * ```\n */\nexport class Link {\n  /**\n   * The content identifier of the link.\n   */\n  public cid: string;\n\n  /**\n   * The content size on which the link points to.\n   */\n  public size: number;\n\n  /**\n   * The name of the link.\n   */\n  public name = '';\n\n  constructor(cid: string, size: number, name = '') {\n    this.cid = cid;\n    this.size = size;\n    this.name = name;\n  }\n}\n\n/**\n * The `Tag` class represents a DAG Node tag.\n *\n * @group Directed Acyclic Graph (DAG)\n * @example\n *\n * ```typescript\n * const key = 'exampleKey';\n * const value = 'exampleValue';\n * const tag = new Tag(key, value);\n *\n * console.log(tag);\n * ```\n */\nexport class Tag {\n  /**\n   * The key of the tag.\n   */\n  public key: string;\n\n  /**\n   * The value of the tag.\n   */\n  public value: string;\n\n  constructor(key: string, value: string) {\n    this.key = key;\n    this.value = value;\n  }\n}\n\n/**\n * The `DagNode` class represents a node in a Directed Acyclic Graph (DAG).\n *\n * @group Directed Acyclic Graph (DAG)\n *\n * @example\n *\n * ```typescript\n * const data = 'Node data';\n * const links = [new Link('...', 10, 'link1')];\n * const tags = [new Tag('exampleKey', 'exampleValue')];\n * const node = new DagNode(data, links, tags);\n *\n * console.log(DagNode.isDagNode(node)); // true\n * ```\n */\nexport class DagNode {\n  private dataBuffer: Buffer;\n\n  /**\n   * The links of the node.\n   */\n  public links: Link[];\n\n  /**\n   * The tags of the node.\n   */\n  public tags: Tag[];\n\n  constructor(data?: Uint8Array | Buffer | string | null, links: Link[] = [], tags: Tag[] = []) {\n    this.dataBuffer = Buffer.from(data || []);\n    this.links = links;\n    this.tags = tags;\n  }\n\n  /**\n   * The size of the node in bytes.\n   */\n  get size() {\n    return dag.Node.toBinary(mapDagNodeToAPI(this)).byteLength;\n  }\n\n  /**\n   * The data of the node as a `Buffer`.\n   */\n  get data(): Buffer {\n    return this.dataBuffer;\n  }\n\n  set data(data: Uint8Array | string | Buffer) {\n    this.dataBuffer = Buffer.from(data);\n  }\n\n  /**\n   * Checks if an object is an instance of `DagNode`.\n   *\n   * @param object - The object to check.\n   *\n   * @returns `true` if the object is an instance of `DagNode` or has the same properties as a `DagNode`, `false` otherwise.\n   */\n  static isDagNode(object: unknown): object is DagNode {\n    const maybeNode = object as DagNode | null;\n\n    if (object instanceof DagNode) {\n      return true;\n    }\n\n    return (\n      typeof maybeNode === 'object' &&\n      maybeNode?.data instanceof Uint8Array &&\n      Array.isArray(maybeNode.links) &&\n      Array.isArray(maybeNode.tags)\n    );\n  }\n}\n\n/**\n * The `DagNodeResponse` class represents a response for a DAG Node.\n *\n * @group Directed Acyclic Graph (DAG)\n * @extends DagNode\n */\nexport class DagNodeResponse extends DagNode {\n  protected cidObject: Cid;\n\n  constructor(cid: string | Uint8Array | Cid, data: Uint8Array, dagLinks: dag.Link[] = [], tags: dag.Tag[] = []) {\n    const links = dagLinks.map((link) => ({ ...link, cid: new Cid(link.cid).toString() }));\n\n    super(new Uint8Array(data), links, tags);\n\n    this.cidObject = new Cid(cid);\n  }\n\n  /**\n   * The content identifier of the response as a string.\n   */\n  get cid() {\n    return this.cidObject.toString();\n  }\n}\n\nexport const mapDagNodeToAPI = (node: DagNode): dag.Node => ({\n  ...node,\n  data: node.data,\n  links: node.links.map((link) => ({\n    ...link,\n    cid: new Cid(link.cid).toBytes(),\n  })),\n});\n","import * as cns from './CnsApi';\nimport { Cid } from './Cid';\nimport { Signature } from './signature';\n\n/**\n * The `CnsRecord` class represents a CNS record.\n *\n * @group Content Name System (CNS)\n *\n * @example\n *\n * ```typescript\n * const cid = '...';\n * const name = 'example';\n * const record = new CnsRecord(cid, name);\n *\n * console.log(CnsRecord.isCnsRecord(record)); // true\n * ```\n */\nexport class CnsRecord implements Omit<cns.Record, 'cid' | 'signature'> {\n  /**\n   * The content identifier (CID) of the CNS record.\n   */\n  readonly cid: string;\n\n  /**\n   * The name of the CNS record.\n   */\n  readonly name: string;\n\n  constructor(cid: string, name: string) {\n    this.cid = cid;\n    this.name = name;\n  }\n\n  /**\n   * Checks if an object is an instance of `CnsRecord`.\n   *\n   * @param object - The object to check.\n   *\n   * @returns `true` if the object is an instance of `CnsRecord` or has the same properties as a `CnsRecord`, `false` otherwise.\n   */\n  static isCnsRecord(object: unknown): object is CnsRecord {\n    const maybeRecord = object as CnsRecord | null;\n\n    if (object instanceof CnsRecord) {\n      return true;\n    }\n\n    return (\n      typeof maybeRecord === 'object' && typeof maybeRecord?.cid === 'string' && typeof maybeRecord.name === 'string'\n    );\n  }\n}\n\n/**\n * The `CnsRecordResponse` class represents a response for a CNS record.\n *\n * @group Content Name System (CNS)\n */\nexport class CnsRecordResponse extends CnsRecord {\n  /**\n   * The signature of the response as a `Signature` object.\n   */\n  readonly signature: Signature;\n\n  constructor(cid: string | Uint8Array, name: string, signature: Signature) {\n    super(new Cid(cid).toString(), name);\n\n    this.signature = signature;\n  }\n}\n\nexport const mapCnsRecordToAPI = ({ name, cid }: CnsRecord): Omit<cns.Record, 'signature'> => ({\n  name,\n  cid: new Cid(cid).toBytes(),\n});\n","import { v4 as uuid } from 'uuid';\nimport type { Signer, BucketId, StorageNodeMode } from '@cere-ddc-sdk/blockchain';\n\nimport { Cid } from '../Cid';\nimport { CnsApi } from '../CnsApi';\nimport { DagApi } from '../DagApi';\nimport { FileApi } from '../FileApi';\nimport { GRPC_REQUEST_INACTIVITY_TIMEOUT } from '../constants';\nimport { MultipartPiece, Piece, PieceResponse } from '../Piece';\nimport { DagNode, DagNodeResponse, mapDagNodeToAPI } from '../DagNode';\nimport { CnsRecord, CnsRecordResponse, mapCnsRecordToAPI } from '../CnsRecord';\nimport { DefaultTransport, RpcTransportOptions } from '../transports';\nimport { bindErrorLogger, createLogger, Logger, LoggerOptions } from '../logger';\nimport { AuthToken, createSdkToken, getSdkSigner } from '../auth';\n\nimport {\n  DagNodeGetOptions,\n  DagNodeStoreOptions,\n  PieceReadOptions,\n  PieceStoreOptions,\n  NodeInterface,\n  OperationAuthOptions,\n  CnsRecordStoreOptions,\n  CnsRecordGetOptions,\n} from './NodeInterface';\nimport { createCorrelationId } from '../activity';\n\nexport type StorageNodeConfig = RpcTransportOptions &\n  LoggerOptions & {\n    mode: StorageNodeMode;\n    nodeId?: string;\n    enableAcks?: boolean;\n    authenticate?: boolean;\n    authToken?: AuthToken | string;\n  };\n\n/**\n * The `StorageNode` class provides methods for communicating with a DDC storage node.\n *\n * @group Storage Node\n * @example\n *\n * ```typescript\n * const signer = new UriSigner('hybrid label reunion ...');\n *\n * const storageNode = new StorageNode(signer, {\n *   mode: StorageNodeMode.Storage,\n * });\n * ```\n */\nexport class StorageNode implements NodeInterface {\n  readonly nodeId: string;\n  readonly displayName: string;\n\n  private dagApi: DagApi;\n  private fileApi: FileApi;\n  private cnsApi: CnsApi;\n  private logger: Logger;\n  private rootTokenPromise?: Promise<AuthToken>;\n\n  readonly mode: StorageNodeMode;\n\n  constructor(\n    private signer: Signer,\n    readonly config: StorageNodeConfig,\n  ) {\n    const authToken = AuthToken.maybeToken(config.authToken);\n    const transport = new DefaultTransport({\n      ...config,\n      timeout: config.timeout ?? GRPC_REQUEST_INACTIVITY_TIMEOUT,\n    });\n\n    this.nodeId = config.nodeId || uuid();\n    this.mode = config.mode;\n    this.logger = createLogger('StorageNode', config);\n    this.rootTokenPromise = authToken && Promise.resolve(authToken);\n\n    /**\n     * Use the HTTP URL as the display name.\n     */\n    this.displayName = config.httpUrl;\n\n    const options = {\n      signer,\n      logger: this.logger,\n      authenticate: config.authenticate,\n      enableAcks: config.enableAcks,\n    };\n\n    this.cnsApi = new CnsApi(transport, options);\n    this.dagApi = new DagApi(transport, options);\n    this.fileApi = new FileApi(transport, options);\n\n    this.logger.debug(config, 'Storage node initialized');\n\n    if (config.logErrors !== false) {\n      bindErrorLogger(this, this.logger, [\n        'storePiece',\n        'storeDagNode',\n        'readPiece',\n        'getDagNode',\n        'storeCnsRecord',\n        'getCnsRecord',\n        'resolveName',\n      ]);\n    }\n  }\n\n  private async getRootToken() {\n    this.rootTokenPromise ||= createSdkToken(this.signer);\n\n    return this.rootTokenPromise;\n  }\n\n  private async createAuthToken({ accessToken }: OperationAuthOptions = {}) {\n    const inputToken = AuthToken.maybeToken(accessToken);\n\n    if (inputToken?.isSigned) {\n      return inputToken;\n    }\n\n    const unsignedToken = inputToken || (await this.getRootToken());\n    const sdkSigner = unsignedToken.subject && getSdkSigner(this.signer, unsignedToken.subject);\n\n    return AuthToken.from(unsignedToken).sign(sdkSigner || this.signer);\n  }\n\n  /**\n   * Stores a piece (raw or multipart) of data in a specific bucket.\n   *\n   * @param bucketId - The ID of the bucket to store the piece in.\n   * @param piece - The instance of Piece or MultipartPiece.\n   * @param options - Optional parameters for storing the piece.\n   *\n   * @returns A promise that resolves to the CID of the stored piece.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: BucketId = 1n;\n   * const piece: Piece = new Piece(new Uint8Array([1, 2, 3]));\n   * const pieceCid = await storageNode.storePiece(bucketId, piece);\n   *\n   * console.log(pieceCid);\n   * ```\n   *\n   * ```typescript\n   * const bucketId: BucketId = 1n;\n   * const piece: MultipartPiece = new MultipartPiece(['CID1', 'CID2'], {\n   *  partSize: 1024,\n   *  totalSize: 2048,\n   * });\n   *\n   * const pieceCid = await storageNode.storePiece(bucketId, piece);\n   *\n   * console.log(pieceCid);\n   * ```\n   */\n  async storePiece(bucketId: BucketId, piece: Piece | MultipartPiece, options?: PieceStoreOptions) {\n    let cidBytes: Uint8Array | undefined = undefined;\n    const token = await this.createAuthToken(options);\n    const correlationId = options?.correlationId || createCorrelationId();\n\n    if (MultipartPiece.isMultipartPiece(piece)) {\n      this.logger.info('Storing multipart piece into bucket %s', bucketId);\n\n      cidBytes = await this.fileApi.putMultipartPiece({\n        bucketId,\n        token,\n        correlationId,\n        partHashes: piece.partHashes,\n        partSize: piece.meta.partSize,\n        totalSize: piece.meta.totalSize,\n      });\n    }\n\n    if (Piece.isPiece(piece)) {\n      this.logger.info('Storing raw piece into bucket %s', bucketId);\n\n      cidBytes = await this.fileApi.putRawPiece(\n        {\n          bucketId,\n          token,\n          correlationId,\n          isMultipart: piece.isPart,\n          offset: piece.offset,\n          size: piece.size,\n        },\n        piece.body,\n      );\n    }\n\n    if (!cidBytes) {\n      throw new Error('`piece` argument is neither Piece nor MultipartPiece');\n    }\n\n    const cid = new Cid(cidBytes).toString();\n\n    if (options?.name) {\n      await this.storeCnsRecord(bucketId, new CnsRecord(cid, options.name), options);\n    }\n\n    this.logger.info('Stored piece into bucket %s with CID %s', bucketId, cid);\n\n    return cid;\n  }\n\n  /**\n   * Stores a DAG node in a specific bucket.\n   *\n   * @param bucketId - The ID of the bucket to store the DAG node in.\n   * @param node - The DAGNode instance to store.\n   * @param options - Optional parameters for storing the DAG node.\n   *\n   * @returns A promise that resolves to the CID of the stored DAG node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: BucketId = 1n;\n   * const firstLink = new Link('CID', 10, 'first-link');\n   * const node: DagNode = new DagNode('node content', [firstLink]);\n   * const nodeCid = await storageNode.storeDagNode(bucketId, node, {\n   *  name: 'node-name', // CNS name for the DAG node\n   * });\n   *\n   * console.log(nodeCid);\n   * ```\n   */\n  async storeDagNode(bucketId: BucketId, node: DagNode, options?: DagNodeStoreOptions) {\n    const token = await this.createAuthToken(options);\n    const correlationId = options?.correlationId || createCorrelationId();\n\n    this.logger.info('Storing DAG node into bucket %s', bucketId);\n\n    const cidBytes = await this.dagApi.putNode({\n      bucketId,\n      token,\n      correlationId,\n      node: mapDagNodeToAPI(node),\n    });\n\n    const cid = new Cid(cidBytes).toString();\n\n    if (options?.name) {\n      await this.storeCnsRecord(bucketId, new CnsRecord(cid, options.name), options);\n    }\n\n    this.logger.info('Stored DAG Node into bucket %s with CID %s', bucketId, cid);\n\n    return cid;\n  }\n\n  /**\n   * Reads a piece of data from a specific bucket.\n   *\n   * @param bucketId - The ID of the bucket to read the piece from.\n   * @param cidOrName - The CID or CNS name of the piece to read.\n   * @param options - Optional parameters for reading the piece.\n   *\n   * @returns A promise that resolves to a PieceResponse instance.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: BucketId = 1n;\n   * const cidOrName = '...'; // CID or CNS name of the piece\n   * const piece = await storageNode.readPiece(bucketId, cidOrName);\n   *\n   * console.log(piece);\n   * ```\n   */\n  async readPiece(bucketId: BucketId, cidOrName: string, options?: PieceReadOptions) {\n    const token = await this.createAuthToken(options);\n    const correlationId = options?.correlationId || createCorrelationId();\n\n    this.logger.info('Reading piece by CID or name \"%s\" from bucket %s', cidOrName, bucketId);\n\n    const cid = await this.resolveName(bucketId, cidOrName, options);\n    const contentStream = await this.fileApi.getFile({\n      bucketId,\n      token,\n      correlationId,\n      cid: cid.toBytes(),\n      range: options?.range,\n    });\n\n    const response = new PieceResponse(cid, contentStream, {\n      range: options?.range,\n    });\n\n    this.logger.info('Read piece by CID or name \"%s\" from bucket %s', cidOrName, bucketId);\n\n    return response;\n  }\n\n  /**\n   * Retrieves a DAG node from a specific bucket.\n   *\n   * @param bucketId - The ID of the bucket to retrieve the DAG node from.\n   * @param cidOrName - The CID or CNS name of the DAG node to retrieve.\n   * @param options - Optional parameters for retrieving the DAG node.\n   *\n   * @returns A promise that resolves to a DagNodeResponse instance.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: bigint = 1n;\n   * const cidOrName = '...'; // CID or CNS name of the DAG node\n   * const dagNode = await storageNode.getDagNode(bucketId, cidOrName);\n   *\n   * console.log(dagNode);\n   * ```\n   */\n  async getDagNode(bucketId: BucketId, cidOrName: string, options?: DagNodeGetOptions) {\n    const token = await this.createAuthToken(options);\n    const correlationId = options?.correlationId || createCorrelationId();\n\n    this.logger.info('Getting DAG Node by CID or name \"%s\" from bucket %s', cidOrName, bucketId);\n\n    const cid = await this.resolveName(bucketId, cidOrName, options);\n    const node = await this.dagApi.getNode({\n      bucketId,\n      token,\n      correlationId,\n      cid: cid.toBytes(),\n      path: options?.path,\n    });\n\n    const response = node && new DagNodeResponse(cid, new Uint8Array(node.data), node.links, node.tags);\n\n    this.logger.info('Got DAG Node by CID or name \"%s\" from bucket %s', cidOrName, bucketId);\n\n    return response;\n  }\n\n  /**\n   * Stores a Content Name System (CNS) record in a specific bucket.\n   *\n   * @param bucketId - The ID of the bucket to store the CNS record in.\n   * @param record - The CNS record to store.\n   * @param options - Optional parameters for storing the CNS record.\n   *\n   * @returns A promise that resolves to the CID of the stored CNS record.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId: bigint = 1n;\n   * const record: CnsRecord = new CnsRecord('CID', 'record-name');\n   * const recordCid = await storageNode.storeCnsRecord(bucketId, record);\n   *\n   * console.log(recordCid);\n   * ```\n   */\n  async storeCnsRecord(bucketId: BucketId, record: CnsRecord, options?: CnsRecordStoreOptions) {\n    const token = await this.createAuthToken(options);\n    const correlationId = options?.correlationId || createCorrelationId();\n\n    this.logger.info('Storing CNS record into bucket %s', bucketId);\n\n    const storredRecord = await this.cnsApi.putRecord({\n      bucketId,\n      token,\n      correlationId,\n      record: mapCnsRecordToAPI(record),\n    });\n\n    this.logger.info('Stored CNS record into bucket %s', bucketId);\n\n    return storredRecord;\n  }\n\n  /**\n   * Retrieves a Content Name System (CNS) record from a specific bucket.\n   *\n   * @param bucketId - The ID of the bucket to retrieve the CNS record from.\n   * @param name - The name of the CNS record to retrieve.\n   * @param options - Optional parameters for retrieving the CNS record.\n   *\n   * @returns A promise that resolves to CnsRecordResponse .\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketId = 1n;\n   * const name = 'record-name';\n   * const cnsRecord = await storageNode.getCnsRecord(bucketId, name);\n   *\n   * console.log(cnsRecord);\n   * ```\n   */\n  async getCnsRecord(bucketId: BucketId, name: string, options?: CnsRecordGetOptions) {\n    const token = await this.createAuthToken(options);\n    const { cacheControl, correlationId = createCorrelationId() } = options || {};\n\n    this.logger.info(`Getting CNS record by name \"${name}\" from bucket ${bucketId}`);\n    const record = await this.cnsApi.getRecord({ bucketId, name, token, correlationId, cacheControl });\n    this.logger.info('Got CNS record by name \"%s\" from bucket %s', name, bucketId);\n\n    return record && new CnsRecordResponse(record.cid, record.name, record.signature);\n  }\n\n  /**\n   * Resolves a name to a CID in the Content Name System (CNS).\n   *\n   * @param name - The CNS name to resolve.\n   * @param options - Optional parameters for resolving the name.\n   *\n   * @returns A promise that resolves to the CID corresponding to the CNS name.\n   *\n   * @example\n   *\n   * ```typescript\n   * const name: string = 'record-name';\n   * const cid = await storageNode.resolveName(name, options);\n   *\n   * console.log(cid);\n   * ```\n   */\n  async resolveName(bucketId: BucketId, cidOrName: string, options?: CnsRecordGetOptions) {\n    if (Cid.isCid(cidOrName)) {\n      return new Cid(cidOrName);\n    }\n\n    this.logger.info('Resolving CNS name \"%s\" from bucket %s', cidOrName, bucketId);\n    const record = await this.getCnsRecord(bucketId, cidOrName, options);\n\n    if (!record) {\n      throw new Error(`Cannot resolve CNS name: \"${cidOrName}\"`);\n    }\n\n    this.logger.info('Resolved CNS name \"%s\" from bucket %s to \"%s\"', cidOrName, bucketId, record.cid);\n\n    return new Cid(record.cid);\n  }\n}\n","import type { BucketId } from '@cere-ddc-sdk/blockchain';\n\nimport type { StorageNodeConfig } from '../nodes';\nimport type { Logger } from '../logger';\n\nexport enum RouterOperation {\n  READ_DAG_NODE = 'read-dag-node',\n  STORE_DAG_NODE = 'store-dag-node',\n  READ_PIECE = 'read-piece',\n  STORE_PIECE = 'store-piece',\n  STORE_CNS_RECORD = 'store-cns-record',\n  READ_CNS_RECORD = 'read-cns-record',\n}\n\nexport type RouterNode = StorageNodeConfig & {\n  priority?: number;\n};\n\nexport abstract class RoutingStrategy {\n  constructor(protected logger: Logger) {}\n\n  abstract selectNode(operation: RouterOperation, nodes: RouterNode[]): RouterNode | undefined;\n  abstract getNodes(bucketId: BucketId): Promise<RouterNode[]>;\n  abstract isReady(): Promise<boolean>;\n  abstract marshalNodes(operation: RouterOperation, nodes: RouterNode[]): Promise<RouterNode[]>;\n}\n","import { RouterNode, RouterOperation, RoutingStrategy } from './RoutingStrategy';\n\nconst isSSLRequired = () => globalThis.location?.protocol === 'https:';\n\nexport abstract class BaseStrategy extends RoutingStrategy {\n  async marshalNodes(operation: RouterOperation, allNodes: RouterNode[]) {\n    if (!isSSLRequired()) {\n      return allNodes;\n    }\n\n    return allNodes.filter((node) => node.ssl);\n  }\n}\n","import { StorageNodeMode as Mode } from '@cere-ddc-sdk/blockchain';\n\nimport { RouterOperation as Operation, RouterNode } from './RoutingStrategy';\nimport { BaseStrategy } from './BaseStrategy.web';\n\ntype ModePriorityMap = Partial<Record<Mode, number>>;\ntype OperationPriorityMap = Record<Operation, ModePriorityMap>;\n\n/**\n * The `priorityMap` defines the priority of the operation for each mode.\n * The lower the number, the higher the priority.\n */\nconst priorityMap: OperationPriorityMap = {\n  [Operation.READ_DAG_NODE]: {\n    [Mode.Full]: 1,\n    [Mode.Cache]: 1,\n    [Mode.Storage]: 2,\n  },\n\n  [Operation.STORE_DAG_NODE]: {\n    [Mode.Full]: 1,\n    [Mode.Storage]: 2,\n    [Mode.Cache]: undefined, // Not applicable for the operation\n  },\n\n  [Operation.READ_PIECE]: {\n    [Mode.Full]: 1,\n    [Mode.Cache]: 1,\n    [Mode.Storage]: 2,\n  },\n\n  [Operation.STORE_PIECE]: {\n    [Mode.Full]: 1,\n    [Mode.Storage]: 2,\n    [Mode.Cache]: undefined, // Not applicable for the operation\n  },\n\n  [Operation.READ_CNS_RECORD]: {\n    [Mode.Full]: 1,\n    [Mode.Cache]: 1,\n    [Mode.Storage]: 2,\n  },\n\n  [Operation.STORE_CNS_RECORD]: {\n    [Mode.Full]: 1,\n    [Mode.Storage]: 2,\n    [Mode.Cache]: undefined, // Not applicable for the operation\n  },\n};\n\n/**\n * The `NodeTypeStrategy` selects a node based on the operation type and node mode.\n */\nexport abstract class NodeTypeStrategy extends BaseStrategy {\n  async marshalNodes(operation: Operation, allNodes: RouterNode[]): Promise<RouterNode[]> {\n    const nodes = await super.marshalNodes(operation, allNodes);\n\n    const opertaionPriorityMap = priorityMap[operation];\n    const operationNodes = nodes.filter(({ mode }) => opertaionPriorityMap[mode] !== undefined);\n\n    return operationNodes.sort((a, b) => {\n      const aPriority = a.priority ?? opertaionPriorityMap[a.mode] ?? 0;\n      const bPriority = b.priority ?? opertaionPriorityMap[b.mode] ?? 0;\n\n      return aPriority - bPriority;\n    });\n  }\n\n  selectNode(operation: Operation, nodes: RouterNode[]): RouterNode | undefined {\n    return nodes[0]; // select first node from the rundomly shuffled list\n  }\n}\n","import fetch from 'cross-fetch';\nimport { Deferred, DeferredState } from '@protobuf-ts/runtime-rpc';\n\nimport { RouterOperation, RouterNode } from '.';\nimport { NodeTypeStrategy } from './NodeTypeStrategy';\nimport { shuffle } from './RandomStrategy';\nimport {\n  PING_ABORT_TIMEOUT,\n  PING_BACKGROUND_DELAY,\n  PING_LATENCY_GROUP,\n  PING_THRESHOLD,\n  PING_THRESHOLD_INC,\n} from '../constants';\n\ntype PingRecord = {\n  node: RouterNode;\n  isDone: Deferred<boolean>;\n  latency?: number;\n};\n\n/**\n * The `PingStrategy` selects a node based on the operation type and ping latency.\n */\nexport abstract class PingStrategy extends NodeTypeStrategy {\n  private nodesMap = new Map<RouterNode['httpUrl'], PingRecord>();\n\n  private getPingedNodes(state?: DeferredState) {\n    const pings = Array.from(this.nodesMap.values());\n    const foundPings = pings.filter(({ isDone }) =>\n      state ? isDone.state === state : isDone.state !== DeferredState.REJECTED,\n    );\n\n    return foundPings.map(({ node }) => node);\n  }\n\n  private async ping(record: PingRecord): Promise<PingRecord> {\n    const start = Date.now();\n    const pingUrl = new URL('/info', record.node.httpUrl);\n\n    try {\n      const response = await fetch(pingUrl, {\n        cache: 'no-cache',\n        signal: AbortSignal.timeout(PING_ABORT_TIMEOUT),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status} ${response.statusText}`);\n      }\n    } catch (err: any) {\n      this.logger.debug({ err }, 'Node ping %s failed with error %s', record.node.httpUrl, err);\n\n      throw err;\n    }\n\n    record.latency = Date.now() - start;\n    this.logger.info('Node ping completed %s with latency %d ms', record.node.httpUrl, record.latency);\n\n    return record;\n  }\n\n  private enqueuePing(node: RouterNode) {\n    const existingPing = this.nodesMap.get(node.httpUrl);\n\n    if (existingPing) {\n      return existingPing;\n    }\n\n    const isDone = new Deferred<boolean>();\n    const pingRecord: PingRecord = { node, isDone };\n\n    this.nodesMap.set(node.httpUrl, pingRecord);\n    this.ping(pingRecord)\n      .then(() => isDone.resolve(true))\n      .catch((err) => isDone.reject(err));\n\n    return isDone.promise;\n  }\n\n  async marshalNodes(operation: RouterOperation, allNodes: RouterNode[]): Promise<RouterNode[]> {\n    const allNodesShuffled = shuffle([...allNodes]);\n    const pingedNodes = await super.marshalNodes(operation, this.getPingedNodes());\n    const allOperationNodes = await super.marshalNodes(operation, allNodesShuffled);\n    const notPingedNodes = allOperationNodes.filter((node) => !this.nodesMap.has(node.httpUrl));\n    const toPingSync = notPingedNodes.slice(0, Math.max(0, PING_THRESHOLD - pingedNodes.length));\n    const toPingAsync = notPingedNodes.slice(0, PING_THRESHOLD_INC);\n    const syncPings = [\n      ...pingedNodes, // Include already pinged nodes to make sure they are settled\n      ...toPingSync,\n    ].map((node) => this.enqueuePing(node));\n\n    /**\n     * Wait for all sync pings to complete\n     */\n    await Promise.allSettled(syncPings);\n\n    /**\n     * After a short delay, start async pings in background\n     */\n    setTimeout(() => toPingAsync.forEach((node) => this.enqueuePing(node)), PING_BACKGROUND_DELAY);\n\n    /**\n     * Sort opperation nodes by latency\n     */\n    return allOperationNodes.sort((a, b) => {\n      const latencyA = this.nodesMap.get(a.httpUrl)?.latency;\n      const latencyB = this.nodesMap.get(b.httpUrl)?.latency;\n\n      /**\n       * Group latency by PING_LATENCY_GROUP ms levels to avaoid sorting by small differences.\n       * Keep nodes without ping at the end for fallback scenarios when all pings fail.\n       */\n      const levelA = latencyA ? Math.ceil(latencyA / PING_LATENCY_GROUP) : Infinity;\n      const levelB = latencyB ? Math.ceil(latencyB / PING_LATENCY_GROUP) : Infinity;\n\n      return levelA - levelB;\n    });\n  }\n}\n","import { StorageNodeConfig } from '..';\nimport { BaseStrategy } from './BaseStrategy';\nimport { RouterOperation, RouterNode } from './RoutingStrategy';\n\nexport const shuffle = (array: RouterNode[]) => {\n  for (let index = array.length - 1; index > 0; index--) {\n    const random = Math.floor(Math.random() * (index + 1));\n\n    [array[index], array[random]] = [array[random], array[index]];\n  }\n\n  return array;\n};\n\nexport abstract class RandomStrategy extends BaseStrategy {\n  async marshalNodes(operation: RouterOperation, nodes: StorageNodeConfig[]): Promise<StorageNodeConfig[]> {\n    return shuffle(nodes);\n  }\n\n  selectNode(operation: RouterOperation, nodes: RouterNode[]): RouterNode {\n    return nodes[0];\n  }\n}\n","import { Blockchain, Bucket, BucketId, ClusterId, StorageNode as BCStorageNode } from '@cere-ddc-sdk/blockchain';\n\nimport { RouterNode } from './RoutingStrategy';\nimport { Logger } from '../logger';\nimport { PingStrategy } from './PingStrategy';\n\nexport type BlockchainStrategyConfig = {\n  blockchain: Blockchain;\n};\n\n/**\n * The `BlockchainStrategy` retrieves nodes from the blockchain. And appiles the `PingStrategy` + `NodeTypeStrategy` to select the best node.\n */\nexport class BlockchainStrategy extends PingStrategy {\n  private blockchain: Blockchain;\n  private bucketCache: Map<BucketId, Bucket> = new Map();\n  private clusterNodes: Map<ClusterId, RouterNode[]> = new Map();\n\n  constructor(logger: Logger, { blockchain }: BlockchainStrategyConfig) {\n    super(logger);\n\n    this.blockchain = blockchain;\n  }\n\n  async isReady() {\n    await this.blockchain.isReady();\n\n    return true;\n  }\n\n  async getNodes(bucketId: BucketId) {\n    const { clusterId } = await this.getBucket(bucketId);\n    const nodes = await this.getClusterNodes(clusterId);\n\n    this.logger.debug({ nodes }, 'Using nodes from blockchain');\n\n    if (!nodes.length) {\n      throw new Error(`No nodes found in the cluster: ${clusterId}`);\n    }\n\n    return nodes;\n  }\n\n  private mapNodeProps = (node: BCStorageNode): RouterNode => {\n    const { grpcPort, host, httpPort, ssl, domain } = node.props;\n    const httpHost = domain || host;\n    const httpUrl = ssl ? `https://${httpHost}` : `http://${httpHost}:${httpPort}`;\n\n    return {\n      ssl,\n      httpUrl,\n      grpcUrl: `grpc://${host}:${grpcPort}`,\n      mode: node.props.mode,\n    };\n  };\n\n  private async getClusterNodes(clusterId: ClusterId) {\n    if (this.clusterNodes.has(clusterId)) {\n      return this.clusterNodes.get(clusterId)!;\n    }\n\n    /**\n     * TODO: Revise the solution and if the blockchain pallet adds a method to fetch nodes with props by clusterId then use it here.\n     */\n    const allNodes = await this.blockchain.ddcNodes.listStorageNodes();\n    const clusterNodes = allNodes.filter((node) => node.clusterId === clusterId).map(this.mapNodeProps);\n    this.clusterNodes.set(clusterId, clusterNodes);\n\n    return clusterNodes;\n  }\n\n  private async getBucket(bucketId: BucketId) {\n    if (this.bucketCache.has(bucketId)) {\n      return this.bucketCache.get(bucketId)!;\n    }\n\n    const bucket = await this.blockchain.ddcCustomers.getBucket(bucketId);\n\n    if (!bucket) {\n      throw new Error(`Failed to get bucket ${bucketId} on blockchain`);\n    }\n\n    this.logger.debug({ bucket }, 'Got bucket from blockchain');\n    this.bucketCache.set(bucketId, bucket);\n\n    return bucket;\n  }\n}\n","import { BucketId } from '@cere-ddc-sdk/blockchain';\n\nimport { RouterNode } from './RoutingStrategy';\nimport { Logger } from '../logger';\nimport { PingStrategy } from './PingStrategy';\n\nexport type StaticStrategyConfig = {\n  nodes: RouterNode[];\n};\n\nexport class StaticStrategy extends PingStrategy {\n  private nodes: RouterNode[];\n\n  constructor(logger: Logger, { nodes }: StaticStrategyConfig) {\n    super(logger);\n\n    this.nodes = nodes;\n  }\n\n  async getNodes(bucketId: BucketId) {\n    return this.nodes;\n  }\n\n  async isReady() {\n    return true;\n  }\n}\n","import { BucketId, Signer } from '@cere-ddc-sdk/blockchain';\n\nimport { StorageNode, StorageNodeConfig } from '../nodes';\nimport { RouterNode, RouterOperation, RoutingStrategy } from './RoutingStrategy';\nimport { BlockchainStrategy, BlockchainStrategyConfig } from './BlockchainStrategy';\nimport { StaticStrategy, StaticStrategyConfig } from './StaticStrategy';\nimport { Logger, LoggerOptions, createLogger } from '../logger';\nimport { AuthToken, createSdkToken, isValidSdkToken } from '../auth';\n\nexport type RouterConfig = (StaticStrategyConfig | BlockchainStrategyConfig) &\n  LoggerOptions & {\n    signer: Signer;\n  };\n\nconst getNodeId = (node: RouterNode) => node.nodeId || node.grpcUrl;\n\n/**\n * The `Router` class provides methods for routing operations to different nodes based on a routing strategy.\n *\n * @internal\n * @example\n *\n * ```typescript\n * const router = new Router({\n *   signer: new UriSigner('...'),\n *   nodes: [...],\n * });\n * ```\n */\nexport class Router {\n  private strategy: RoutingStrategy;\n  private signer: Signer;\n  private logger: Logger;\n  private sdkTokenPromise?: Promise<AuthToken>;\n\n  constructor({ signer, ...config }: RouterConfig) {\n    this.logger = createLogger('Router', config);\n    this.signer = signer;\n\n    if ('nodes' in config) {\n      this.strategy = new StaticStrategy(this.logger, config);\n      this.logger.debug({ strategy: 'static' }, 'Router created');\n    } else {\n      this.strategy = new BlockchainStrategy(this.logger, config);\n      this.logger.debug({ strategy: 'blockchain' }, 'Router created');\n    }\n  }\n\n  /**\n   * Returns an SDK token for the current signer\n   */\n  private getSdkToken() {\n    this.sdkTokenPromise = Promise.all([this.sdkTokenPromise, this.signer.isReady()]).then(([token]) =>\n      token && isValidSdkToken(this.signer, token) ? token : createSdkToken(this.signer),\n    );\n\n    return this.sdkTokenPromise;\n  }\n\n  /**\n   * Retrieves a node for a specific operation in a specific bucket, excluding certain nodes.\n   *\n   * @param operation - The operation for which to retrieve a node.\n   * @param bucketId - The ID of the bucket in which to retrieve a node.\n   * @param exclude - An optional array of node IDs to exclude from the retrieval.\n   *\n   * @returns A promise that resolves to the `StorageNode` selected for the operation.\n   *\n   * @throws Will throw an error if no nodes are available to handle the operation.\n   */\n  async getNode(\n    operation: RouterOperation,\n    bucketId: BucketId,\n    config: Partial<StorageNodeConfig> = {},\n    exclude: string[] = [],\n  ) {\n    this.logger.info('Getting node for operation \"%s\" in bucket %s', operation, bucketId);\n\n    const sdkTokenPromise = this.getSdkToken();\n    await this.strategy.isReady();\n\n    const allNodes = await this.strategy.getNodes(bucketId);\n    const nodes = allNodes.filter((node) => !exclude.includes(getNodeId(node)));\n    const finalNodes = await this.strategy.marshalNodes(operation, nodes);\n    const node = this.strategy.selectNode(operation, finalNodes);\n\n    if (!node) {\n      throw new Error('No nodes available to handle the operation');\n    }\n\n    const storageNode = new StorageNode(this.signer, {\n      ...node,\n      logger: this.logger,\n      authToken: await sdkTokenPromise,\n      nodeId: node.nodeId || node.grpcUrl,\n      ...config,\n    });\n\n    this.logger.info(`Selected node for operation \"%s\" in bucket %s: %s`, operation, bucketId, storageNode.displayName);\n    this.logger.debug({ bucketId, node }, 'Selected node');\n\n    return storageNode;\n  }\n}\n","import { RpcError } from '@protobuf-ts/runtime-rpc';\n\nexport class NodeError extends RpcError {\n  correlationId?: string;\n  nodeId?: string;\n\n  static fromRpcError(error: RpcError): NodeError {\n    const finalError = new NodeError(error.message, error.code, error.meta);\n\n    finalError.methodName = error.methodName;\n    finalError.serviceName = error.serviceName;\n\n    return finalError;\n  }\n}\n","import retry, { Options as RetryOptions } from 'async-retry';\nimport { RpcError } from '@protobuf-ts/runtime-rpc';\nimport { BucketId } from '@cere-ddc-sdk/blockchain';\n\nimport { GrpcStatus } from '../grpc/status';\nimport { RETRYABLE_GRPC_ERROR_CODES, RETRY_MAX_ATTEPTS } from '../constants';\nimport { Router, RouterOperation } from '../routing';\nimport { Piece, MultipartPiece } from '../Piece';\nimport { DagNode } from '../DagNode';\nimport { CnsRecord } from '../CnsRecord';\nimport { Logger, LoggerOptions, bindErrorLogger, createLogger } from '../logger';\nimport { createCorrelationId } from '../activity';\nimport { NodeError } from './NodeError';\nimport {\n  DagNodeGetOptions,\n  DagNodeStoreOptions,\n  PieceReadOptions,\n  PieceStoreOptions,\n  NodeInterface,\n  CnsRecordGetOptions,\n  CorrelationOptions,\n} from './NodeInterface';\n\n/**\n * The timeouts bettween retries are exponential, starting at `minTimeout` and increasing each time until `maxTimeout`.\n *\n * The formuka for the timeout between retries is:\n *\n * ```typescript\n * const timeout = Math.min(random * minTimeout * Math.pow(factor, attempt), maxTimeout);\n * ```\n */\nexport type OpperationRetryOptions = Omit<RetryOptions, 'retries'> & {\n  attempts?: number;\n};\n\nexport type BalancedNodeConfig = LoggerOptions & {\n  router: Router;\n  retries?: number | OpperationRetryOptions;\n};\n\nconst withCorrelationId = <T extends CorrelationOptions>(options: T): T => ({\n  ...options,\n  correlationId: options.correlationId || createCorrelationId(),\n});\n\n/**\n * The `BalancedNode` class implements the `NodeInterface` and provides methods for interacting with storage nodes.\n *\n * A balanced node is a node that distributes operations across multiple underlying nodes to balance the load.\n *\n * @group Storage Node\n * @example\n *\n * ```typescript\n * const router = new Router(...);\n * const balancedNode = new BalancedNode({ router });\n * ```\n */\nexport class BalancedNode implements NodeInterface {\n  readonly nodeId = 'BalancedNode';\n  readonly displayName = 'BalancedNode';\n\n  private router: Router;\n  private logger: Logger;\n\n  private retryOptions: RetryOptions = {\n    minTimeout: 50, // Starting timeout from which to increase exponentially\n    factor: 2, // Exponential backoff\n    retries: RETRY_MAX_ATTEPTS,\n  };\n\n  constructor({ router, ...config }: BalancedNodeConfig) {\n    this.router = router;\n    this.logger = createLogger('BalancedNode', config);\n\n    if (typeof config.retries === 'number') {\n      this.retryOptions.retries = config.retries;\n    } else if (config.retries) {\n      const { attempts = RETRY_MAX_ATTEPTS, ...retryOptions } = config.retries;\n\n      this.retryOptions = { ...this.retryOptions, ...retryOptions, retries: attempts };\n    }\n\n    if (config.logErrors !== false) {\n      bindErrorLogger(this, this.logger, [\n        'storePiece',\n        'storeDagNode',\n        'readPiece',\n        'getDagNode',\n        'storeCnsRecord',\n        'getCnsRecord',\n        'resolveName',\n      ]);\n    }\n  }\n\n  /**\n   * Executes a function with automatic retry on failure.\n   *\n   * @param fn - The function to execute.\n   * @param options - Optional parameters for retrying the function.\n   *\n   * @returns A promise that resolves to the result of the function.\n   */\n  private async withRetry<T>(\n    bucketId: BucketId,\n    operation: RouterOperation,\n    { correlationId }: CorrelationOptions,\n    body: (node: NodeInterface, bail: (e: Error) => void, attempt: number) => Promise<T>,\n  ) {\n    let lastOperationError: RpcError | undefined;\n    let lastRouterError: Error | undefined;\n\n    const exclude: NodeInterface[] = [];\n\n    return retry(\n      async (bail, attempt) => {\n        let node: NodeInterface | undefined;\n\n        try {\n          node = await this.router.getNode(\n            operation,\n            bucketId,\n            { logErrors: false },\n            exclude.map((node) => node.nodeId),\n          );\n\n          exclude.unshift(node);\n        } catch (error) {\n          /**\n           * In case we fail to get a node, we retry with previous nodes that failed until the max attempts.\n           */\n          node = exclude.pop() || node;\n\n          if (node) {\n            this.logger.info(\n              `Reusing previous node for operation \"%s\" in bucket %s: %s`,\n              operation,\n              bucketId,\n              node.displayName,\n            );\n          }\n\n          if (error instanceof Error) {\n            lastRouterError = error;\n          }\n        }\n\n        if (!node) {\n          throw lastOperationError ?? lastRouterError ?? new Error('No nodes available to handle the operation');\n        }\n\n        try {\n          return await body(node, bail, attempt);\n        } catch (error) {\n          const nodeError = error instanceof RpcError ? NodeError.fromRpcError(error) : undefined;\n\n          if (nodeError) {\n            nodeError.nodeId = node.nodeId;\n            nodeError.correlationId = correlationId;\n\n            if (RETRYABLE_GRPC_ERROR_CODES.map((status) => GrpcStatus[status]).includes(nodeError.code)) {\n              lastOperationError = nodeError;\n\n              throw nodeError;\n            }\n          }\n\n          bail(nodeError || (error as Error));\n        }\n      },\n      {\n        ...this.retryOptions,\n        onRetry: (err, attempt) => {\n          this.retryOptions.onRetry?.(err, attempt);\n\n          this.logger.warn({ err, attempt }, 'Retrying operation');\n        },\n      },\n    ) as T;\n  }\n\n  async storePiece(bucketId: BucketId, piece: Piece | MultipartPiece, storeOptions: PieceStoreOptions = {}) {\n    const options = withCorrelationId(storeOptions);\n\n    return this.withRetry(bucketId, RouterOperation.STORE_PIECE, options, (node, bail, attempt) =>\n      /**\n       * Clone the piece if it is a piece and this is not the first attempt.\n       * This is done to avoid reusing the same stream multiple times.\n       */\n      node.storePiece(bucketId, Piece.isPiece(piece) && attempt > 0 ? Piece.from(piece) : piece, options),\n    );\n  }\n\n  async readPiece(bucketId: BucketId, cidOrName: string, readOptions: PieceReadOptions = {}) {\n    const options = withCorrelationId(readOptions);\n\n    return this.withRetry(bucketId, RouterOperation.READ_PIECE, options, (node) =>\n      node.readPiece(bucketId, cidOrName, options),\n    );\n  }\n\n  async storeDagNode(bucketId: BucketId, dagNode: DagNode, storeOptions: DagNodeStoreOptions = {}) {\n    const options = withCorrelationId(storeOptions);\n\n    return this.withRetry(bucketId, RouterOperation.STORE_DAG_NODE, options, (node) =>\n      node.storeDagNode(bucketId, dagNode, options),\n    );\n  }\n\n  async getDagNode(bucketId: BucketId, cidOrName: string, getOptions: DagNodeGetOptions = {}) {\n    const options = withCorrelationId(getOptions);\n\n    return this.withRetry(bucketId, RouterOperation.READ_DAG_NODE, options, (node) =>\n      node.getDagNode(bucketId, cidOrName, options),\n    );\n  }\n\n  async storeCnsRecord(bucketId: BucketId, record: CnsRecord, storeOptions: DagNodeStoreOptions = {}) {\n    const options = withCorrelationId(storeOptions);\n\n    return this.withRetry(bucketId, RouterOperation.STORE_CNS_RECORD, options, (node) =>\n      node.storeCnsRecord(bucketId, record, options),\n    );\n  }\n\n  async getCnsRecord(bucketId: BucketId, name: string, getOptions: CnsRecordGetOptions = {}) {\n    const options = withCorrelationId(getOptions);\n\n    return this.withRetry(bucketId, RouterOperation.READ_CNS_RECORD, options, (node) =>\n      node.getCnsRecord(bucketId, name, options),\n    );\n  }\n\n  async resolveName(bucketId: BucketId, cidOrName: string, resolveOptions: CnsRecordGetOptions = {}) {\n    const options = withCorrelationId(resolveOptions);\n\n    return this.withRetry(bucketId, RouterOperation.READ_CNS_RECORD, options, (node) =>\n      node.resolveName(bucketId, cidOrName, options),\n    );\n  }\n}\n","import { StorageNodeMode } from '@cere-ddc-sdk/blockchain';\nimport { RouterNode } from './routing';\n\nexport type ConfigPreset = {\n  blockchain: string;\n  nodes?: RouterNode[];\n};\n\n/**\n * DDC mainnet configuration preset\n *\n * @hidden\n */\nexport const MAINNET: ConfigPreset = {\n  blockchain: 'wss://rpc.mainnet.cere.network/ws',\n};\n\n/**\n * DDC testnet configuration preset\n *\n * @hidden\n */\nexport const TESTNET: ConfigPreset = {\n  blockchain: 'wss://rpc.testnet.cere.network/ws',\n};\n\n/**\n * DDC devnet configuration preset\n *\n * @hidden\n */\nexport const DEVNET: ConfigPreset = {\n  blockchain: 'wss://archive.devnet.cere.network/ws',\n};\n\nexport const DEFAULT_PRESET = TESTNET;\n\n/**\n * Static DEVNET preset\n *\n * TODO: Remove after full migration to on-chain topology\n *\n * @deprecated Use `DEVNET` instead\n * @ignore\n */\nexport const DEVNET_STATIC: ConfigPreset = {\n  blockchain: 'wss://archive.devnet.cere.network/ws',\n  nodes: [\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://38.242.236.247:9090',\n      httpUrl: 'https://storage-1.devnet.cere.network',\n      ssl: true,\n    },\n\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://38.242.236.247:9091',\n      httpUrl: 'https://storage-2.devnet.cere.network',\n    },\n\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://158.220.87.61:9090',\n      httpUrl: 'https://storage-3.devnet.cere.network',\n      ssl: true,\n    },\n\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://158.220.87.61:9091',\n      httpUrl: 'https://storage-4.devnet.cere.network',\n    },\n\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://89.117.79.111:9090',\n      httpUrl: 'https://storage-5.devnet.cere.network',\n      ssl: true,\n    },\n\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://89.117.79.111:9091',\n      httpUrl: 'https://storage-6.devnet.cere.network',\n    },\n\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://154.53.57.124:9090',\n      httpUrl: 'https://storage-7.devnet.cere.network',\n      ssl: true,\n    },\n\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://154.53.57.124:9091',\n      httpUrl: 'https://storage-8.devnet.cere.network',\n    },\n  ],\n};\n\n/**\n * Static TESTENT preset\n *\n * TODO: Remove after full migration to on-chain topology\n *\n * @deprecated Use `TESTNET` instead\n * @ignore\n */\nexport const TESTNET_STATIC: ConfigPreset = {\n  blockchain: 'wss://rpc.testnet.cere.network/ws',\n  nodes: [\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://128.140.103.37:9090',\n      httpUrl: 'https://storage-1.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.55.218.0:9090',\n      httpUrl: 'https://storage-2.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://94.130.27.127:9090',\n      httpUrl: 'https://storage-3.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://157.90.226.137:9090',\n      httpUrl: 'https://storage-4.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://116.203.211.74:9090',\n      httpUrl: 'https://storage-5.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://116.203.188.159:9090',\n      httpUrl: 'https://storage-6.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://66.135.3.185:9090',\n      httpUrl: 'https://storage-7.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://207.246.92.234:9090',\n      httpUrl: 'https://storage-8.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://116.203.153.145:9090',\n      httpUrl: 'https://storage-9.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://94.130.183.14:9090',\n      httpUrl: 'https://storage-10.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://78.47.189.200:9090',\n      httpUrl: 'https://storage-11.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://116.203.83.55:9090',\n      httpUrl: 'https://storage-12.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://95.217.155.6:9090',\n      httpUrl: 'https://storage-13.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.108.154.151:9090',\n      httpUrl: 'https://storage-14.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://37.27.18.247:9090',\n      httpUrl: 'https://storage-15.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.109.138.28:9090',\n      httpUrl: 'https://storage-16.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.158.22:9090',\n      httpUrl: 'https://storage-17.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.154.25:9090',\n      httpUrl: 'https://storage-18.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.154.242:9090',\n      httpUrl: 'https://storage-19.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.154.168:9090',\n      httpUrl: 'https://storage-20.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.157.36:9090',\n      httpUrl: 'https://storage-21.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.157.4:9090',\n      httpUrl: 'https://storage-22.testnet.cere.network',\n      ssl: false,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.154.45:9090',\n      httpUrl: 'https://storage-23.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://162.212.157.254:9090',\n      httpUrl: 'https://storage-24.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://38.242.148.54:9090',\n      httpUrl: 'https://storage-25.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://38.242.148.67:9090',\n      httpUrl: 'https://storage-26.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://38.242.148.78:9090',\n      httpUrl: 'https://storage-27.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://154.12.245.135:9090',\n      httpUrl: 'https://storage-28.testnet.cere.network',\n      ssl: false,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://154.12.245.139:9090',\n      httpUrl: 'https://storage-29.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://154.12.245.141:9090',\n      httpUrl: 'https://storage-30.testnet.cere.network',\n      ssl: false,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://31.220.96.197:9090',\n      httpUrl: 'https://storage-31.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Storage,\n      grpcUrl: 'grpc://31.220.96.198:9090',\n      httpUrl: 'https://storage-32.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://37.27.26.9:9090',\n      httpUrl: 'https://storage-33.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://37.27.15.104:9090',\n      httpUrl: 'https://storage-34.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.108.244.154:9090',\n      httpUrl: 'https://storage-35.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.21.111.73:9090',\n      httpUrl: 'https://storage-36.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://135.181.80.135:9090',\n      httpUrl: 'https://storage-37.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.109.174.181:9090',\n      httpUrl: 'https://storage-38.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.109.227.87:9090',\n      httpUrl: 'https://storage-39.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.108.211.60:9090',\n      httpUrl: 'https://storage-40.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://78.47.122.10:9090',\n      httpUrl: 'https://storage-41.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://128.140.97.160:9090',\n      httpUrl: 'https://storage-42.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://49.13.23.245:9090',\n      httpUrl: 'https://storage-43.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://167.235.231.47:9090',\n      httpUrl: 'https://storage-44.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.21.54.218:9090',\n      httpUrl: 'https://storage-45.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://37.27.15.137:9090',\n      httpUrl: 'https://storage-46.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://95.216.139.48:9090',\n      httpUrl: 'https://storage-47.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://95.217.167.158:9090',\n      httpUrl: 'https://storage-48.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://149.248.2.7:9090',\n      httpUrl: 'https://storage-49.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://140.82.50.92:9090',\n      httpUrl: 'https://storage-50.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://149.28.111.44:9090',\n      httpUrl: 'https://storage-51.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://66.135.30.145:9090',\n      httpUrl: 'https://storage-52.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://45.63.65.67:9090',\n      httpUrl: 'https://storage-53.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://137.220.57.81:9090',\n      httpUrl: 'https://storage-54.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://207.148.2.17:9090',\n      httpUrl: 'https://storage-55.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://149.28.242.196:9090',\n      httpUrl: 'https://storage-56.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://64.176.183.175:9090',\n      httpUrl: 'https://storage-57.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://45.76.131.46:9090',\n      httpUrl: 'https://storage-58.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://108.61.198.218:9090',\n      httpUrl: 'https://storage-59.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://80.240.22.212:9090',\n      httpUrl: 'https://storage-60.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://107.191.63.179:9090',\n      httpUrl: 'https://storage-61.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.20.100.39:9090',\n      httpUrl: 'https://storage-62.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://65.20.112.89:9090',\n      httpUrl: 'https://storage-63.testnet.cere.network',\n      ssl: true,\n    },\n    {\n      mode: StorageNodeMode.Full,\n      grpcUrl: 'grpc://64.176.67.225:9090',\n      httpUrl: 'https://storage-64.testnet.cere.network',\n      ssl: true,\n    },\n  ],\n};\n"],"names":["createRpcMeta","token","meta","authMeta","toString","_extends","GrpcStatus","KB","MB","MIN_PIECE_SIZE","MAX_PIECE_SIZE","RETRYABLE_GRPC_ERROR_CODES","UNAVAILABLE","DEADLINE_EXCEEDED","RESOURCE_EXHAUSTED","ABORTED","INTERNAL","UNKNOWN","CANCELLED","RETRY_MAX_ATTEPTS","Signature_Algorithm","Signature","MessageType","constructor","super","no","name","kind","T","create","value","message","globalThis","Object","this","messagePrototype","algorithm","signer","Uint8Array","undefined","reflectionMergePartial","internalBinaryRead","reader","length","options","target","end","pos","fieldNo","wireType","tag","int32","bytes","u","readUnknownField","Error","typeName","d","skip","UnknownFieldHandler","onRead","internalBinaryWrite","writer","WireType","Varint","LengthDelimited","writeUnknownFields","onWrite","mapSignature","signature","SigAlg","SR_25519","encodeAddress","createSignature","async","proxySigner","maybeSdkSigner","isReady","type","ED_25519","publicKey","sign","Operation","AuthToken","Payload","uint32","payload","fork","join","opt","L","repeat","operations","prev","subject","canDelegate","bool","bucketId","uint64","toBigInt","e","push","expiresAt","int64","toNumber","pieceCid","i","Encoder","prefix","baseEncode","encode","Decoder","baseDecode","prefixCodePoint","codePointAt","decode","text","JSON","stringify","slice","or","decoder","ComposedDecoder","decoders","input","RangeError","keys","left","right","Codec","encoder","rfc4648","bitsPerChar","alphabet","alphabetIdx","createAlphabetIdx","from","data","pad","mask","out","bits","buffer","string","written","SyntaxError","base32","cidContentTypeMap","Cid","cid","toBytes","contentHash","contentType","isCid","byteLength","_unused","_excluded","params","_params$expiresIn","_params$canDelegate","_params$expiresAt","_AuthToken$maybeToken","expiresIn","Date","now","decodeAddress","maybeToken","Token","_this$token$payload","_this$token$payload$c","isSigned","_this$signature","toBinary","fromProto","protoToken","newToken","base58","parent","_parent$token$payload","_objectWithoutPropertiesLoose","fromBinary","fullAccess","GET","PUT","DELETE","signerRegistry","WeakMap","getRegestry","has","set","Map","get","getSdkSigner","address","createSdkToken","Web3Signer","isWeb3Signer","sdkSigner","randomSigner","createRandomSigner","createSdkSigner","finalToken","globalConsole","console","getLogLevel","_options$logger","logLevel","logger","level","getLogFn","defaultPrefix","rawArgs","_options$logOptions$m","_options$logOptions","levels","values","msgPrefix","logOptions","args","filter","arg","log","debug","rest","format","createLogger","info","warn","error","fatal","trace","silent","loggedErrors","WeakSet","bindErrorLogger","obj","methods","method","original","apply","err","add","PutRequest","Record","record","PutResponse","GetRequest","GetResponse","ttl","CnsApi","ServiceType","post","body","I","O","CnsApiClient","_transport","put","mergeOptions","stackIntercept","ActivityRequest_RequestType","ActivityRequest_ContentType","ActivityFulfillment","downstream","timestamp","upstream","ActivityRequest","requestId","requestType","id","offset","size","parentRequest","ActivityAcknowledgment","bytesStoredOrDelivered","request","ack","createActivityRequest","_ref","activityRequest","createRequestId","PIECE","Buffer","uuid","createAck","signedAck","CORRELATION_ID_META_KEY","correlationId","createCorrelationId","transport","api","putRecord","createCorrelationRpcMeta","createAuthRpcMeta","ProtoRecord","createSignatureMessage","ActivityRequestType","STORE","getRecord","cacheControl","_record","response","RpcError","code","Node","node","path","Link","Tag","links","tags","key","DagApi","additionalBindings","DagApiClient","CidValidator","enable","hasherPromise","getHasher","createBLAKE3","update","chunk","validate","_this$logger","receivedHash","digest","expectedHash","FileValidator","range","isProved","prove","proof","DagNodeValidator","_options$authenticate","authenticate","putNode","getNode","validator","TransformStream","ReadableStream","_globalThis$ReadableS2","_globalThis$ReadableS","prototype","_Symbol$asyncIterator","Symbol","asyncIterator","_wrapAsyncGenerator","getReader","done","_awaitAsyncGenerator","read","releaseLock","withChunkSize","chunkSize","transform","controller","concat","enqueue","call","flush","_buffer","_toIterable","isInputStream","_asyncGeneratorDelegate","_asyncIterator","arguments","getContentSize","content","defaultSize","ContentStreamSymbol","isContentStream","createContentStream","_x","toIterable","stream","pull","next","close","assign","pipeThrough","json","Response","arrayBuffer","PutRawPieceRequest","oneof","PutRawPieceRequest_Metadata","PutRawPieceRequest_Content","oneofKind","metadata","isMultipart","PutRawPieceResponse","PutMultiPartPieceRequest","totalSize","partSize","partHashes","PutMultiPartPieceResponse","GetFileRequest","GetFileRequest_Request","GetFileRequest_Request_Range","start","GetFileResponse","GetFileResponse_Proof","FileApi","clientStreaming","serverStreaming","FileApiClient","putRawPiece","putMultipartPiece","getFile","_excluded2","_excluded3","_options$enableAcks","enableAcks","Math","pow","ceil","log2","ProtoPutMultiPartPieceRequest","_ref2","requests","send","headers","bytesSent","Promise","race","status","complete","_ref3","_request$range","_toDataStream","_iteratorError","_iteratorAbruptCompletion","_didIteratorError","_iterator","_step","responses","then","catch","return","GrpcTransport","t","module","exports","r","n","o","l","m","c","defineProperty","configurable","enumerable","__esModule","default","hasOwnProperty","p","s","splitValues","headersMap","Headers","getHeaderKeys","forEach","getHeaderValues","append","splitHeaderValue","appendFromString","getOwnPropertyNames","Array","isArray","split","indexOf","substring","trim","delete","normalizeName","splice","normalizeValue","toHeaders","BrowserHeaders","iterateHeaders","iterator","iterateHeadersKeys","String","test","TypeError","toLowerCase","getAll","ChunkParser","ChunkType","encodeASCII","decodeASCII","fromCharCode","a","getUint8","getUint32","charCodeAt","MESSAGE","TRAILERS","position","parse","h","f","g","b","DataView","byteOffset","y","v","chunkType","trailers","Metadata","httpStatusToCode","Code","OK","Canceled","Unknown","InvalidArgument","DeadlineExceeded","NotFound","AlreadyExists","PermissionDenied","ResourceExhausted","FailedPrecondition","Aborted","OutOfRange","Unimplemented","Internal","Unavailable","DataLoss","Unauthenticated","client","started","sentFirstMessage","completed","closed","finishedSending","onHeadersCallbacks","onMessageCallbacks","onEndCallbacks","parser","methodDefinition","props","createTransport","url","host","service","serviceName","methodName","onHeaders","onTransportHeaders","bind","onChunk","onTransportChunk","onEnd","onTransportEnd","makeDefaultTransport","responseHeaders","rawOnHeaders","decodeGRPCStatus","rawOnError","responseType","deserializeBinary","rawOnMessage","responseTrailers","rawOnEnd","decodeURIComponent","setTimeout","toObject","onMessage","requestStream","frameRequest","sendMessage","finishSend","cancel","parseInt","grpc","setDefaultTransport","setDefaultTransportFactory","CrossBrowserHttpTransport","FetchReadableStreamTransport","XhrTransport","WebsocketTransport","invoke","unary","withCredentials","__assign","detectFetchSupport","cancelled","self","AbortController","init","pump","fetch","signal","abort","credentials","__extends","setPrototypeOf","__proto__","stringToArrayBuffer","MozChunkedArrayBufferXHR","XHR","detectMozXHRSupport","detectXHROverrideMimeTypeSupport","onProgressEvent","xhr","substr","index","onLoadEvent","onStateChange","readyState","XMLHttpRequest","HEADERS_RECEIVED","getAllResponseHeaders","open","configureXhr","setRequestHeader","Boolean","addEventListener","overrideMimeType","xhrSupportsResponseType","FINISH_SEND","Int8Array","CONNECTING","WebSocket","binaryType","onopen","onclose","onerror","onmessage","responseStream","statusMessage","serializeBinary","ArrayBuffer","setUint32","TimeoutAbortController","timeout","timeoutHandle","stop","clearTimeout","composeSignal","sigA","sigB","abortHandler","aborted","TimeoutInterceptor","interceptDuplex","interceptServerStreaming","interceptClientStreaming","interceptUnary","getStatus","statusCode","Number","detail","interceptors","defaultOptions","createHost","httpUrl","ssl","sanitizedUrl","URL","protocol","href","replace","_options$meta","InputType","mapType","defHeader","Deferred","defMessage","defStatus","defTrailer","emitError","rejectPending","reason","resolvePending","ClientStreamingCall","promise","duplex","_options$meta2","outStream","RpcOutputStreamController","notifyError","notifyMessage","notifyComplete","DuplexStreamingCall","state","DeferredState","PENDING","mergeRpcOptions","_options$meta3","reject","_options$abort","output","UnaryCall","NativeType","_WebType","WebType","DefaultTransport","Piece","contentLength","multipartOffset","isPart","isPiece","object","isStaticPiece","piece","locked","MultipartPiece","parts","map","part","isMultipartPiece","maybeMultipartPiece","PieceResponse","cidObject","_this$meta","hash","consumers","DagNode","dataBuffer","dag","mapDagNodeToAPI","isDagNode","maybeNode","DagNodeResponse","dagLinks","link","CnsRecord","isCnsRecord","CnsRecordResponse","mapCnsRecordToAPI","StorageNode","config","_config$timeout","nodeId","displayName","dagApi","fileApi","cnsApi","rootTokenPromise","mode","authToken","resolve","logErrors","getRootToken","createAuthToken","accessToken","inputToken","unsignedToken","storePiece","cidBytes","storeCnsRecord","storeDagNode","readPiece","cidOrName","resolveName","contentStream","getDagNode","storredRecord","getCnsRecord","RouterOperation","RoutingStrategy","BaseStrategy","marshalNodes","operation","allNodes","_globalThis$location","location","isSSLRequired","priorityMap","READ_DAG_NODE","Mode","Full","Cache","Storage","STORE_DAG_NODE","READ_PIECE","STORE_PIECE","READ_CNS_RECORD","STORE_CNS_RECORD","NodeTypeStrategy","nodes","opertaionPriorityMap","sort","_a$priority","_b$priority","priority","selectNode","PingStrategy","nodesMap","getPingedNodes","isDone","REJECTED","ping","pingUrl","cache","AbortSignal","ok","statusText","latency","enqueuePing","existingPing","pingRecord","allNodesShuffled","array","random","floor","shuffle","pingedNodes","allOperationNodes","notPingedNodes","toPingSync","max","toPingAsync","syncPings","allSettled","_this$nodesMap$get","_this$nodesMap$get2","latencyA","latencyB","Infinity","BlockchainStrategy","blockchain","bucketCache","clusterNodes","mapNodeProps","grpcPort","httpPort","domain","httpHost","grpcUrl","getNodes","clusterId","getBucket","getClusterNodes","ddcNodes","listStorageNodes","bucket","ddcCustomers","StaticStrategy","Router","strategy","sdkTokenPromise","getSdkToken","all","isValidSdkToken","_token$signature","exclude","includes","getNodeId","finalNodes","storageNode","NodeError","fromRpcError","finalError","withCorrelationId","BalancedNode","router","retryOptions","minTimeout","factor","retries","_config$retries","attempts","withRetry","_this","lastOperationError","lastRouterError","retry","bail","attempt","unshift","pop","nodeError","onRetry","_this$retryOptions$on","_this$retryOptions","storeOptions","readOptions","dagNode","getOptions","resolveOptions","MAINNET","TESTNET","DEVNET","DEFAULT_PRESET","DEVNET_STATIC","StorageNodeMode","TESTNET_STATIC"],"mappings":"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"}