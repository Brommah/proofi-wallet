var runtimeRpc = require('@protobuf-ts/runtime-rpc');
var base58 = require('bs58');
var blockchain = require('@cere-ddc-sdk/blockchain');
var runtime = require('@protobuf-ts/runtime');
var pino = require('pino');
var buffer = require('buffer');
var uuid = require('uuid');
var hashWasm = require('hash-wasm');
var web = require('stream/web');
var consumers$1 = require('stream/consumers');
var grpcJs = require('@grpc/grpc-js');
var grpcTransport = require('@protobuf-ts/grpc-transport');
var retry = require('async-retry');
var fetch$1 = require('cross-fetch');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var base58__default = /*#__PURE__*/_interopDefaultLegacy(base58);
var pino__default = /*#__PURE__*/_interopDefaultLegacy(pino);
var retry__default = /*#__PURE__*/_interopDefaultLegacy(retry);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch$1);

const createRpcMeta$1 = (token, meta) => {
  const authMeta = {};
  if (token) {
    authMeta.token = token.toString();
  }
  return {
    ...meta,
    ...authMeta
  };
};

var GrpcStatus;
(function (GrpcStatus) {
  GrpcStatus[GrpcStatus["OK"] = 0] = "OK";
  GrpcStatus[GrpcStatus["CANCELLED"] = 1] = "CANCELLED";
  GrpcStatus[GrpcStatus["UNKNOWN"] = 2] = "UNKNOWN";
  GrpcStatus[GrpcStatus["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
  GrpcStatus[GrpcStatus["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
  GrpcStatus[GrpcStatus["NOT_FOUND"] = 5] = "NOT_FOUND";
  GrpcStatus[GrpcStatus["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
  GrpcStatus[GrpcStatus["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
  GrpcStatus[GrpcStatus["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
  GrpcStatus[GrpcStatus["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
  GrpcStatus[GrpcStatus["ABORTED"] = 10] = "ABORTED";
  GrpcStatus[GrpcStatus["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
  GrpcStatus[GrpcStatus["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
  GrpcStatus[GrpcStatus["INTERNAL"] = 13] = "INTERNAL";
  GrpcStatus[GrpcStatus["UNAVAILABLE"] = 14] = "UNAVAILABLE";
  GrpcStatus[GrpcStatus["DATA_LOSS"] = 15] = "DATA_LOSS";
  GrpcStatus[GrpcStatus["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(GrpcStatus || (GrpcStatus = {}));

const KB = 1024;
const MB = 1024 * KB;
/**
 * Minimum size of a piece of content, in bytes.
 *
 * @hidden
 */
const MIN_PIECE_SIZE = 4 * MB;
/**
 * Maximum size of a piece of content, in bytes.
 *
 * @hidden
 */
const MAX_PIECE_SIZE = 128 * MB;
/**
 * Size of a chunk of a content stream, in bytes.
 * 4 MB (recomended gRPC message size) minus 100 KB reserved for the message structure.
 */
const CONTENT_CHUNK_SIZE = 4 * MB - 100 * KB;
/**
 * Expiration time for an authentication token, in milliseconds.
 * This is set to one month.
 */
const AUTH_TOKEN_EXPIRATION_TIME = 30 * 24 * 60 * 60 * 1000;
/**
 * Default inactivity timeout for gRPC requests, in milliseconds.
 * This is set to 30 seconds.
 */
const GRPC_REQUEST_INACTIVITY_TIMEOUT = 30 * 1000;
/**
 * gRPC error codes that should trigger a retry of the operation.
 */
const RETRYABLE_GRPC_ERROR_CODES = [GrpcStatus.UNAVAILABLE, GrpcStatus.DEADLINE_EXCEEDED, GrpcStatus.RESOURCE_EXHAUSTED, GrpcStatus.ABORTED, GrpcStatus.INTERNAL, GrpcStatus.UNKNOWN,
/**
 * GRPC library uses this error code when a request is cancelled using abort signals, and it does not respect `AbortSignal.reason`.
 * Currently there is no way to cancel a request using the SDK API. So the only possible source of this errors is internal timeout logic.
 *
 * TODO: If we let developers to cancel requests, we should handle this error code or figure out a way to avoid re-trying.
 */
GrpcStatus.CANCELLED];
/**
 * Maximum number of attempts to retry an operation.
 */
const RETRY_MAX_ATTEPTS = 5;
/**
 * Minimum number of nodes to ping before any DDC operation.
 */
const PING_THRESHOLD = 10;
/**
 * Number of additional nodes to ping in the background after each operation.
 */
const PING_THRESHOLD_INC = 2;
/**
 * Coefficient in milliseconds to group nodes by latency.
 */
const PING_LATENCY_GROUP = 100;
/**
 * Delay in milliseconds before starting background pings after an operation.
 */
const PING_BACKGROUND_DELAY = 100;
/**
 * Timeout in milliseconds for aborting a ping request.
 */
const PING_ABORT_TIMEOUT = 1000;

/**
 * @generated from protobuf enum common.Signature.Algorithm
 */
var Signature_Algorithm;
(function (Signature_Algorithm) {
  /**
   * @generated from protobuf enum value: ED_25519 = 0;
   */
  Signature_Algorithm[Signature_Algorithm["ED_25519"] = 0] = "ED_25519";
  /**
   * @generated from protobuf enum value: SR_25519 = 1;
   */
  Signature_Algorithm[Signature_Algorithm["SR_25519"] = 1] = "SR_25519";
})(Signature_Algorithm || (Signature_Algorithm = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Signature$Type extends runtime.MessageType {
  constructor() {
    super("common.Signature", [{
      no: 1,
      name: "algorithm",
      kind: "enum",
      T: () => ["common.Signature.Algorithm", Signature_Algorithm]
    }, {
      no: 2,
      name: "signer",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 3,
      name: "value",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.algorithm = 0;
    message.signer = new Uint8Array(0);
    message.value = new Uint8Array(0);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* common.Signature.Algorithm algorithm */1:
          message.algorithm = reader.int32();
          break;
        case /* bytes signer */2:
          message.signer = reader.bytes();
          break;
        case /* bytes value */3:
          message.value = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* common.Signature.Algorithm algorithm = 1; */
    if (message.algorithm !== 0) writer.tag(1, runtime.WireType.Varint).int32(message.algorithm);
    /* bytes signer = 2; */
    if (message.signer.length) writer.tag(2, runtime.WireType.LengthDelimited).bytes(message.signer);
    /* bytes value = 3; */
    if (message.value.length) writer.tag(3, runtime.WireType.LengthDelimited).bytes(message.value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message common.Signature
 */
const Signature = new Signature$Type();

const mapSignature = signature => ({
  algorithm: signature.algorithm === Signature_Algorithm.SR_25519 ? 'sr25519' : 'ed25519',
  signer: blockchain.encodeAddress(signature.signer),
  value: new Uint8Array(signature.value)
});

const createSignature = async (signer, message, {
  token
} = {}) => {
  const proxySigner = maybeSdkSigner(signer, token);
  await proxySigner.isReady();
  if (proxySigner.type !== 'ed25519' && proxySigner.type !== 'sr25519') {
    throw new Error(`Signer type ${proxySigner.type} is not allowed in DDC`);
  }
  return Signature.create({
    algorithm: proxySigner.type === 'ed25519' ? Signature_Algorithm.ED_25519 : Signature_Algorithm.SR_25519,
    signer: proxySigner.publicKey,
    value: await proxySigner.sign(message)
  });
};

/**
 * @generated from protobuf enum Operation
 */
exports.AuthTokenOperation = void 0;
(function (Operation) {
  /**
   * @generated from protobuf enum value: UNKNOWN = 0;
   */
  Operation[Operation["UNKNOWN"] = 0] = "UNKNOWN";
  /**
   * @generated from protobuf enum value: PUT = 1;
   */
  Operation[Operation["PUT"] = 1] = "PUT";
  /**
   * @generated from protobuf enum value: GET = 2;
   */
  Operation[Operation["GET"] = 2] = "GET";
  /**
   * @generated from protobuf enum value: DELETE = 3;
   */
  Operation[Operation["DELETE"] = 3] = "DELETE";
})(exports.AuthTokenOperation || (exports.AuthTokenOperation = {}));
// @generated message type with reflection information, may provide speed optimized methods
class AuthToken$Type extends runtime.MessageType {
  constructor() {
    super("AuthToken", [{
      no: 1,
      name: "signature",
      kind: "message",
      T: () => Signature
    }, {
      no: 2,
      name: "payload",
      kind: "message",
      T: () => Payload
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* common.Signature signature */1:
          message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
          break;
        case /* Payload payload */2:
          message.payload = Payload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* common.Signature signature = 1; */
    if (message.signature) Signature.internalBinaryWrite(message.signature, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* Payload payload = 2; */
    if (message.payload) Payload.internalBinaryWrite(message.payload, writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message AuthToken
 */
const AuthToken$1 = new AuthToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Payload$Type extends runtime.MessageType {
  constructor() {
    super("Payload", [{
      no: 1,
      name: "prev",
      kind: "message",
      T: () => AuthToken$1
    }, {
      no: 2,
      name: "subject",
      kind: "scalar",
      opt: true,
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 3,
      name: "canDelegate",
      kind: "scalar",
      opt: true,
      T: 8 /*ScalarType.BOOL*/
    }, {
      no: 4,
      name: "bucketId",
      kind: "scalar",
      opt: true,
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 5,
      name: "operations",
      kind: "enum",
      repeat: 1 /*RepeatType.PACKED*/,
      T: () => ["Operation", exports.AuthTokenOperation]
    }, {
      no: 6,
      name: "expiresAt",
      kind: "scalar",
      opt: true,
      T: 3 /*ScalarType.INT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 7,
      name: "pieceCid",
      kind: "scalar",
      opt: true,
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.operations = [];
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional AuthToken prev */1:
          message.prev = AuthToken$1.internalBinaryRead(reader, reader.uint32(), options, message.prev);
          break;
        case /* optional bytes subject */2:
          message.subject = reader.bytes();
          break;
        case /* optional bool canDelegate */3:
          message.canDelegate = reader.bool();
          break;
        case /* optional uint64 bucketId = 4 [jstype = JS_NORMAL];*/4:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* repeated Operation operations */5:
          if (wireType === runtime.WireType.LengthDelimited) for (let e = reader.int32() + reader.pos; reader.pos < e;) message.operations.push(reader.int32());else message.operations.push(reader.int32());
          break;
        case /* optional int64 expiresAt */6:
          message.expiresAt = reader.int64().toNumber();
          break;
        case /* optional bytes pieceCid */7:
          message.pieceCid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* optional AuthToken prev = 1; */
    if (message.prev) AuthToken$1.internalBinaryWrite(message.prev, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* optional bytes subject = 2; */
    if (message.subject !== undefined) writer.tag(2, runtime.WireType.LengthDelimited).bytes(message.subject);
    /* optional bool canDelegate = 3; */
    if (message.canDelegate !== undefined) writer.tag(3, runtime.WireType.Varint).bool(message.canDelegate);
    /* optional uint64 bucketId = 4 [jstype = JS_NORMAL]; */
    if (message.bucketId !== undefined) writer.tag(4, runtime.WireType.Varint).uint64(message.bucketId);
    /* repeated Operation operations = 5; */
    if (message.operations.length) {
      writer.tag(5, runtime.WireType.LengthDelimited).fork();
      for (let i = 0; i < message.operations.length; i++) writer.int32(message.operations[i]);
      writer.join();
    }
    /* optional int64 expiresAt = 6; */
    if (message.expiresAt !== undefined) writer.tag(6, runtime.WireType.Varint).int64(message.expiresAt);
    /* optional bytes pieceCid = 7; */
    if (message.pieceCid !== undefined) writer.tag(7, runtime.WireType.LengthDelimited).bytes(message.pieceCid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Payload
 */
const Payload = new Payload$Type();

/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 */
class Encoder {
    name;
    prefix;
    baseEncode;
    constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        }
        else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 */
class Decoder {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        const prefixCodePoint = prefix.codePointAt(0);
        /* c8 ignore next 3 */
        if (prefixCodePoint === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefixCodePoint;
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        }
        else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    decoders;
    constructor(decoders) {
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) {
            return decoder.decode(input);
        }
        else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
function or(left, right) {
    return new ComposedDecoder({
        ...(left.decoders ?? { [left.prefix]: left }),
        ...(right.decoders ?? { [right.prefix]: right })
    });
}
class Codec {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
function from({ name, prefix, encode, decode }) {
    return new Codec(name, prefix, encode, decode);
}
function decode(string, alphabetIdx, bitsPerChar, name) {
    // Count the padding bytes:
    let end = string.length;
    while (string[end - 1] === '=') {
        --end;
    }
    // Allocate the output:
    const out = new Uint8Array((end * bitsPerChar / 8) | 0);
    // Parse the data:
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    let written = 0; // Next byte to write
    for (let i = 0; i < end; ++i) {
        // Read one character from the string:
        const value = alphabetIdx[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        // Append the bits to the buffer:
        buffer = (buffer << bitsPerChar) | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & (buffer >> bits);
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
}
function encode(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    for (let i = 0; i < data.length; ++i) {
        // Slurp data into the buffer:
        buffer = (buffer << 8) | data[i];
        bits += 8;
        // Write out as much as we can:
        while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet[mask & (buffer >> bits)];
        }
    }
    // Partial character:
    if (bits !== 0) {
        out += alphabet[mask & (buffer << (bitsPerChar - bits))];
    }
    // Add padding characters until we hit a byte boundary:
    if (pad) {
        while (((out.length * bitsPerChar) & 7) !== 0) {
            out += '=';
        }
    }
    return out;
}
function createAlphabetIdx(alphabet) {
    // Build the character lookup table:
    const alphabetIdx = {};
    for (let i = 0; i < alphabet.length; ++i) {
        alphabetIdx[alphabet[i]] = i;
    }
    return alphabetIdx;
}
/**
 * RFC4648 Factory
 */
function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    const alphabetIdx = createAlphabetIdx(alphabet);
    return from({
        prefix,
        name,
        encode(input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode(input) {
            return decode(input, alphabetIdx, bitsPerChar, name);
        }
    });
}

const base32 = rfc4648({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
});
rfc4648({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
});
rfc4648({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
});
rfc4648({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
});
rfc4648({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
});
rfc4648({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
});
rfc4648({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
});
rfc4648({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
});
rfc4648({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
});

const cidContentTypeMap = ['none', 'dag-node', 'raw-piece', 'multipart-piece'];
/**
 * The `Cid` class represents a Content Identifier (CID) in DDC.
 *
 * @internal
 */
class Cid {
  constructor(cid) {
    this.cid = void 0;
    this.cid = cid instanceof Cid ? cid.toBytes() : cid;
  }
  /**
   * The content hash of the CID.
   */
  get contentHash() {
    return this.toBytes().slice(-32);
  }
  get contentType() {
    return cidContentTypeMap[this.toBytes()[1]];
  }
  /**
   * Converts the CID to a string.
   *
   * @returns The CID as a string.
   */
  toString() {
    return typeof this.cid === 'string' ? this.cid : base32.encode(this.cid);
  }
  /**
   * Converts the CID to a `Uint8Array`.
   *
   * @returns The CID as a `Uint8Array`.
   */
  toBytes() {
    return typeof this.cid === 'string' ? base32.decode(this.cid) : this.cid;
  }
  /**
   * Checks if an object is an instance of `Cid`.
   *
   * @param object - The object to check.
   *
   * @returns `true` if the object is an instance of `Cid` or has the same properties as a `Cid`, `false` otherwise.
   */
  static isCid(cid) {
    try {
      const bytes = new Cid(cid).toBytes();
      return bytes.byteLength > 32; // TODO: Implement proper CID parsing and detection
    } catch {
      return false;
    }
  }
}

/**
 * The `AuthToken` class represents an authentication token.
 *
 * @group Authentication
 *
 * @example
 *
 * ```typescript
 * const authToken = new AuthToken({
 *   bucketId: 1n,
 *   operations: [AuthTokenOperation.GET],
 * });
 *
 * await authToken.sign(signer);
 *
 * const sharebleToken = authToken.toString();
 * console.log(sharebleToken);
 *
 * const authTokenFromSharebleToken = AuthToken.from(sharebleToken);
 * console.log(authTokenFromSharebleToken);
 * ```
 */
class AuthToken {
  constructor(params) {
    var _params$expiresIn, _params$canDelegate, _params$expiresAt, _AuthToken$maybeToken;
    this.token = void 0;
    const expiresIn = (_params$expiresIn = params.expiresIn) != null ? _params$expiresIn : AUTH_TOKEN_EXPIRATION_TIME;
    const payload = {
      bucketId: params.bucketId,
      operations: params.operations,
      canDelegate: (_params$canDelegate = params.canDelegate) != null ? _params$canDelegate : false,
      expiresAt: (_params$expiresAt = params.expiresAt) != null ? _params$expiresAt : Date.now() + expiresIn,
      subject: params.subject ? blockchain.decodeAddress(params.subject) : undefined,
      pieceCid: params.pieceCid ? new Cid(params.pieceCid).toBytes() : undefined,
      prev: (_AuthToken$maybeToken = AuthToken.maybeToken(params.prev)) == null ? void 0 : _AuthToken$maybeToken.token
    };
    this.token = AuthToken$1.create({
      payload
    });
  }
  /*
   * The subject of the token.
   */
  get subject() {
    var _this$token$payload;
    return ((_this$token$payload = this.token.payload) == null ? void 0 : _this$token$payload.subject) && blockchain.encodeAddress(this.token.payload.subject);
  }
  /**
   * The signature of the token
   */
  get signature() {
    return this.token.signature && mapSignature(this.token.signature);
  }
  /**
   * Whether the token can delegate access.
   */
  get canDelegate() {
    var _this$token$payload$c;
    return (_this$token$payload$c = this.token.payload.canDelegate) != null ? _this$token$payload$c : false;
  }
  /**
   * The bucket identifier that the token grants access to.
   */
  get bucketId() {
    return this.token.payload.bucketId;
  }
  /**
   * The operations that the token grants access to.
   */
  get operations() {
    return this.token.payload.operations;
  }
  /**
   * The piece CID that the token grants access to.
   */
  get pieceCid() {
    return this.token.payload.pieceCid && new Cid(this.token.payload.pieceCid).toString();
  }
  /**
   * The expiration time of the token.
   */
  get expiresAt() {
    return this.token.payload.expiresAt;
  }
  /**
   * Whether the token is properly signed.
   */
  get isSigned() {
    var _this$signature;
    return this.subject ? ((_this$signature = this.signature) == null ? void 0 : _this$signature.signer) === this.subject : !!this.signature;
  }
  toBinary() {
    return AuthToken$1.toBinary(this.token);
  }
  static fromProto(protoToken) {
    const newToken = new AuthToken({
      operations: []
    });
    newToken.token = protoToken;
    return newToken;
  }
  /**
   * Converts the authentication token to a string.
   *
   * @returns The authentication token as a base58-encoded string.
   */
  toString() {
    return base58__default["default"].encode(this.toBinary());
  }
  /**
   * Signs the authentication token using the provided signer.
   *
   * @param signer - The instance of Signer to use for signing the token.
   *
   * @example
   *
   * ```typescript
   * const signer: Signer = ...;
   * const authToken = new AuthToken(...);
   *
   * await authToken.sign(signer);
   * ```
   */
  async sign(signer) {
    this.token.signature = await createSignature(signer, this.toBinary());
    return this;
  }
  /**
   * Creates an `AuthToken` from a string or another `AuthToken`.
   *
   * @param token - The token as a string or an `AuthToken`.
   *
   * @returns An instance of the `AuthToken` class.
   *
   * @throws Will throw an error if the token is invalid.
   *
   * @example
   *
   * ```typescript
   * const token: string = '...';
   * const authToken = AuthToken.from(token);
   *
   * console.log(authToken);
   * ```
   */
  static from(token) {
    const parent = this.maybeToken(token);
    if (!(parent != null && parent.token.payload)) {
      throw new Error('Invalid token');
    }
    const {
      subject,
      ...params
    } = parent.token.payload;
    return new AuthToken({
      ...params,
      prev: subject && parent // Set `prev` only if `subject` is provided
    });
  }
  /**
   * This static method is used to convert a token into an AuthToken object.
   *
   * @param token - The input token, which can be either a string or an AuthToken object.
   * @returns - If the input token is a string, returns an AuthToken object created from the string.
   *            If the input token is already an AuthToken object, returns the input token as is.
   *
   * @example
   *
   * ```typescript
   * const token: string = '...';
   * const authToken = AuthToken.maybeToken(token);
   *
   * console.log(authToken);
   * ```
   */
  static maybeToken(token) {
    if (typeof token !== 'string') {
      return token;
    }
    return this.fromProto(AuthToken$1.fromBinary(base58__default["default"].decode(token)));
  }
  /**
   * Creates an `AuthToken` with full access (GET, PUT, DELETE operations).
   *
   * @param params - The parameters of the token access.
   *
   * @returns An instance of the `AuthToken` class with full access.
   *
   * @example
   *
   * ```typescript
   * const authToken = AuthToken.fullAccess({
   *   bucketId: 1n,
   * });
   * ```
   */
  static fullAccess(params = {}) {
    return new AuthToken({
      ...params,
      operations: [exports.AuthTokenOperation.GET, exports.AuthTokenOperation.PUT, exports.AuthTokenOperation.DELETE]
    });
  }
}

const signerRegistry = new WeakMap();
const isWeb3Signer = signer => {
  return signer instanceof blockchain.Web3Signer;
};
const getRegestry = signer => {
  if (!signerRegistry.has(signer)) {
    signerRegistry.set(signer, new Map());
  }
  return signerRegistry.get(signer);
};
const createSdkSigner = async signer => {
  const randomSigner = blockchain.createRandomSigner({
    type: signer.type
  });
  await randomSigner.isReady();
  getRegestry(signer).set(randomSigner.address, randomSigner);
  return randomSigner;
};
const getSdkSigner = (signer, address) => {
  return getRegestry(signer).get(address);
};
const isValidSdkToken = (signer, token) => {
  var _token$signature;
  return signer.address === ((_token$signature = token.signature) == null ? void 0 : _token$signature.signer);
};
const createSdkToken = async signer => {
  if (!isWeb3Signer(signer)) {
    return AuthToken.fullAccess().sign(signer);
  }
  const sdkSigner = await createSdkSigner(signer);
  return AuthToken.fullAccess({
    subject: sdkSigner.address
  }).sign(signer);
};
const maybeSdkSigner = (signer, token) => {
  const finalToken = AuthToken.maybeToken(token);
  return (finalToken == null ? void 0 : finalToken.signature) && getSdkSigner(signer, finalToken.signature.signer) || signer;
};

const truncateHex = function (input, maxLength = 100, separator = '...') {
  if (input.length <= maxLength) return input;
  const separatorLength = separator.length,
    charsToShow = maxLength - separatorLength,
    frontChars = Math.ceil(charsToShow / 2),
    backChars = Math.floor(charsToShow / 2);
  return input.substring(0, frontChars) + separator + input.substring(input.length - backChars);
};
/**
 * Maps the log object using the provided function.
 */
const mapLog = fn => log => {
  const nextLog = {
    ...log
  };
  for (const [key, value] of Object.entries(log)) {
    const isObject = value && typeof value === 'object' && !ArrayBuffer.isView(value);
    const isError = value instanceof Error;
    nextLog[key] = isObject && !isError ? mapLog(fn)(value) : fn(value, key);
  }
  return nextLog;
};
const createLogger = (defaultPrefix, options = {}) => {
  var _logOptions$msgPrefix;
  const {
    logger,
    logOptions = {},
    logLevel = 'warn'
  } = options;
  const msgPrefix = (_logOptions$msgPrefix = logOptions.msgPrefix) != null ? _logOptions$msgPrefix : `[${defaultPrefix}] `;
  /**
   * If the provided logger is already a pino logger, we just add a child logger to it.
   */
  if (logger) {
    const pinologger = logger;
    return pinologger.child({});
  }
  const output = logOptions.output || {
    type: 'console',
    format: 'pretty'
  };
  const outputs = Array.isArray(output) ? output : [output];
  const targets = outputs.map(output => {
    var _output$append;
    return {
      target: output.format === 'json' ? 'pino/file' : 'pino-pretty',
      level: output.level || logLevel,
      options: output.type === 'file' ? {
        destination: output.path,
        append: (_output$append = output.append) != null ? _output$append : false,
        colorize: false,
        mkdir: true
      } : {
        destination: 1,
        // stdout
        colorize: true,
        colorizeObjects: true,
        levelFirst: true,
        ignore: 'hostname,pid',
        sync: true
      }
    };
  });
  return pino__default["default"]({
    level: logLevel,
    msgPrefix,
    transport: {
      targets
    },
    depthLimit: 3,
    edgeLimit: 10,
    formatters: {
      log: mapLog(value => {
        if (value instanceof Uint8Array) {
          return '0x' + truncateHex(buffer.Buffer.from(value).toString('hex'));
        }
        return value;
      })
    }
  });
};

const loggedErrors = new WeakSet();
const bindErrorLogger = (obj, logger, methods) => {
  for (const method of methods.filter(method => typeof obj[method] === 'function')) {
    const original = obj[method];
    const patched = async function (...args) {
      try {
        return await original.apply(this, args);
      } catch (err) {
        const error = err;
        if (!loggedErrors.has(error)) {
          loggedErrors.add(error);
          logger.error(error, 'Error in %s', original.name || 'anonymous function');
        }
        throw error;
      }
    };
    obj[method] = patched;
  }
};

/* eslint-disable */
// @generated message type with reflection information, may provide speed optimized methods
class PutRequest$Type$1 extends runtime.MessageType {
  constructor() {
    super("cns.PutRequest", [{
      no: 1,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 2,
      name: "record",
      kind: "message",
      T: () => Record
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketId = 0n;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/1:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* cns.Record record */2:
          message.record = Record.internalBinaryRead(reader, reader.uint32(), options, message.record);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(1, runtime.WireType.Varint).uint64(message.bucketId);
    /* cns.Record record = 2; */
    if (message.record) Record.internalBinaryWrite(message.record, writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message cns.PutRequest
 */
const PutRequest$1 = new PutRequest$Type$1();
// @generated message type with reflection information, may provide speed optimized methods
class PutResponse$Type$1 extends runtime.MessageType {
  constructor() {
    super("cns.PutResponse", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    return target != null ? target : this.create();
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message cns.PutResponse
 */
const PutResponse$1 = new PutResponse$Type$1();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequest$Type$1 extends runtime.MessageType {
  constructor() {
    super("cns.GetRequest", [{
      no: 1,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9 /*ScalarType.STRING*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketId = 0n;
    message.name = "";
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/1:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* string name */2:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(1, runtime.WireType.Varint).uint64(message.bucketId);
    /* string name = 2; */
    if (message.name !== "") writer.tag(2, runtime.WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message cns.GetRequest
 */
const GetRequest$1 = new GetRequest$Type$1();
// @generated message type with reflection information, may provide speed optimized methods
class GetResponse$Type$1 extends runtime.MessageType {
  constructor() {
    super("cns.GetResponse", [{
      no: 1,
      name: "record",
      kind: "message",
      T: () => Record
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* cns.Record record */1:
          message.record = Record.internalBinaryRead(reader, reader.uint32(), options, message.record);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* cns.Record record = 1; */
    if (message.record) Record.internalBinaryWrite(message.record, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message cns.GetResponse
 */
const GetResponse$1 = new GetResponse$Type$1();
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends runtime.MessageType {
  constructor() {
    super("cns.Record", [{
      no: 1,
      name: "signature",
      kind: "message",
      T: () => Signature
    }, {
      no: 2,
      name: "cid",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 3,
      name: "name",
      kind: "scalar",
      T: 9 /*ScalarType.STRING*/
    }, {
      no: 4,
      name: "ttl",
      kind: "scalar",
      opt: true,
      T: 13 /*ScalarType.UINT32*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = new Uint8Array(0);
    message.name = "";
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* common.Signature signature */1:
          message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
          break;
        case /* bytes cid */2:
          message.cid = reader.bytes();
          break;
        case /* string name */3:
          message.name = reader.string();
          break;
        case /* optional uint32 ttl */4:
          message.ttl = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* common.Signature signature = 1; */
    if (message.signature) Signature.internalBinaryWrite(message.signature, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* bytes cid = 2; */
    if (message.cid.length) writer.tag(2, runtime.WireType.LengthDelimited).bytes(message.cid);
    /* string name = 3; */
    if (message.name !== "") writer.tag(3, runtime.WireType.LengthDelimited).string(message.name);
    /* optional uint32 ttl = 4; */
    if (message.ttl !== undefined) writer.tag(4, runtime.WireType.Varint).uint32(message.ttl);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message cns.Record
 */
const Record = new Record$Type();
/**
 * @generated ServiceType for protobuf service cns.CnsApi
 */
const CnsApi$1 = new runtimeRpc.ServiceType("cns.CnsApi", [{
  name: "Put",
  options: {
    "google.api.http": {
      post: "/v1/cns/{bucketId}",
      body: "*"
    }
  },
  I: PutRequest$1,
  O: PutResponse$1
}, {
  name: "Get",
  options: {
    "google.api.http": {
      get: "/v1/cns/{bucketId}/{name}"
    }
  },
  I: GetRequest$1,
  O: GetResponse$1
}]);

/**
 * @generated from protobuf service cns.CnsApi
 */
class CnsApiClient {
  constructor(_transport) {
    this._transport = void 0;
    this.typeName = CnsApi$1.typeName;
    this.methods = CnsApi$1.methods;
    this.options = CnsApi$1.options;
    this._transport = _transport;
  }
  /**
   * @generated from protobuf rpc: Put(cns.PutRequest) returns (cns.PutResponse);
   */
  put(input, options) {
    const method = this.methods[0],
      opt = this._transport.mergeOptions(options);
    return runtimeRpc.stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: Get(cns.GetRequest) returns (cns.GetResponse);
   */
  get(input, options) {
    const method = this.methods[1],
      opt = this._transport.mergeOptions(options);
    return runtimeRpc.stackIntercept("unary", this._transport, method, opt, input);
  }
}

/**
 * @generated from protobuf enum activity_report.ActivityRequest.RequestType
 */
var ActivityRequest_RequestType;
(function (ActivityRequest_RequestType) {
  /**
   * @generated from protobuf enum value: REQUEST_TYPE_STORE = 0;
   */
  ActivityRequest_RequestType[ActivityRequest_RequestType["STORE"] = 0] = "STORE";
  /**
   * @generated from protobuf enum value: REQUEST_TYPE_GET = 1;
   */
  ActivityRequest_RequestType[ActivityRequest_RequestType["GET"] = 1] = "GET";
})(ActivityRequest_RequestType || (ActivityRequest_RequestType = {}));
/**
 * @generated from protobuf enum activity_report.ActivityRequest.ContentType
 */
var ActivityRequest_ContentType;
(function (ActivityRequest_ContentType) {
  /**
   * @generated from protobuf enum value: CONTENT_TYPE_PIECE = 0;
   */
  ActivityRequest_ContentType[ActivityRequest_ContentType["PIECE"] = 0] = "PIECE";
  /**
   * @generated from protobuf enum value: CONTENT_TYPE_SEGMENT = 1;
   */
  ActivityRequest_ContentType[ActivityRequest_ContentType["SEGMENT"] = 1] = "SEGMENT";
  /**
   * @generated from protobuf enum value: CONTENT_TYPE_MERKLE_TREE = 2;
   */
  ActivityRequest_ContentType[ActivityRequest_ContentType["MERKLE_TREE"] = 2] = "MERKLE_TREE";
})(ActivityRequest_ContentType || (ActivityRequest_ContentType = {}));
// @generated message type with reflection information, may provide speed optimized methods
class ActivityRecord$Type extends runtime.MessageType {
  constructor() {
    super("activity_report.ActivityRecord", [{
      no: 1,
      name: "upstream",
      kind: "message",
      T: () => ActivityFulfillment
    }, {
      no: 2,
      name: "downstream",
      kind: "message",
      repeat: 1 /*RepeatType.PACKED*/,
      T: () => ActivityFulfillment
    }, {
      no: 3,
      name: "timestamp",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 10,
      name: "signature",
      kind: "message",
      T: () => Signature
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.downstream = [];
    message.timestamp = 0;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* activity_report.ActivityFulfillment upstream */1:
          message.upstream = ActivityFulfillment.internalBinaryRead(reader, reader.uint32(), options, message.upstream);
          break;
        case /* repeated activity_report.ActivityFulfillment downstream */2:
          message.downstream.push(ActivityFulfillment.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* uint64 timestamp */3:
          message.timestamp = reader.uint64().toNumber();
          break;
        case /* common.Signature signature */10:
          message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* activity_report.ActivityFulfillment upstream = 1; */
    if (message.upstream) ActivityFulfillment.internalBinaryWrite(message.upstream, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* repeated activity_report.ActivityFulfillment downstream = 2; */
    for (let i = 0; i < message.downstream.length; i++) ActivityFulfillment.internalBinaryWrite(message.downstream[i], writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    /* uint64 timestamp = 3; */
    if (message.timestamp !== 0) writer.tag(3, runtime.WireType.Varint).uint64(message.timestamp);
    /* common.Signature signature = 10; */
    if (message.signature) Signature.internalBinaryWrite(message.signature, writer.tag(10, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message activity_report.ActivityRecord
 */
new ActivityRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityRequest$Type extends runtime.MessageType {
  constructor() {
    super("activity_report.ActivityRequest", [{
      no: 1,
      name: "parentRequest",
      kind: "message",
      T: () => ActivityRequest
    }, {
      no: 2,
      name: "requestId",
      kind: "scalar",
      T: 9 /*ScalarType.STRING*/
    }, {
      no: 3,
      name: "requestType",
      kind: "enum",
      T: () => ["activity_report.ActivityRequest.RequestType", ActivityRequest_RequestType, "REQUEST_TYPE_"]
    }, {
      no: 4,
      name: "contentType",
      kind: "enum",
      T: () => ["activity_report.ActivityRequest.ContentType", ActivityRequest_ContentType, "CONTENT_TYPE_"]
    }, {
      no: 5,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 6,
      name: "id",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 7,
      name: "offset",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 8,
      name: "size",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 9,
      name: "timestamp",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 10,
      name: "signature",
      kind: "message",
      T: () => Signature
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.requestId = "";
    message.requestType = 0;
    message.contentType = 0;
    message.bucketId = 0n;
    message.id = new Uint8Array(0);
    message.offset = 0;
    message.size = 0;
    message.timestamp = 0;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional activity_report.ActivityRequest parentRequest */1:
          message.parentRequest = ActivityRequest.internalBinaryRead(reader, reader.uint32(), options, message.parentRequest);
          break;
        case /* string requestId */2:
          message.requestId = reader.string();
          break;
        case /* activity_report.ActivityRequest.RequestType requestType */3:
          message.requestType = reader.int32();
          break;
        case /* activity_report.ActivityRequest.ContentType contentType */4:
          message.contentType = reader.int32();
          break;
        case /* uint64 bucketId = 5 [jstype = JS_NORMAL];*/5:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* bytes id */6:
          message.id = reader.bytes();
          break;
        case /* uint64 offset */7:
          message.offset = reader.uint64().toNumber();
          break;
        case /* uint64 size */8:
          message.size = reader.uint64().toNumber();
          break;
        case /* uint64 timestamp */9:
          message.timestamp = reader.uint64().toNumber();
          break;
        case /* common.Signature signature */10:
          message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* optional activity_report.ActivityRequest parentRequest = 1; */
    if (message.parentRequest) ActivityRequest.internalBinaryWrite(message.parentRequest, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* string requestId = 2; */
    if (message.requestId !== "") writer.tag(2, runtime.WireType.LengthDelimited).string(message.requestId);
    /* activity_report.ActivityRequest.RequestType requestType = 3; */
    if (message.requestType !== 0) writer.tag(3, runtime.WireType.Varint).int32(message.requestType);
    /* activity_report.ActivityRequest.ContentType contentType = 4; */
    if (message.contentType !== 0) writer.tag(4, runtime.WireType.Varint).int32(message.contentType);
    /* uint64 bucketId = 5 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(5, runtime.WireType.Varint).uint64(message.bucketId);
    /* bytes id = 6; */
    if (message.id.length) writer.tag(6, runtime.WireType.LengthDelimited).bytes(message.id);
    /* uint64 offset = 7; */
    if (message.offset !== 0) writer.tag(7, runtime.WireType.Varint).uint64(message.offset);
    /* uint64 size = 8; */
    if (message.size !== 0) writer.tag(8, runtime.WireType.Varint).uint64(message.size);
    /* uint64 timestamp = 9; */
    if (message.timestamp !== 0) writer.tag(9, runtime.WireType.Varint).uint64(message.timestamp);
    /* common.Signature signature = 10; */
    if (message.signature) Signature.internalBinaryWrite(message.signature, writer.tag(10, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message activity_report.ActivityRequest
 */
const ActivityRequest = new ActivityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityAcknowledgment$Type extends runtime.MessageType {
  constructor() {
    super("activity_report.ActivityAcknowledgment", [{
      no: 1,
      name: "requestId",
      kind: "scalar",
      T: 9 /*ScalarType.STRING*/
    }, {
      no: 2,
      name: "bytesStoredOrDelivered",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 3,
      name: "timestamp",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 4,
      name: "signature",
      kind: "message",
      T: () => Signature
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.requestId = "";
    message.bytesStoredOrDelivered = 0;
    message.timestamp = 0;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string requestId */1:
          message.requestId = reader.string();
          break;
        case /* uint64 bytesStoredOrDelivered */2:
          message.bytesStoredOrDelivered = reader.uint64().toNumber();
          break;
        case /* uint64 timestamp */3:
          message.timestamp = reader.uint64().toNumber();
          break;
        case /* common.Signature signature */4:
          message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* string requestId = 1; */
    if (message.requestId !== "") writer.tag(1, runtime.WireType.LengthDelimited).string(message.requestId);
    /* uint64 bytesStoredOrDelivered = 2; */
    if (message.bytesStoredOrDelivered !== 0) writer.tag(2, runtime.WireType.Varint).uint64(message.bytesStoredOrDelivered);
    /* uint64 timestamp = 3; */
    if (message.timestamp !== 0) writer.tag(3, runtime.WireType.Varint).uint64(message.timestamp);
    /* common.Signature signature = 4; */
    if (message.signature) Signature.internalBinaryWrite(message.signature, writer.tag(4, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message activity_report.ActivityAcknowledgment
 */
const ActivityAcknowledgment = new ActivityAcknowledgment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityFulfillment$Type extends runtime.MessageType {
  constructor() {
    super("activity_report.ActivityFulfillment", [{
      no: 1,
      name: "request",
      kind: "message",
      T: () => ActivityRequest
    }, {
      no: 2,
      name: "ack",
      kind: "message",
      T: () => ActivityAcknowledgment
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* activity_report.ActivityRequest request */1:
          message.request = ActivityRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
          break;
        case /* optional activity_report.ActivityAcknowledgment ack */2:
          message.ack = ActivityAcknowledgment.internalBinaryRead(reader, reader.uint32(), options, message.ack);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* activity_report.ActivityRequest request = 1; */
    if (message.request) ActivityRequest.internalBinaryWrite(message.request, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* optional activity_report.ActivityAcknowledgment ack = 2; */
    if (message.ack) ActivityAcknowledgment.internalBinaryWrite(message.ack, writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message activity_report.ActivityFulfillment
 */
const ActivityFulfillment = new ActivityFulfillment$Type();

/**
 * Creates an activity request.
 */
const createActivityRequest = async (request, {
  signer,
  logger,
  ...options
}) => {
  if (!signer) {
    throw new Error('Activity capturing cannot be enabled. Signer requred!');
  }
  const activityRequest = ActivityRequest.create({
    timestamp: Date.now(),
    requestId: createRequestId(),
    ...request,
    contentType: ActivityRequest_ContentType.PIECE
  });
  activityRequest.signature = await createSignature(signer, ActivityRequest.toBinary(activityRequest), options);
  logger == null || logger.debug({
    activityRequest
  }, 'Activity request');
  return buffer.Buffer.from(ActivityRequest.toBinary(activityRequest)).toString('base64');
};
/**
 * Generates a unique request ID.
 */
const createRequestId = () => uuid.v4();

/**
 * Creates an activity acknowledgment.
 */
const createAck = async (ack, {
  signer,
  logger,
  ...options
}) => {
  if (!signer) {
    throw new Error('Cannot sign acknowledgment. Signer requred!');
  }
  const signedAck = ActivityAcknowledgment.create({
    ...ack,
    signature: await createSignature(signer, ActivityAcknowledgment.toBinary(ack), options)
  });
  logger == null || logger.debug({
    signedAck
  }, 'Activity acknowledgment');
  return signedAck;
};

const CORRELATION_ID_META_KEY = 'correlation-id';
const createRpcMeta = (correlationId, meta) => {
  return {
    ...meta,
    [CORRELATION_ID_META_KEY]: correlationId || uuid.v4()
  };
};

/**
 * Generate a random correlation ID.
 */
const createCorrelationId = () => uuid.v4();

const createSignatureMessage = record => {
  const message = Record.create(record);
  return Record.toBinary(message);
};
/**
 * The `CnsApi` class provides methods to interact with the DDC CNS API.
 *
 * @group Content Name System (CNS)
 * @example
 *
 * ```typescript
 * import { CnsApi, GrpcTransport } from '@cere-ddc-sdk/ddc';
 *
 * const transport = new GrpcTransport(...);
 * const cnsApi = new CnsApi(transport);
 * ```
 */
class CnsApi {
  constructor(transport, options = {}) {
    this.options = void 0;
    this.logger = void 0;
    this.api = void 0;
    this.options = options;
    this.api = new CnsApiClient(transport);
    this.logger = createLogger('CnsApi', options);
  }
  /**
   * Stores a CNS record to DDC.
   *
   * @param request - An object that includes the token, bucket ID, and record to store.
   *
   * @returns The stored record with its signature.
   *
   * @example
   *
   * ```typescript
   * const request: PutRequest = {
   *   token: '...',
   *   bucketId: '...',
   *   record: { ... }
   * };
   *
   * const record = await cnsApi.putRecord(request);
   *
   * console.log(record); //
   * ```
   */
  async putRecord({
    token,
    bucketId,
    record,
    correlationId
  }) {
    this.logger.debug({
      bucketId,
      record,
      token,
      correlationId
    }, 'Storing CNS record');
    const meta = createRpcMeta(correlationId, createRpcMeta$1(token));
    const {
      signer
    } = this.options;
    if (!signer) {
      throw new Error('Unnable to store CNS record. Signer required!');
    }
    const signature = await createSignature(signer, createSignatureMessage(record), {
      token
    });
    meta.request = await createActivityRequest({
      bucketId,
      size: Record.toBinary(record).byteLength,
      requestType: ActivityRequest_RequestType.STORE
    }, {
      logger: this.logger,
      signer
    });
    await this.api.put({
      bucketId,
      record: {
        ...record,
        signature
      }
    }, {
      meta
    });
    this.logger.debug({
      record,
      correlationId
    }, 'CNS record stored');
    return {
      ...record,
      signature: mapSignature(signature)
    };
  }
  /**
   * Retrieves a CNS record from DDC.
   *
   * @param request - An object that includes the token, bucket ID, and record name to retrieve.
   *
   * @returns The retrieved record with its signature.
   *
   * @example
   *
   * ```typescript
   * const request: GetRequest = {
   *   token: '...',
   *   bucketId: '...',
   *   name: 'example'
   * };
   *
   * const record = await cnsApi.getRecord(getRequest);
   *
   * console.log(record);
   * ```
   */
  async getRecord({
    token,
    name,
    bucketId,
    correlationId,
    cacheControl
  }) {
    var _record;
    this.logger.debug({
      name,
      bucketId,
      token,
      correlationId,
      cacheControl
    }, 'Retrieving CNS record');
    let record;
    const meta = createRpcMeta(correlationId, createRpcMeta$1(token));
    if (cacheControl) {
      meta['cache-control'] = cacheControl;
    }
    if (this.options.signer) {
      meta.request = await createActivityRequest({
        bucketId,
        requestType: ActivityRequest_RequestType.GET
      }, {
        token,
        logger: this.logger,
        signer: this.options.signer
      });
    }
    try {
      const {
        response
      } = await this.api.get({
        name,
        bucketId
      }, {
        meta
      });
      record = response.record;
    } catch (error) {
      /**
       * TODO: replace error.message === 'no result' with error.code === GrpcStatus[GrpcStatus.NOT_FOUND] when the status is fixed on stroage node side
       */
      const isNotFound = error instanceof runtimeRpc.RpcError && error.code === GrpcStatus[GrpcStatus.UNKNOWN] && error.message === 'no result'; // error.code === GrpcStatus[GrpcStatus.NOT_FOUND];
      if (!isNotFound) {
        throw error;
      }
    }
    if (!((_record = record) != null && _record.signature)) {
      this.logger.debug({
        name,
        bucketId,
        correlationId
      }, 'CNS record not found');
      return undefined;
    }
    this.logger.debug({
      record,
      correlationId
    }, 'CNS record retrieved');
    return {
      ...record,
      signature: mapSignature(record.signature),
      cid: new Uint8Array(record.cid)
    };
  }
}

/* eslint-disable */
// @generated message type with reflection information, may provide speed optimized methods
class PutRequest$Type extends runtime.MessageType {
  constructor() {
    super("dag.PutRequest", [{
      no: 1,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 2,
      name: "node",
      kind: "message",
      T: () => Node
    }, {
      no: 3,
      name: "cid",
      kind: "scalar",
      opt: true,
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketId = 0n;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/1:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* dag.Node node */2:
          message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
          break;
        case /* optional bytes cid */3:
          message.cid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(1, runtime.WireType.Varint).uint64(message.bucketId);
    /* dag.Node node = 2; */
    if (message.node) Node.internalBinaryWrite(message.node, writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    /* optional bytes cid = 3; */
    if (message.cid !== undefined) writer.tag(3, runtime.WireType.LengthDelimited).bytes(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dag.PutRequest
 */
const PutRequest = new PutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutResponse$Type extends runtime.MessageType {
  constructor() {
    super("dag.PutResponse", [{
      no: 1,
      name: "cid",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = new Uint8Array(0);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes cid */1:
          message.cid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* bytes cid = 1; */
    if (message.cid.length) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dag.PutResponse
 */
const PutResponse = new PutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequest$Type extends runtime.MessageType {
  constructor() {
    super("dag.GetRequest", [{
      no: 1,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 2,
      name: "cid",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 3,
      name: "path",
      kind: "scalar",
      opt: true,
      T: 9 /*ScalarType.STRING*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketId = 0n;
    message.cid = new Uint8Array(0);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/1:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* bytes cid */2:
          message.cid = reader.bytes();
          break;
        case /* optional string path */3:
          message.path = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(1, runtime.WireType.Varint).uint64(message.bucketId);
    /* bytes cid = 2; */
    if (message.cid.length) writer.tag(2, runtime.WireType.LengthDelimited).bytes(message.cid);
    /* optional string path = 3; */
    if (message.path !== undefined) writer.tag(3, runtime.WireType.LengthDelimited).string(message.path);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dag.GetRequest
 */
const GetRequest = new GetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetResponse$Type extends runtime.MessageType {
  constructor() {
    super("dag.GetResponse", [{
      no: 1,
      name: "node",
      kind: "message",
      T: () => Node
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dag.Node node */1:
          message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* dag.Node node = 1; */
    if (message.node) Node.internalBinaryWrite(message.node, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dag.GetResponse
 */
const GetResponse = new GetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Node$Type extends runtime.MessageType {
  constructor() {
    super("dag.Node", [{
      no: 1,
      name: "data",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 2,
      name: "links",
      kind: "message",
      repeat: 1 /*RepeatType.PACKED*/,
      T: () => Link$1
    }, {
      no: 3,
      name: "tags",
      kind: "message",
      repeat: 1 /*RepeatType.PACKED*/,
      T: () => Tag$1
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    message.links = [];
    message.tags = [];
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */1:
          message.data = reader.bytes();
          break;
        case /* repeated dag.Link links */2:
          message.links.push(Link$1.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated dag.Tag tags */3:
          message.tags.push(Tag$1.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* bytes data = 1; */
    if (message.data.length) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.data);
    /* repeated dag.Link links = 2; */
    for (let i = 0; i < message.links.length; i++) Link$1.internalBinaryWrite(message.links[i], writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    /* repeated dag.Tag tags = 3; */
    for (let i = 0; i < message.tags.length; i++) Tag$1.internalBinaryWrite(message.tags[i], writer.tag(3, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dag.Node
 */
const Node = new Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Link$Type extends runtime.MessageType {
  constructor() {
    super("dag.Link", [{
      no: 1,
      name: "cid",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9 /*ScalarType.STRING*/
    }, {
      no: 3,
      name: "size",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = new Uint8Array(0);
    message.name = "";
    message.size = 0;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes cid */1:
          message.cid = reader.bytes();
          break;
        case /* string name */2:
          message.name = reader.string();
          break;
        case /* uint64 size */3:
          message.size = reader.uint64().toNumber();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* bytes cid = 1; */
    if (message.cid.length) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.cid);
    /* string name = 2; */
    if (message.name !== "") writer.tag(2, runtime.WireType.LengthDelimited).string(message.name);
    /* uint64 size = 3; */
    if (message.size !== 0) writer.tag(3, runtime.WireType.Varint).uint64(message.size);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dag.Link
 */
const Link$1 = new Link$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tag$Type extends runtime.MessageType {
  constructor() {
    super("dag.Tag", [{
      no: 1,
      name: "key",
      kind: "scalar",
      T: 9 /*ScalarType.STRING*/
    }, {
      no: 2,
      name: "value",
      kind: "scalar",
      T: 9 /*ScalarType.STRING*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.key = "";
    message.value = "";
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */1:
          message.key = reader.string();
          break;
        case /* string value */2:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* string key = 1; */
    if (message.key !== "") writer.tag(1, runtime.WireType.LengthDelimited).string(message.key);
    /* string value = 2; */
    if (message.value !== "") writer.tag(2, runtime.WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dag.Tag
 */
const Tag$1 = new Tag$Type();
/**
 * @generated ServiceType for protobuf service dag.DagApi
 */
const DagApi$1 = new runtimeRpc.ServiceType("dag.DagApi", [{
  name: "Put",
  options: {
    "google.api.http": {
      post: "/v1/dag/{bucketId}",
      body: "*"
    }
  },
  I: PutRequest,
  O: PutResponse
}, {
  name: "Get",
  options: {
    "google.api.http": {
      get: "/v1/dag/{bucketId}/{cid}/{path}",
      additionalBindings: [{
        get: "/v1/dag/{bucketId}/{cid}"
      }]
    }
  },
  I: GetRequest,
  O: GetResponse
}]);

/**
 * @generated from protobuf service dag.DagApi
 */
class DagApiClient {
  constructor(_transport) {
    this._transport = void 0;
    this.typeName = DagApi$1.typeName;
    this.methods = DagApi$1.methods;
    this.options = DagApi$1.options;
    this._transport = _transport;
  }
  /**
   * @generated from protobuf rpc: Put(dag.PutRequest) returns (dag.PutResponse);
   */
  put(input, options) {
    const method = this.methods[0],
      opt = this._transport.mergeOptions(options);
    return runtimeRpc.stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: Get(dag.GetRequest) returns (dag.GetResponse);
   */
  get(input, options) {
    const method = this.methods[1],
      opt = this._transport.mergeOptions(options);
    return runtimeRpc.stackIntercept("unary", this._transport, method, opt, input);
  }
}

class CidValidator {
  constructor(cid, {
    logger,
    enable = true
  } = {}) {
    this.hasherPromise = void 0;
    this.cid = void 0;
    this.logger = void 0;
    this.enable = void 0;
    this.cid = new Cid(cid);
    this.logger = logger;
    this.enable = enable;
  }
  async getHasher() {
    this.hasherPromise || (this.hasherPromise = hashWasm.createBLAKE3());
    return this.hasherPromise;
  }
  async update(chunk) {
    if (!this.enable) {
      return this;
    }
    const hasher = await this.getHasher();
    hasher.update(chunk);
    return this;
  }
  async validate() {
    var _this$logger;
    if (!this.enable) {
      return;
    }
    const hasher = await this.getHasher();
    const receivedHash = hasher.digest('hex');
    const expectedHash = Buffer.from(this.cid.contentHash).toString('hex');
    (_this$logger = this.logger) == null || _this$logger.debug({
      expectedHash,
      receivedHash
    }, 'Validating content hash');
    if (receivedHash !== expectedHash) {
      throw new Error('Received content is not valid - hash does not match');
    }
  }
}

class FileValidator extends CidValidator {
  constructor(cid, {
    range,
    ...options
  } = {}) {
    super(cid, options);
    this.range = void 0;
    this.isProved = false;
    this.range = range;
  }
  /**
   * TODO: Implement proof verification
   */
  async prove({
    proof
  }) {
    this.isProved = proof.length > 0;
  }
  async validate() {
    if (this.isProved || this.range) {
      return;
    }
    await super.validate();
  }
}

class DagNodeValidator extends CidValidator {}

/**
 * The `DagApi` class provides methods to interact with the DDC DAG API.
 *
 * @group Directed Acyclic Graph (DAG)
 * @example
 *
 * ```typescript
 * import { DagApi, GrpcTransport } from '@cere-ddc-sdk/ddc';
 *
 * const transport = new GrpcTransport(...);
 * const dagApi = new DagApi(transport);
 * ```
 */
class DagApi {
  constructor(transport, options = {}) {
    var _options$authenticate;
    this.logger = void 0;
    this.api = void 0;
    this.options = void 0;
    this.api = new DagApiClient(transport);
    this.logger = createLogger('DagApi', options);
    this.options = {
      ...options,
      authenticate: (_options$authenticate = options.authenticate) != null ? _options$authenticate : false
    };
  }
  /**
   * Stores a node in DDC DAG.
   *
   * @param request - An object that includes the access token and the node to store.
   *
   * @returns The CID of the stored node as a `Uint8Array`.
   *
   * @example
   *
   * ```typescript
   * const request: PutRequest = { token: '...', node: { ... } };
   * const cid = await dagApi.putNode(request);
   *
   * console.log(cid);
   * ```
   */
  async putNode({
    token,
    bucketId,
    node,
    cid,
    correlationId
  }) {
    const meta = createRpcMeta(correlationId, createRpcMeta$1(token));
    this.logger.debug({
      token,
      correlationId,
      bucketId,
      node,
      cid
    }, 'Storing DAG Node');
    if (this.options.signer && node) {
      meta.request = await createActivityRequest({
        id: cid,
        bucketId,
        size: Node.toBinary(node).byteLength,
        requestType: ActivityRequest_RequestType.STORE
      }, {
        token,
        logger: this.logger,
        signer: this.options.signer
      });
    }
    const {
      response
    } = await this.api.put({
      bucketId,
      node,
      cid
    }, {
      meta
    });
    this.logger.debug({
      cid,
      correlationId
    }, 'DAG Node stored');
    return new Uint8Array(response.cid);
  }
  /**
   * Retrieves a DAG node from DDC.
   *
   * @group Low level API
   * @param request - An object that includes the access token and the CID of the node to retrieve.
   *
   * @returns The retrieved node as a `Node` object, or `undefined` if the node does not exist.
   *
   * @example
   *
   * ```typescript
   * const request: GetRequest = { token: '...', cid: '...' };
   * const node = await dagApi.getNode(request);
   *
   * console.log(node);
   * ```
   */
  async getNode({
    token,
    correlationId,
    ...request
  }) {
    this.logger.debug({
      ...request,
      token,
      correlationId
    }, 'Retrieving DAG Node');
    /**
     * In case a sub-node requested using root CID + path - we don't have the target node CID, so we can't authenticate it.
     */
    const authenticate = this.options.authenticate && !request.path;
    const meta = createRpcMeta(correlationId, createRpcMeta$1(token));
    const validator = new DagNodeValidator(request.cid, {
      enable: authenticate,
      logger: this.logger
    });
    if (this.options.signer) {
      meta.request = await createActivityRequest({
        id: request.cid,
        bucketId: request.bucketId,
        requestType: ActivityRequest_RequestType.GET
      }, {
        token,
        logger: this.logger,
        signer: this.options.signer
      });
    }
    const {
      response
    } = await this.api.get(request, {
      meta
    });
    if (response.node && authenticate) {
      await validator.update(Node.toBinary(response.node));
    }
    await validator.validate();
    this.logger.debug({
      node: response.node,
      correlationId
    }, 'DAG Node retrieved');
    return response.node && {
      ...response.node,
      data: new Uint8Array(response.node.data)
    };
  }
}

const withChunkSize = chunkSize => {
  let buffer$1;
  const slice = Uint8Array.prototype.slice;
  return new web.TransformStream({
    transform(data, controller) {
      buffer$1 = buffer$1 ? buffer.Buffer.concat([buffer$1, data]) : buffer.Buffer.from(data);
      while (buffer$1.byteLength >= chunkSize) {
        controller.enqueue(slice.call(buffer$1, 0, chunkSize));
        buffer$1 = buffer.Buffer.from(slice.call(buffer$1, chunkSize));
      }
    },
    flush(controller) {
      var _buffer;
      if ((_buffer = buffer$1) != null && _buffer.byteLength) {
        controller.enqueue(slice.call(buffer$1));
      }
      buffer$1 = undefined;
    }
  });
};
/**
 * Not all browsers support async iterators on ReadableStream, so we need to convert it manualy in some cases
 */
const isInputStream = input => {
  return 'getReader' in input;
};
async function* toIterable(input) {
  if (!isInputStream(input)) {
    return yield* input;
  }
  const reader = input.getReader();
  while (true) {
    const {
      done,
      value
    } = await reader.read();
    if (done) {
      break;
    }
    yield value;
  }
}
const getContentSize = (content, defaultSize) => {
  return 'byteLength' in content ? content.byteLength : defaultSize;
};
const ContentStreamSymbol = Symbol('ContentStream');
const isContentStream = input => {
  return !!input && typeof input === 'object' && ContentStreamSymbol in input;
};
const createContentStream = (input, chunkSize = CONTENT_CHUNK_SIZE) => {
  const asyncIterator = toIterable(input instanceof Uint8Array ? [input] : input);
  const stream = new web.ReadableStream({
    async pull(controller) {
      const {
        done,
        value
      } = await asyncIterator.next();
      if (value) {
        controller.enqueue(value);
      }
      if (done) {
        controller.close();
      }
    }
  });
  return Object.assign(chunkSize ? stream.pipeThrough(withChunkSize(chunkSize)) : stream, {
    [ContentStreamSymbol]: true
  });
};

var consumers = {
  __proto__: null,
  json: consumers$1.json,
  arrayBuffer: consumers$1.arrayBuffer,
  text: consumers$1.text
};

/* eslint-disable */
// @generated message type with reflection information, may provide speed optimized methods
class PutRawPieceRequest$Type extends runtime.MessageType {
  constructor() {
    super("file.PutRawPieceRequest", [{
      no: 1,
      name: "metadata",
      kind: "message",
      oneof: "body",
      T: () => PutRawPieceRequest_Metadata
    }, {
      no: 2,
      name: "content",
      kind: "message",
      oneof: "body",
      T: () => PutRawPieceRequest_Content
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.body = {
      oneofKind: undefined
    };
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* file.PutRawPieceRequest.Metadata metadata */1:
          message.body = {
            oneofKind: "metadata",
            metadata: PutRawPieceRequest_Metadata.internalBinaryRead(reader, reader.uint32(), options, message.body.metadata)
          };
          break;
        case /* file.PutRawPieceRequest.Content content */2:
          message.body = {
            oneofKind: "content",
            content: PutRawPieceRequest_Content.internalBinaryRead(reader, reader.uint32(), options, message.body.content)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* file.PutRawPieceRequest.Metadata metadata = 1; */
    if (message.body.oneofKind === "metadata") PutRawPieceRequest_Metadata.internalBinaryWrite(message.body.metadata, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* file.PutRawPieceRequest.Content content = 2; */
    if (message.body.oneofKind === "content") PutRawPieceRequest_Content.internalBinaryWrite(message.body.content, writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.PutRawPieceRequest
 */
const PutRawPieceRequest = new PutRawPieceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutRawPieceRequest_Metadata$Type extends runtime.MessageType {
  constructor() {
    super("file.PutRawPieceRequest.Metadata", [{
      no: 1,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 2,
      name: "cid",
      kind: "scalar",
      opt: true,
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 3,
      name: "offset",
      kind: "scalar",
      opt: true,
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 4,
      name: "isMultipart",
      kind: "scalar",
      T: 8 /*ScalarType.BOOL*/
    }, {
      no: 5,
      name: "size",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketId = 0n;
    message.isMultipart = false;
    message.size = 0;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/1:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* optional bytes cid */2:
          message.cid = reader.bytes();
          break;
        case /* optional uint64 offset */3:
          message.offset = reader.uint64().toNumber();
          break;
        case /* bool isMultipart */4:
          message.isMultipart = reader.bool();
          break;
        case /* uint64 size */5:
          message.size = reader.uint64().toNumber();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(1, runtime.WireType.Varint).uint64(message.bucketId);
    /* optional bytes cid = 2; */
    if (message.cid !== undefined) writer.tag(2, runtime.WireType.LengthDelimited).bytes(message.cid);
    /* optional uint64 offset = 3; */
    if (message.offset !== undefined) writer.tag(3, runtime.WireType.Varint).uint64(message.offset);
    /* bool isMultipart = 4; */
    if (message.isMultipart !== false) writer.tag(4, runtime.WireType.Varint).bool(message.isMultipart);
    /* uint64 size = 5; */
    if (message.size !== 0) writer.tag(5, runtime.WireType.Varint).uint64(message.size);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.PutRawPieceRequest.Metadata
 */
const PutRawPieceRequest_Metadata = new PutRawPieceRequest_Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutRawPieceRequest_Content$Type extends runtime.MessageType {
  constructor() {
    super("file.PutRawPieceRequest.Content", [{
      no: 1,
      name: "data",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.data = new Uint8Array(0);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */1:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* bytes data = 1; */
    if (message.data.length) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.PutRawPieceRequest.Content
 */
const PutRawPieceRequest_Content = new PutRawPieceRequest_Content$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutRawPieceResponse$Type extends runtime.MessageType {
  constructor() {
    super("file.PutRawPieceResponse", [{
      no: 1,
      name: "cid",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = new Uint8Array(0);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes cid */1:
          message.cid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* bytes cid = 1; */
    if (message.cid.length) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.PutRawPieceResponse
 */
const PutRawPieceResponse = new PutRawPieceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutMultiPartPieceRequest$Type extends runtime.MessageType {
  constructor() {
    super("file.PutMultiPartPieceRequest", [{
      no: 1,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 2,
      name: "cid",
      kind: "scalar",
      opt: true,
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 3,
      name: "totalSize",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 4,
      name: "partSize",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 5,
      name: "partHashes",
      kind: "scalar",
      repeat: 2 /*RepeatType.UNPACKED*/,
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bucketId = 0n;
    message.totalSize = 0;
    message.partSize = 0;
    message.partHashes = [];
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 bucketId = 1 [jstype = JS_NORMAL];*/1:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* optional bytes cid */2:
          message.cid = reader.bytes();
          break;
        case /* uint64 totalSize */3:
          message.totalSize = reader.uint64().toNumber();
          break;
        case /* uint64 partSize */4:
          message.partSize = reader.uint64().toNumber();
          break;
        case /* repeated bytes partHashes */5:
          message.partHashes.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* uint64 bucketId = 1 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(1, runtime.WireType.Varint).uint64(message.bucketId);
    /* optional bytes cid = 2; */
    if (message.cid !== undefined) writer.tag(2, runtime.WireType.LengthDelimited).bytes(message.cid);
    /* uint64 totalSize = 3; */
    if (message.totalSize !== 0) writer.tag(3, runtime.WireType.Varint).uint64(message.totalSize);
    /* uint64 partSize = 4; */
    if (message.partSize !== 0) writer.tag(4, runtime.WireType.Varint).uint64(message.partSize);
    /* repeated bytes partHashes = 5; */
    for (let i = 0; i < message.partHashes.length; i++) writer.tag(5, runtime.WireType.LengthDelimited).bytes(message.partHashes[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.PutMultiPartPieceRequest
 */
const PutMultiPartPieceRequest = new PutMultiPartPieceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutMultiPartPieceResponse$Type extends runtime.MessageType {
  constructor() {
    super("file.PutMultiPartPieceResponse", [{
      no: 1,
      name: "cid",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = new Uint8Array(0);
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes cid */1:
          message.cid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* bytes cid = 1; */
    if (message.cid.length) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.cid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.PutMultiPartPieceResponse
 */
const PutMultiPartPieceResponse = new PutMultiPartPieceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFileRequest$Type extends runtime.MessageType {
  constructor() {
    super("file.GetFileRequest", [{
      no: 1,
      name: "request",
      kind: "message",
      oneof: "body",
      T: () => GetFileRequest_Request
    }, {
      no: 2,
      name: "ack",
      kind: "message",
      oneof: "body",
      T: () => ActivityAcknowledgment
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.body = {
      oneofKind: undefined
    };
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* file.GetFileRequest.Request request */1:
          message.body = {
            oneofKind: "request",
            request: GetFileRequest_Request.internalBinaryRead(reader, reader.uint32(), options, message.body.request)
          };
          break;
        case /* activity_report.ActivityAcknowledgment ack */2:
          message.body = {
            oneofKind: "ack",
            ack: ActivityAcknowledgment.internalBinaryRead(reader, reader.uint32(), options, message.body.ack)
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* file.GetFileRequest.Request request = 1; */
    if (message.body.oneofKind === "request") GetFileRequest_Request.internalBinaryWrite(message.body.request, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* activity_report.ActivityAcknowledgment ack = 2; */
    if (message.body.oneofKind === "ack") ActivityAcknowledgment.internalBinaryWrite(message.body.ack, writer.tag(2, runtime.WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.GetFileRequest
 */
const GetFileRequest = new GetFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFileRequest_Request$Type extends runtime.MessageType {
  constructor() {
    super("file.GetFileRequest.Request", [{
      no: 1,
      name: "cid",
      kind: "scalar",
      T: 12 /*ScalarType.BYTES*/
    }, {
      no: 2,
      name: "bucketId",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 0 /*LongType.BIGINT*/
    }, {
      no: 3,
      name: "range",
      kind: "message",
      T: () => GetFileRequest_Request_Range
    }, {
      no: 4,
      name: "authenticate",
      kind: "scalar",
      T: 8 /*ScalarType.BOOL*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.cid = new Uint8Array(0);
    message.bucketId = 0n;
    message.authenticate = false;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes cid */1:
          message.cid = reader.bytes();
          break;
        case /* uint64 bucketId = 2 [jstype = JS_NORMAL];*/2:
          message.bucketId = reader.uint64().toBigInt();
          break;
        case /* optional file.GetFileRequest.Request.Range range */3:
          message.range = GetFileRequest_Request_Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
          break;
        case /* bool authenticate */4:
          message.authenticate = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* bytes cid = 1; */
    if (message.cid.length) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.cid);
    /* uint64 bucketId = 2 [jstype = JS_NORMAL]; */
    if (message.bucketId !== 0n) writer.tag(2, runtime.WireType.Varint).uint64(message.bucketId);
    /* optional file.GetFileRequest.Request.Range range = 3; */
    if (message.range) GetFileRequest_Request_Range.internalBinaryWrite(message.range, writer.tag(3, runtime.WireType.LengthDelimited).fork(), options).join();
    /* bool authenticate = 4; */
    if (message.authenticate !== false) writer.tag(4, runtime.WireType.Varint).bool(message.authenticate);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.GetFileRequest.Request
 */
const GetFileRequest_Request = new GetFileRequest_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFileRequest_Request_Range$Type extends runtime.MessageType {
  constructor() {
    super("file.GetFileRequest.Request.Range", [{
      no: 1,
      name: "start",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }, {
      no: 2,
      name: "end",
      kind: "scalar",
      T: 4 /*ScalarType.UINT64*/,
      L: 2 /*LongType.NUMBER*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.start = 0;
    message.end = 0;
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 start */1:
          message.start = reader.uint64().toNumber();
          break;
        case /* uint64 end */2:
          message.end = reader.uint64().toNumber();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* uint64 start = 1; */
    if (message.start !== 0) writer.tag(1, runtime.WireType.Varint).uint64(message.start);
    /* uint64 end = 2; */
    if (message.end !== 0) writer.tag(2, runtime.WireType.Varint).uint64(message.end);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.GetFileRequest.Request.Range
 */
const GetFileRequest_Request_Range = new GetFileRequest_Request_Range$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFileResponse$Type extends runtime.MessageType {
  constructor() {
    super("file.GetFileResponse", [{
      no: 1,
      name: "proof",
      kind: "message",
      oneof: "body",
      T: () => GetFileResponse_Proof
    }, {
      no: 2,
      name: "data",
      kind: "scalar",
      oneof: "body",
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.body = {
      oneofKind: undefined
    };
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* file.GetFileResponse.Proof proof */1:
          message.body = {
            oneofKind: "proof",
            proof: GetFileResponse_Proof.internalBinaryRead(reader, reader.uint32(), options, message.body.proof)
          };
          break;
        case /* bytes data */2:
          message.body = {
            oneofKind: "data",
            data: reader.bytes()
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* file.GetFileResponse.Proof proof = 1; */
    if (message.body.oneofKind === "proof") GetFileResponse_Proof.internalBinaryWrite(message.body.proof, writer.tag(1, runtime.WireType.LengthDelimited).fork(), options).join();
    /* bytes data = 2; */
    if (message.body.oneofKind === "data") writer.tag(2, runtime.WireType.LengthDelimited).bytes(message.body.data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.GetFileResponse
 */
const GetFileResponse = new GetFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFileResponse_Proof$Type extends runtime.MessageType {
  constructor() {
    super("file.GetFileResponse.Proof", [{
      no: 1,
      name: "proof",
      kind: "scalar",
      repeat: 2 /*RepeatType.UNPACKED*/,
      T: 12 /*ScalarType.BYTES*/
    }]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.proof = [];
    if (value !== undefined) runtime.reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target != null ? target : this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes proof */1:
          message.proof.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? runtime.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    /* repeated bytes proof = 1; */
    for (let i = 0; i < message.proof.length; i++) writer.tag(1, runtime.WireType.LengthDelimited).bytes(message.proof[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? runtime.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message file.GetFileResponse.Proof
 */
const GetFileResponse_Proof = new GetFileResponse_Proof$Type();
/**
 * @generated ServiceType for protobuf service file.FileApi
 */
const FileApi$1 = new runtimeRpc.ServiceType("file.FileApi", [{
  name: "putRawPiece",
  clientStreaming: true,
  options: {},
  I: PutRawPieceRequest,
  O: PutRawPieceResponse
}, {
  name: "putMultipartPiece",
  options: {},
  I: PutMultiPartPieceRequest,
  O: PutMultiPartPieceResponse
}, {
  name: "getFile",
  serverStreaming: true,
  clientStreaming: true,
  options: {},
  I: GetFileRequest,
  O: GetFileResponse
}]);

/**
 * @generated from protobuf service file.FileApi
 */
class FileApiClient {
  constructor(_transport) {
    this._transport = void 0;
    this.typeName = FileApi$1.typeName;
    this.methods = FileApi$1.methods;
    this.options = FileApi$1.options;
    this._transport = _transport;
  }
  /**
   * @generated from protobuf rpc: putRawPiece(stream file.PutRawPieceRequest) returns (file.PutRawPieceResponse);
   */
  putRawPiece(options) {
    const method = this.methods[0],
      opt = this._transport.mergeOptions(options);
    return runtimeRpc.stackIntercept("clientStreaming", this._transport, method, opt);
  }
  /**
   * @generated from protobuf rpc: putMultipartPiece(file.PutMultiPartPieceRequest) returns (file.PutMultiPartPieceResponse);
   */
  putMultipartPiece(input, options) {
    const method = this.methods[1],
      opt = this._transport.mergeOptions(options);
    return runtimeRpc.stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: getFile(stream file.GetFileRequest) returns (stream file.GetFileResponse);
   */
  getFile(options) {
    const method = this.methods[2],
      opt = this._transport.mergeOptions(options);
    return runtimeRpc.stackIntercept("duplex", this._transport, method, opt);
  }
}

const ceilToPowerOf2 = n => Math.pow(2, Math.ceil(Math.log2(n)));
/**
 * The `FileApi` class provides methods to interact with the DDC File API.
 *
 * @group Files
 * @example
 *
 * ```typescript
 * import { FileApi, GrpcTransport } from '@cere-ddc-sdk/ddc';
 *
 * const transport = new GrpcTransport(...);
 * const fileApi = new FileApi(transport);
 * ```
 */
class FileApi {
  constructor(transport, options = {}) {
    var _options$enableAcks, _options$authenticate;
    this.logger = void 0;
    this.api = void 0;
    this.options = void 0;
    this.api = new FileApiClient(transport);
    this.logger = createLogger('FileApi', options);
    this.options = {
      ...options,
      enableAcks: (_options$enableAcks = options.enableAcks) != null ? _options$enableAcks : !!options.signer,
      // ACKs are enabled by default if signer is provided
      authenticate: (_options$authenticate = options.authenticate) != null ? _options$authenticate : false
    };
  }
  /**
   * Stores a multipart piece in DDC.
   *
   * @param request - An object that includes the access token, the part size, and the piece to store.
   *
   * @returns The CID of the stored piece as a `Uint8Array`.
   *
   * @example
   *
   * ```typescript
   * const request: PutMultiPartPieceRequest = {
   *   token: '...',
   *   partSize: 1024,
   *   piece: { ... }
   * };
   *
   * const cid = await fileApi.putMultipartPiece(request);
   *
   * console.log(cid);
   * ```
   */
  async putMultipartPiece({
    token,
    correlationId,
    ...request
  }) {
    const {
      signer
    } = this.options;
    const meta = createRpcMeta(correlationId, createRpcMeta$1(token));
    const partSize = ceilToPowerOf2(request.partSize);
    this.logger.debug({
      ...request,
      partSize,
      token,
      correlationId
    }, 'Storing multipart piece');
    if (signer) {
      meta.request = await createActivityRequest({
        bucketId: request.bucketId,
        size: PutMultiPartPieceRequest.toBinary(request).byteLength,
        requestType: ActivityRequest_RequestType.STORE
      }, {
        token,
        signer,
        logger: this.logger
      });
    }
    const {
      response
    } = await this.api.putMultipartPiece({
      ...request,
      partSize
    }, {
      meta
    });
    this.logger.debug({
      response,
      correlationId
    }, 'Multipart piece stored');
    return new Uint8Array(response.cid);
  }
  /**
   * Stores a raw piece in DDC.
   *
   * @param metadata - An object that includes the access token and the metadata for the raw piece.
   * @param content - The content of the raw piece as a `Content` object.
   *
   * @returns The CID of the stored piece as a `Uint8Array`.
   *
   * @throws Will throw an error if the size of the raw piece cannot be determined, or if it exceeds the maximum size.
   *
   * @example
   *
   * ```typescript
   * const content: Content = ...;
   * const metadata: PutRawPieceMetadata = {
   *   token: '...',
   *   bucketId: '...',
   *   ...
   * };
   *
   * const cid = await fileApi.putRawPiece(metadata, content);
   *
   * console.log(cid);
   * ```
   */
  async putRawPiece({
    token,
    correlationId,
    ...metadata
  }, content) {
    const meta = createRpcMeta(correlationId, createRpcMeta$1(token));
    const size = getContentSize(content, metadata.size);
    const {
      signer
    } = this.options;
    this.logger.debug({
      metadata,
      token,
      correlationId
    }, 'Storing raw piece of size %d', size);
    if (!size) {
      throw new Error('Cannot determine the raw piece size');
    }
    if (size > MAX_PIECE_SIZE) {
      throw new Error(`Raw piece size should not be greather then ${MAX_PIECE_SIZE / MB} MB`);
    }
    if (signer) {
      meta.request = await createActivityRequest({
        size,
        bucketId: metadata.bucketId,
        requestType: ActivityRequest_RequestType.STORE
      }, {
        token,
        signer,
        logger: this.logger
      });
    }
    const call = this.api.putRawPiece({
      meta
    });
    /**
     * Send none-blocking request message.
     */
    call.requests.send({
      body: {
        oneofKind: 'metadata',
        metadata: {
          ...metadata,
          size
        }
      }
    });
    /**
     * Wait for responce headers before start streaming piece content.
     */
    const headers = await call.headers;
    this.logger.debug({
      headers,
      correlationId
    }, 'Server responded with headers');
    let bytesSent = 0;
    const contentStream = isContentStream(content) ? content : createContentStream(content);
    const reader = contentStream.getReader();
    while (bytesSent < MAX_PIECE_SIZE) {
      const {
        done,
        value
      } = await reader.read();
      if (done || !value) {
        break;
      }
      await Promise.race([call.status, call.requests.send({
        body: {
          oneofKind: 'content',
          content: {
            data: value
          }
        }
      })]);
      bytesSent += value.byteLength;
    }
    reader.releaseLock();
    await call.requests.complete();
    const {
      cid
    } = await call.response;
    this.logger.debug({
      cid,
      correlationId
    }, 'Raw piece stored');
    return new Uint8Array(cid);
  }
  /**
   * Retrieves a file from DDC.
   *
   * @param request - An object that includes the access token, the CID of the file to retrieve, and an optional range.
   *
   * @returns A stream of the file's content as a `ContentStream`.
   *
   * @example
   *
   * ```typescript
   * const request: GetFileRequest = { token: '...', cid: '...' };
   *
   * const contentStream = await fileApi.getFile(request);
   *
   * for await (const chunk of contentStream) {
   *   console.log(chunk);
   * }
   * ```
   */
  async getFile({
    token,
    correlationId,
    ...request
  }) {
    const {
      enableAcks,
      signer,
      authenticate = false
    } = this.options;
    this.logger.debug({
      request,
      token,
      correlationId
    }, 'Started reading data');
    const requestId = createRequestId();
    const meta = createRpcMeta(correlationId, createRpcMeta$1(token));
    const validator = new FileValidator(request.cid, {
      logger: this.logger,
      enable: authenticate,
      range: request.range
    });
    if (signer) {
      var _request$range;
      meta.request = await createActivityRequest({
        requestId,
        id: request.cid,
        bucketId: request.bucketId,
        offset: (_request$range = request.range) == null ? void 0 : _request$range.start,
        size: request.range && request.range.end - request.range.start + 1,
        requestType: ActivityRequest_RequestType.GET
      }, {
        token,
        signer,
        logger: this.logger
      });
    }
    const call = this.api.getFile({
      meta
    });
    /**
     * Send none-blocking request message.
     */
    call.requests.send({
      body: {
        oneofKind: 'request',
        request: {
          ...request,
          authenticate
        }
      }
    });
    /**
     * Wait for responce headers to be received.
     */
    const headers = await call.headers;
    this.logger.debug({
      headers,
      correlationId
    }, 'Server responded with headers');
    /**
     * Create data stream from responce messages.
     */
    async function* toDataStream() {
      let bytesStoredOrDelivered = 0;
      try {
        for await (const {
          body
        } of call.responses) {
          if (body.oneofKind === 'data') {
            yield body.data;
            bytesStoredOrDelivered += body.data.byteLength;
            if (enableAcks) {
              call.requests.send({
                body: {
                  oneofKind: 'ack',
                  ack: await createAck({
                    requestId,
                    bytesStoredOrDelivered,
                    timestamp: Date.now()
                  }, {
                    token,
                    signer,
                    logger: this.logger
                  })
                }
              }).then(() => {
                this.logger.info('Acknowledgment sent with request ID: %s (%d bytes)', requestId, bytesStoredOrDelivered);
              }).catch(() => {
                this.logger.warn('Failed to send acknowledgment with request ID: %s (%d bytes)', requestId, bytesStoredOrDelivered);
              });
            }
            await validator.update(body.data);
          }
          if (body.oneofKind === 'proof') {
            await validator.prove(body.proof);
          }
        }
        await call.requests.complete();
        await validator.validate();
      } catch (error) {
        this.logger.error(error, 'An error occurred while reading file stream');
        throw error;
      }
    }
    /**
     * Create content stream from Iterator using original chunk size to avoid unnecessary buffering.
     */
    return createContentStream(toDataStream.call(this), null);
  }
}

class TimeoutAbortController extends AbortController {
  constructor(timeout) {
    super();
    this.timeout = void 0;
    this.timeoutHandle = void 0;
    this.stop = () => {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
      }
    };
    this.start = () => {
      this.stop();
      this.timeoutHandle = setTimeout(() => this.abort(new runtimeRpc.RpcError('Request timed out', GrpcStatus[GrpcStatus.CANCELLED])), this.timeout);
      return this;
    };
    this.timeout = timeout;
    this.timeout = timeout;
  }
}
const composeSignal = (sigA, sigB) => {
  if (!sigB) {
    return sigA;
  }
  const controller = new AbortController();
  const abortHandler = () => {
    if (!controller.signal.aborted) {
      controller.abort();
    }
  };
  sigA.addEventListener('abort', abortHandler);
  sigB.addEventListener('abort', abortHandler);
  return controller.signal;
};
/**
 * An interceptor that adds a timeout to all RPC calls.
 *
 * TODO: This interceptor adds timeout to `headers` promise only for now, since the SDK cannot retry ongoing requests for now.
 */
class TimeoutInterceptor {
  constructor(timeout) {
    this.timeout = void 0;
    this.timeout = timeout;
  }
  start(options) {
    const controller = new TimeoutAbortController(this.timeout);
    return [controller.start(), composeSignal(controller.signal, options.abort)];
  }
  interceptDuplex(next, method, options) {
    const [controller, abort] = this.start(options);
    const call = next(method, {
      ...options,
      abort
    });
    call.headers.then(controller.stop, controller.stop);
    return call;
  }
  interceptServerStreaming(next, method, input, options) {
    const [controller, abort] = this.start(options);
    const call = next(method, input, {
      ...options,
      abort
    });
    call.headers.then(controller.stop, controller.stop);
    return call;
  }
  interceptClientStreaming(next, method, options) {
    const [controller, abort] = this.start(options);
    const call = next(method, {
      ...options,
      abort
    });
    call.headers.then(controller.stop, controller.stop);
    return call;
  }
  interceptUnary(next, method, input, {
    timeout,
    ...options
  }) {
    return next(method, input, {
      ...options,
      timeout: timeout != null ? timeout : this.timeout
    });
  }
}

const URL_PROTOCOL = 'grpc://';
const getHost = href => {
  return href.startsWith(URL_PROTOCOL) ? href.slice(URL_PROTOCOL.length) : href;
};
/**
 * The `GrpcTransport` class represents a gRPC transport layer for RPC communication.
 *
 * @group RPC Transport
 */
class GrpcTransport extends grpcTransport.GrpcTransport {
  constructor({
    grpcUrl,
    interceptors = [],
    timeout
  }) {
    super({
      interceptors: timeout ? [new TimeoutInterceptor(timeout), ...interceptors] : interceptors,
      host: getHost(grpcUrl),
      channelCredentials: grpcJs.ChannelCredentials.createInsecure()
    });
  }
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var grpcWebClient = createCommonjsModule(function (module, exports) {
!function(e,t){for(var r in t)e[r]=t[r];t.__esModule&&Object.defineProperty(e,"__esModule",{value:!0});}(exports,function(){var e={418:function(e,t){!function(e,t){for(var r in t)e[r]=t[r];}(t,function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.i=function(e){return e},r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n});},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=1)}([function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),o=function(){function e(e,t){void 0===e&&(e={}),void 0===t&&(t={splitValues:!1});var r,o=this;this.headersMap={},e&&("undefined"!=typeof Headers&&e instanceof Headers?n.getHeaderKeys(e).forEach((function(r){n.getHeaderValues(e,r).forEach((function(e){t.splitValues?o.append(r,n.splitHeaderValue(e)):o.append(r,e);}));})):"object"==typeof(r=e)&&"object"==typeof r.headersMap&&"function"==typeof r.forEach?e.forEach((function(e,t){o.append(e,t);})):"undefined"!=typeof Map&&e instanceof Map?e.forEach((function(e,t){o.append(t,e);})):"string"==typeof e?this.appendFromString(e):"object"==typeof e&&Object.getOwnPropertyNames(e).forEach((function(t){var r=e[t];Array.isArray(r)?r.forEach((function(e){o.append(t,e);})):o.append(t,r);})));}return e.prototype.appendFromString=function(e){for(var t=e.split("\r\n"),r=0;r<t.length;r++){var n=t[r],o=n.indexOf(":");if(o>0){var s=n.substring(0,o).trim(),i=n.substring(o+1).trim();this.append(s,i);}}},e.prototype.delete=function(e,t){var r=n.normalizeName(e);if(void 0===t)delete this.headersMap[r];else {var o=this.headersMap[r];if(o){var s=o.indexOf(t);s>=0&&o.splice(s,1),0===o.length&&delete this.headersMap[r];}}},e.prototype.append=function(e,t){var r=this,o=n.normalizeName(e);Array.isArray(this.headersMap[o])||(this.headersMap[o]=[]),Array.isArray(t)?t.forEach((function(e){r.headersMap[o].push(n.normalizeValue(e));})):this.headersMap[o].push(n.normalizeValue(t));},e.prototype.set=function(e,t){var r=n.normalizeName(e);if(Array.isArray(t)){var o=[];t.forEach((function(e){o.push(n.normalizeValue(e));})),this.headersMap[r]=o;}else this.headersMap[r]=[n.normalizeValue(t)];},e.prototype.has=function(e,t){var r=this.headersMap[n.normalizeName(e)];if(!Array.isArray(r))return !1;if(void 0!==t){var o=n.normalizeValue(t);return r.indexOf(o)>=0}return !0},e.prototype.get=function(e){var t=this.headersMap[n.normalizeName(e)];return void 0!==t?t.concat():[]},e.prototype.forEach=function(e){var t=this;Object.getOwnPropertyNames(this.headersMap).forEach((function(r){e(r,t.headersMap[r]);}),this);},e.prototype.toHeaders=function(){if("undefined"!=typeof Headers){var e=new Headers;return this.forEach((function(t,r){r.forEach((function(r){e.append(t,r);}));})),e}throw new Error("Headers class is not defined")},e}();t.BrowserHeaders=o;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});var n=r(0);t.BrowserHeaders=n.BrowserHeaders;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.iterateHeaders=function(e,t){for(var r=e[Symbol.iterator](),n=r.next();!n.done;)t(n.value[0]),n=r.next();},t.iterateHeadersKeys=function(e,t){for(var r=e.keys(),n=r.next();!n.done;)t(n.value),n=r.next();};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});var n=r(2);t.normalizeName=function(e){if("string"!=typeof e&&(e=String(e)),/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e))throw new TypeError("Invalid character in header field name");return e.toLowerCase()},t.normalizeValue=function(e){return "string"!=typeof e&&(e=String(e)),e},t.getHeaderValues=function(e,t){var r=e;if(r instanceof Headers&&r.getAll)return r.getAll(t);var n=r.get(t);return n&&"string"==typeof n?[n]:n},t.getHeaderKeys=function(e){var t=e,r={},o=[];return t.keys?n.iterateHeadersKeys(t,(function(e){r[e]||(r[e]=!0,o.push(e));})):t.forEach?t.forEach((function(e,t){r[t]||(r[t]=!0,o.push(t));})):n.iterateHeaders(t,(function(e){var t=e[0];r[t]||(r[t]=!0,o.push(t));})),o},t.splitHeaderValue=function(e){var t=[];return e.split(", ").forEach((function(e){e.split(",").forEach((function(e){t.push(e);}));})),t};}]));},617:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.ChunkParser=t.ChunkType=t.encodeASCII=t.decodeASCII=void 0;var n,o=r(65);function s(e){return 9===(t=e)||10===t||13===t||e>=32&&e<=126;var t;}function i(e){for(var t=0;t!==e.length;++t)if(!s(e[t]))throw new Error("Metadata is not valid (printable) ASCII");return String.fromCharCode.apply(String,Array.prototype.slice.call(e))}function a(e){return 128==(128&e.getUint8(0))}function u(e){return e.getUint32(1,!1)}function d(e,t,r){return e.byteLength-t>=r}function c(e,t,r){if(e.slice)return e.slice(t,r);var n=e.length;void 0!==r&&(n=r);for(var o=new Uint8Array(n-t),s=0,i=t;i<n;i++)o[s++]=e[i];return o}t.decodeASCII=i,t.encodeASCII=function(e){for(var t=new Uint8Array(e.length),r=0;r!==e.length;++r){var n=e.charCodeAt(r);if(!s(n))throw new Error("Metadata contains invalid ASCII");t[r]=n;}return t},function(e){e[e.MESSAGE=1]="MESSAGE",e[e.TRAILERS=2]="TRAILERS";}(n=t.ChunkType||(t.ChunkType={}));var p=function(){function e(){this.buffer=null,this.position=0;}return e.prototype.parse=function(e,t){if(0===e.length&&t)return [];var r,s=[];if(null==this.buffer)this.buffer=e,this.position=0;else if(this.position===this.buffer.byteLength)this.buffer=e,this.position=0;else {var p=this.buffer.byteLength-this.position,h=new Uint8Array(p+e.byteLength),f=c(this.buffer,this.position);h.set(f,0);var l=new Uint8Array(e);h.set(l,p),this.buffer=h,this.position=0;}for(;;){if(!d(this.buffer,this.position,5))return s;var g=c(this.buffer,this.position,this.position+5),b=new DataView(g.buffer,g.byteOffset,g.byteLength),y=u(b);if(!d(this.buffer,this.position,5+y))return s;var v=c(this.buffer,this.position+5,this.position+5+y);if(this.position+=5+y,a(b))return s.push({chunkType:n.TRAILERS,trailers:(r=v,new o.Metadata(i(r)))}),s;s.push({chunkType:n.MESSAGE,data:v});}},e}();t.ChunkParser=p;},8:function(e,t){var r;Object.defineProperty(t,"__esModule",{value:!0}),t.httpStatusToCode=t.Code=void 0,function(e){e[e.OK=0]="OK",e[e.Canceled=1]="Canceled",e[e.Unknown=2]="Unknown",e[e.InvalidArgument=3]="InvalidArgument",e[e.DeadlineExceeded=4]="DeadlineExceeded",e[e.NotFound=5]="NotFound",e[e.AlreadyExists=6]="AlreadyExists",e[e.PermissionDenied=7]="PermissionDenied",e[e.ResourceExhausted=8]="ResourceExhausted",e[e.FailedPrecondition=9]="FailedPrecondition",e[e.Aborted=10]="Aborted",e[e.OutOfRange=11]="OutOfRange",e[e.Unimplemented=12]="Unimplemented",e[e.Internal=13]="Internal",e[e.Unavailable=14]="Unavailable",e[e.DataLoss=15]="DataLoss",e[e.Unauthenticated=16]="Unauthenticated";}(r=t.Code||(t.Code={})),t.httpStatusToCode=function(e){switch(e){case 0:return r.Internal;case 200:return r.OK;case 400:return r.InvalidArgument;case 401:return r.Unauthenticated;case 403:return r.PermissionDenied;case 404:return r.NotFound;case 409:return r.Aborted;case 412:return r.FailedPrecondition;case 429:return r.ResourceExhausted;case 499:return r.Canceled;case 500:return r.Unknown;case 501:return r.Unimplemented;case 503:return r.Unavailable;case 504:return r.DeadlineExceeded;default:return r.Unknown}};},934:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.client=void 0;var n=r(65),o=r(617),s=r(8),i=r(346),a=r(57),u=r(882);t.client=function(e,t){return new d(e,t)};var d=function(){function e(e,t){this.started=!1,this.sentFirstMessage=!1,this.completed=!1,this.closed=!1,this.finishedSending=!1,this.onHeadersCallbacks=[],this.onMessageCallbacks=[],this.onEndCallbacks=[],this.parser=new o.ChunkParser,this.methodDefinition=e,this.props=t,this.createTransport();}return e.prototype.createTransport=function(){var e=this.props.host+"/"+this.methodDefinition.service.serviceName+"/"+this.methodDefinition.methodName,t={methodDefinition:this.methodDefinition,debug:this.props.debug||!1,url:e,onHeaders:this.onTransportHeaders.bind(this),onChunk:this.onTransportChunk.bind(this),onEnd:this.onTransportEnd.bind(this)};this.props.transport?this.transport=this.props.transport(t):this.transport=a.makeDefaultTransport(t);},e.prototype.onTransportHeaders=function(e,t){if(this.props.debug&&i.debug("onHeaders",e,t),this.closed)this.props.debug&&i.debug("grpc.onHeaders received after request was closed - ignoring");else if(0===t);else {this.responseHeaders=e,this.props.debug&&i.debug("onHeaders.responseHeaders",JSON.stringify(this.responseHeaders,null,2));var r=c(e);this.props.debug&&i.debug("onHeaders.gRPCStatus",r);var n=r&&r>=0?r:s.httpStatusToCode(t);this.props.debug&&i.debug("onHeaders.code",n);var o=e.get("grpc-message")||[];if(this.props.debug&&i.debug("onHeaders.gRPCMessage",o),this.rawOnHeaders(e),n!==s.Code.OK){var a=this.decodeGRPCStatus(o[0]);this.rawOnError(n,a,e);}}},e.prototype.onTransportChunk=function(e){var t=this;if(this.closed)this.props.debug&&i.debug("grpc.onChunk received after request was closed - ignoring");else {var r=[];try{r=this.parser.parse(e);}catch(e){return this.props.debug&&i.debug("onChunk.parsing error",e,e.message),void this.rawOnError(s.Code.Internal,"parsing error: "+e.message)}r.forEach((function(e){if(e.chunkType===o.ChunkType.MESSAGE){var r=t.methodDefinition.responseType.deserializeBinary(e.data);t.rawOnMessage(r);}else e.chunkType===o.ChunkType.TRAILERS&&(t.responseHeaders?(t.responseTrailers=new n.Metadata(e.trailers),t.props.debug&&i.debug("onChunk.trailers",t.responseTrailers)):(t.responseHeaders=new n.Metadata(e.trailers),t.rawOnHeaders(t.responseHeaders)));}));}},e.prototype.onTransportEnd=function(){if(this.props.debug&&i.debug("grpc.onEnd"),this.closed)this.props.debug&&i.debug("grpc.onEnd received after request was closed - ignoring");else if(void 0!==this.responseTrailers){var e=c(this.responseTrailers);if(null!==e){var t=this.responseTrailers.get("grpc-message"),r=this.decodeGRPCStatus(t[0]);this.rawOnEnd(e,r,this.responseTrailers);}else this.rawOnError(s.Code.Internal,"Response closed without grpc-status (Trailers provided)");}else {if(void 0===this.responseHeaders)return void this.rawOnError(s.Code.Unknown,"Response closed without headers");var n=c(this.responseHeaders),o=this.responseHeaders.get("grpc-message");if(this.props.debug&&i.debug("grpc.headers only response ",n,o),null===n)return void this.rawOnEnd(s.Code.Unknown,"Response closed without grpc-status (Headers only)",this.responseHeaders);var a=this.decodeGRPCStatus(o[0]);this.rawOnEnd(n,a,this.responseHeaders);}},e.prototype.decodeGRPCStatus=function(e){if(!e)return "";try{return decodeURIComponent(e)}catch(t){return e}},e.prototype.rawOnEnd=function(e,t,r){var n=this;this.props.debug&&i.debug("rawOnEnd",e,t,r),this.completed||(this.completed=!0,this.onEndCallbacks.forEach((function(o){if(!n.closed)try{o(e,t,r);}catch(e){setTimeout((function(){throw e}),0);}})));},e.prototype.rawOnHeaders=function(e){this.props.debug&&i.debug("rawOnHeaders",e),this.completed||this.onHeadersCallbacks.forEach((function(t){try{t(e);}catch(e){setTimeout((function(){throw e}),0);}}));},e.prototype.rawOnError=function(e,t,r){var o=this;void 0===r&&(r=new n.Metadata),this.props.debug&&i.debug("rawOnError",e,t),this.completed||(this.completed=!0,this.onEndCallbacks.forEach((function(n){if(!o.closed)try{n(e,t,r);}catch(e){setTimeout((function(){throw e}),0);}})));},e.prototype.rawOnMessage=function(e){var t=this;this.props.debug&&i.debug("rawOnMessage",e.toObject()),this.completed||this.closed||this.onMessageCallbacks.forEach((function(r){if(!t.closed)try{r(e);}catch(e){setTimeout((function(){throw e}),0);}}));},e.prototype.onHeaders=function(e){this.onHeadersCallbacks.push(e);},e.prototype.onMessage=function(e){this.onMessageCallbacks.push(e);},e.prototype.onEnd=function(e){this.onEndCallbacks.push(e);},e.prototype.start=function(e){if(this.started)throw new Error("Client already started - cannot .start()");this.started=!0;var t=new n.Metadata(e||{});t.set("content-type","application/grpc-web+proto"),t.set("x-grpc-web","1"),this.transport.start(t);},e.prototype.send=function(e){if(!this.started)throw new Error("Client not started - .start() must be called before .send()");if(this.closed)throw new Error("Client already closed - cannot .send()");if(this.finishedSending)throw new Error("Client already finished sending - cannot .send()");if(!this.methodDefinition.requestStream&&this.sentFirstMessage)throw new Error("Message already sent for non-client-streaming method - cannot .send()");this.sentFirstMessage=!0;var t=u.frameRequest(e);this.transport.sendMessage(t);},e.prototype.finishSend=function(){if(!this.started)throw new Error("Client not started - .finishSend() must be called before .close()");if(this.closed)throw new Error("Client already closed - cannot .send()");if(this.finishedSending)throw new Error("Client already finished sending - cannot .finishSend()");this.finishedSending=!0,this.transport.finishSend();},e.prototype.close=function(){if(!this.started)throw new Error("Client not started - .start() must be called before .close()");if(this.closed)throw new Error("Client already closed - cannot .close()");this.closed=!0,this.props.debug&&i.debug("request.abort aborting request"),this.transport.cancel();},e}();function c(e){var t=e.get("grpc-status")||[];if(t.length>0)try{var r=t[0];return parseInt(r,10)}catch(e){return null}return null}},346:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.debug=void 0,t.debug=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];console.debug?console.debug.apply(null,e):console.log.apply(null,e);};},607:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.grpc=void 0;var n,o=r(418),s=r(57),i=r(229),a=r(540),u=r(210),d=r(859),c=r(8),p=r(938),h=r(35),f=r(934);(n=t.grpc||(t.grpc={})).setDefaultTransport=s.setDefaultTransportFactory,n.CrossBrowserHttpTransport=d.CrossBrowserHttpTransport,n.FetchReadableStreamTransport=i.FetchReadableStreamTransport,n.XhrTransport=u.XhrTransport,n.WebsocketTransport=a.WebsocketTransport,n.Code=c.Code,n.Metadata=o.BrowserHeaders,n.client=function(e,t){return f.client(e,t)},n.invoke=p.invoke,n.unary=h.unary;},938:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.invoke=void 0;var n=r(934);t.invoke=function(e,t){if(e.requestStream)throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");var r=n.client(e,{host:t.host,transport:t.transport,debug:t.debug});return t.onHeaders&&r.onHeaders(t.onHeaders),t.onMessage&&r.onMessage(t.onMessage),t.onEnd&&r.onEnd(t.onEnd),r.start(t.metadata),r.send(t.request),r.finishSend(),{close:function(){r.close();}}};},65:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.Metadata=void 0;var n=r(418);Object.defineProperty(t,"Metadata",{enumerable:!0,get:function(){return n.BrowserHeaders}});},57:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.makeDefaultTransport=t.setDefaultTransportFactory=void 0;var n=r(859),o=function(e){return n.CrossBrowserHttpTransport({withCredentials:!1})(e)};t.setDefaultTransportFactory=function(e){o=e;},t.makeDefaultTransport=function(e){return o(e)};},229:function(e,t,r){var n=this&&this.__assign||function(){return (n=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var o in t=arguments[r])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.detectFetchSupport=t.FetchReadableStreamTransport=void 0;var o=r(65),s=r(346);t.FetchReadableStreamTransport=function(e){return function(t){return function(e,t){return e.debug&&s.debug("fetchRequest",e),new i(e,t)}(t,e)}};var i=function(){function e(e,t){this.cancelled=!1,this.controller=self.AbortController&&new AbortController,this.options=e,this.init=t;}return e.prototype.pump=function(e,t){var r=this;if(this.reader=e,this.cancelled)return this.options.debug&&s.debug("Fetch.pump.cancel at first pump"),void this.reader.cancel().catch((function(e){r.options.debug&&s.debug("Fetch.pump.reader.cancel exception",e);}));this.reader.read().then((function(e){if(e.done)return r.options.onEnd(),t;r.options.onChunk(e.value),r.pump(r.reader,t);})).catch((function(e){r.cancelled?r.options.debug&&s.debug("Fetch.catch - request cancelled"):(r.cancelled=!0,r.options.debug&&s.debug("Fetch.catch",e.message),r.options.onEnd(e));}));},e.prototype.send=function(e){var t=this;fetch(this.options.url,n(n({},this.init),{headers:this.metadata.toHeaders(),method:"POST",body:e,signal:this.controller&&this.controller.signal})).then((function(e){if(t.options.debug&&s.debug("Fetch.response",e),t.options.onHeaders(new o.Metadata(e.headers),e.status),!e.body)return e;t.pump(e.body.getReader(),e);})).catch((function(e){t.cancelled?t.options.debug&&s.debug("Fetch.catch - request cancelled"):(t.cancelled=!0,t.options.debug&&s.debug("Fetch.catch",e.message),t.options.onEnd(e));}));},e.prototype.sendMessage=function(e){this.send(e);},e.prototype.finishSend=function(){},e.prototype.start=function(e){this.metadata=e;},e.prototype.cancel=function(){var e=this;this.cancelled?this.options.debug&&s.debug("Fetch.cancel already cancelled"):(this.cancelled=!0,this.controller?(this.options.debug&&s.debug("Fetch.cancel.controller.abort"),this.controller.abort()):this.options.debug&&s.debug("Fetch.cancel.missing abort controller"),this.reader?(this.options.debug&&s.debug("Fetch.cancel.reader.cancel"),this.reader.cancel().catch((function(t){e.options.debug&&s.debug("Fetch.cancel.reader.cancel exception",t);}))):this.options.debug&&s.debug("Fetch.cancel before reader"));},e}();t.detectFetchSupport=function(){return "undefined"!=typeof Response&&Response.prototype.hasOwnProperty("body")&&"function"==typeof Headers};},859:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.CrossBrowserHttpTransport=void 0;var n=r(229),o=r(210);t.CrossBrowserHttpTransport=function(e){if(n.detectFetchSupport()){var t={credentials:e.withCredentials?"include":"same-origin"};return n.FetchReadableStreamTransport(t)}return o.XhrTransport({withCredentials:e.withCredentials})};},210:function(e,t,r){var n,o=this&&this.__extends||(n=function(e,t){return (n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.stringToArrayBuffer=t.MozChunkedArrayBufferXHR=t.XHR=t.XhrTransport=void 0;var s=r(65),i=r(346),a=r(849);t.XhrTransport=function(e){return function(t){if(a.detectMozXHRSupport())return new d(t,e);if(a.detectXHROverrideMimeTypeSupport())return new u(t,e);throw new Error("This environment's XHR implementation cannot support binary transfer.")}};var u=function(){function e(e,t){this.options=e,this.init=t;}return e.prototype.onProgressEvent=function(){this.options.debug&&i.debug("XHR.onProgressEvent.length: ",this.xhr.response.length);var e=this.xhr.response.substr(this.index);this.index=this.xhr.response.length;var t=p(e);this.options.onChunk(t);},e.prototype.onLoadEvent=function(){this.options.debug&&i.debug("XHR.onLoadEvent"),this.options.onEnd();},e.prototype.onStateChange=function(){this.options.debug&&i.debug("XHR.onStateChange",this.xhr.readyState),this.xhr.readyState===XMLHttpRequest.HEADERS_RECEIVED&&this.options.onHeaders(new s.Metadata(this.xhr.getAllResponseHeaders()),this.xhr.status);},e.prototype.sendMessage=function(e){this.xhr.send(e);},e.prototype.finishSend=function(){},e.prototype.start=function(e){var t=this;this.metadata=e;var r=new XMLHttpRequest;this.xhr=r,r.open("POST",this.options.url),this.configureXhr(),this.metadata.forEach((function(e,t){r.setRequestHeader(e,t.join(", "));})),r.withCredentials=Boolean(this.init.withCredentials),r.addEventListener("readystatechange",this.onStateChange.bind(this)),r.addEventListener("progress",this.onProgressEvent.bind(this)),r.addEventListener("loadend",this.onLoadEvent.bind(this)),r.addEventListener("error",(function(e){t.options.debug&&i.debug("XHR.error",e),t.options.onEnd(e.error);}));},e.prototype.configureXhr=function(){this.xhr.responseType="text",this.xhr.overrideMimeType("text/plain; charset=x-user-defined");},e.prototype.cancel=function(){this.options.debug&&i.debug("XHR.abort"),this.xhr.abort();},e}();t.XHR=u;var d=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return o(t,e),t.prototype.configureXhr=function(){this.options.debug&&i.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"),this.xhr.responseType="moz-chunked-arraybuffer";},t.prototype.onProgressEvent=function(){var e=this.xhr.response;this.options.debug&&i.debug("MozXHR.onProgressEvent: ",new Uint8Array(e)),this.options.onChunk(new Uint8Array(e));},t}(u);function c(e,t){var r=e.charCodeAt(t);if(r>=55296&&r<=56319){var n=e.charCodeAt(t+1);n>=56320&&n<=57343&&(r=65536+(r-55296<<10)+(n-56320));}return r}function p(e){for(var t=new Uint8Array(e.length),r=0,n=0;n<e.length;n++){var o=String.prototype.codePointAt?e.codePointAt(n):c(e,n);t[r++]=255&o;}return t}t.MozChunkedArrayBufferXHR=d,t.stringToArrayBuffer=p;},849:function(e,t){var r;function n(){if(void 0!==r)return r;if(XMLHttpRequest){r=new XMLHttpRequest;try{r.open("GET","https://localhost");}catch(e){}}return r}function o(e){var t=n();if(!t)return !1;try{return t.responseType=e,t.responseType===e}catch(e){}return !1}Object.defineProperty(t,"__esModule",{value:!0}),t.detectXHROverrideMimeTypeSupport=t.detectMozXHRSupport=t.xhrSupportsResponseType=void 0,t.xhrSupportsResponseType=o,t.detectMozXHRSupport=function(){return "undefined"!=typeof XMLHttpRequest&&o("moz-chunked-arraybuffer")},t.detectXHROverrideMimeTypeSupport=function(){return "undefined"!=typeof XMLHttpRequest&&XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType")};},540:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.WebsocketTransport=void 0;var n,o=r(346),s=r(617);!function(e){e[e.FINISH_SEND=1]="FINISH_SEND";}(n||(n={}));var i=new Uint8Array([1]);t.WebsocketTransport=function(){return function(e){return function(e){e.debug&&o.debug("websocketRequest",e);var t,r=function(e){if("https://"===e.substr(0,8))return "wss://"+e.substr(8);if("http://"===e.substr(0,7))return "ws://"+e.substr(7);throw new Error("Websocket transport constructed with non-https:// or http:// host.")}(e.url),a=[];function u(e){if(e===n.FINISH_SEND)t.send(i);else {var r=e,o=new Int8Array(r.byteLength+1);o.set(new Uint8Array([0])),o.set(r,1),t.send(o);}}return {sendMessage:function(e){t&&t.readyState!==t.CONNECTING?u(e):a.push(e);},finishSend:function(){t&&t.readyState!==t.CONNECTING?u(n.FINISH_SEND):a.push(n.FINISH_SEND);},start:function(n){(t=new WebSocket(r,["grpc-websockets"])).binaryType="arraybuffer",t.onopen=function(){var r;e.debug&&o.debug("websocketRequest.onopen"),t.send((r="",n.forEach((function(e,t){r+=e+": "+t.join(", ")+"\r\n";})),s.encodeASCII(r))),a.forEach((function(e){u(e);}));},t.onclose=function(t){e.debug&&o.debug("websocketRequest.onclose",t),e.onEnd();},t.onerror=function(t){e.debug&&o.debug("websocketRequest.onerror",t);},t.onmessage=function(t){e.onChunk(new Uint8Array(t.data));};},cancel:function(){e.debug&&o.debug("websocket.abort"),t.close();}}}(e)}};},35:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.unary=void 0;var n=r(65),o=r(934);t.unary=function(e,t){if(e.responseStream)throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");if(e.requestStream)throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");var r=null,s=null,i=o.client(e,{host:t.host,transport:t.transport,debug:t.debug});return i.onHeaders((function(e){r=e;})),i.onMessage((function(e){s=e;})),i.onEnd((function(e,o,i){t.onEnd({status:e,statusMessage:o,headers:r||new n.Metadata,message:s,trailers:i});})),i.start(t.metadata),i.send(t.request),i.finishSend(),{close:function(){i.close();}}};},882:function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.frameRequest=void 0,t.frameRequest=function(e){var t=e.serializeBinary(),r=new ArrayBuffer(t.byteLength+5);return new DataView(r,1,4).setUint32(0,t.length,!1),new Uint8Array(r,5).set(t),new Uint8Array(r)};}},t={};return function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(607)}());
});

const createHost = ({
  httpUrl,
  ssl
}) => {
  const sanitizedUrl = /^https?:\/\//i.test(httpUrl) ? httpUrl : `http://${httpUrl}`;
  const url = new URL(sanitizedUrl);
  if (ssl) {
    url.protocol = 'https:';
  }
  return url.href.replace(/\/+$/, '');
};
const getStatus = headers => {
  const [statusCode] = headers.get('grpc-status') || [];
  const [message] = headers.get('grpc-message') || [];
  return statusCode ? {
    code: GrpcStatus[Number(statusCode)],
    detail: message || ''
  } : null;
};
/**
 * The `WebsocketTransport` class represents a gRPC transport layer for RPC communication over WebSockets.
 *
 * @group RPC Transport
 */
class WebsocketTransport {
  constructor({
    timeout,
    interceptors = [],
    ...options
  }) {
    this.defaultOptions = {};
    this.host = void 0;
    this.host = createHost(options);
    this.defaultOptions = {
      interceptors: timeout ? [new TimeoutInterceptor(timeout), ...interceptors] : interceptors
    };
  }
  clientStreaming(method, options) {
    var _options$meta;
    const InputType = mapType(method.I);
    const defHeader = new runtimeRpc.Deferred();
    const defMessage = new runtimeRpc.Deferred();
    const defStatus = new runtimeRpc.Deferred();
    const defTrailer = new runtimeRpc.Deferred();
    const client = grpcWebClient.grpc.client({
      methodName: method.name,
      requestStream: true,
      responseStream: false,
      requestType: InputType,
      responseType: mapType(method.O),
      service: {
        serviceName: method.service.typeName
      }
    }, {
      host: this.host,
      transport: grpcWebClient.grpc.WebsocketTransport()
    });
    const emitError = error => {
      defHeader.rejectPending(error);
      defMessage.rejectPending(error);
      defStatus.rejectPending(error);
      defTrailer.rejectPending(error);
    };
    if (options.abort) {
      options.abort.addEventListener('abort', () => {
        emitError(options.abort.reason || new runtimeRpc.RpcError('Canceled by client', GrpcStatus[GrpcStatus.CANCELLED]));
        client.close();
      });
    }
    client.onHeaders(meta => {
      const status = getStatus(meta);
      if (status && status.code !== GrpcStatus[GrpcStatus.OK]) {
        return defHeader.rejectPending(new runtimeRpc.RpcError(status.detail, status.code));
      }
      defHeader.resolvePending(meta.headersMap);
    });
    client.onMessage(message => {
      defMessage.resolvePending(message.toObject());
    });
    client.onEnd((status, statusMessage, trailers) => {
      if (status !== grpcWebClient.grpc.Code.OK) {
        return emitError(new runtimeRpc.RpcError(statusMessage, GrpcStatus[status]));
      }
      defStatus.resolvePending({
        code: GrpcStatus[status],
        detail: statusMessage
      });
      defTrailer.resolvePending(trailers.headersMap);
    });
    client.start(new grpcWebClient.grpc.Metadata(options.meta));
    const inputStream = {
      send: async message => client.send(new InputType(message)),
      complete: async () => client.finishSend()
    };
    return new runtimeRpc.ClientStreamingCall(method, (_options$meta = options.meta) != null ? _options$meta : {}, inputStream, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);
  }
  duplex(method, options) {
    var _options$meta2;
    const InputType = mapType(method.I);
    const defHeader = new runtimeRpc.Deferred();
    const outStream = new runtimeRpc.RpcOutputStreamController();
    const defStatus = new runtimeRpc.Deferred();
    const defTrailer = new runtimeRpc.Deferred();
    const client = grpcWebClient.grpc.client({
      methodName: method.name,
      requestStream: true,
      responseStream: true,
      requestType: InputType,
      responseType: mapType(method.O),
      service: {
        serviceName: method.service.typeName
      }
    }, {
      host: this.host,
      transport: grpcWebClient.grpc.WebsocketTransport()
    });
    const emitError = error => {
      defHeader.rejectPending(error);
      defStatus.rejectPending(error);
      defTrailer.rejectPending(error);
      if (!outStream.closed) {
        outStream.notifyError(error);
      }
    };
    if (options.abort) {
      options.abort.addEventListener('abort', () => {
        emitError(options.abort.reason || new runtimeRpc.RpcError('Canceled by client', GrpcStatus[GrpcStatus.CANCELLED]));
        client.close();
      });
    }
    client.onHeaders(meta => {
      const status = getStatus(meta);
      if (status && status.code !== GrpcStatus[GrpcStatus.OK]) {
        return defHeader.rejectPending(new runtimeRpc.RpcError(status.detail, status.code));
      }
      defHeader.resolvePending(meta.headersMap);
    });
    client.onMessage(message => {
      outStream.notifyMessage(message.toObject());
    });
    client.onEnd((status, statusMessage, trailers) => {
      if (status !== grpcWebClient.grpc.Code.OK) {
        return emitError(new runtimeRpc.RpcError(statusMessage, GrpcStatus[status]));
      }
      defStatus.resolvePending({
        code: GrpcStatus[status],
        detail: statusMessage
      });
      defTrailer.resolvePending(trailers.headersMap);
      if (!outStream.closed) {
        outStream.notifyComplete();
      }
    });
    client.start(new grpcWebClient.grpc.Metadata(options.meta));
    const inputStream = {
      send: async message => {
        client.send(new InputType(message));
      },
      complete: async () => {
        if (defStatus.state === runtimeRpc.DeferredState.PENDING) {
          client.finishSend();
        }
      }
    };
    return new runtimeRpc.DuplexStreamingCall(method, (_options$meta2 = options.meta) != null ? _options$meta2 : {}, inputStream, defHeader.promise, outStream, defStatus.promise, defTrailer.promise);
  }
  mergeOptions(options) {
    return runtimeRpc.mergeRpcOptions(this.defaultOptions, options);
  }
  serverStreaming() {
    throw new Error('Not implemented');
  }
  unary(method, input, options) {
    var _options$meta3;
    const InputType = mapType(method.I);
    const defHeader = new runtimeRpc.Deferred();
    const defMessage = new runtimeRpc.Deferred();
    const defStatus = new runtimeRpc.Deferred();
    const defTrailer = new runtimeRpc.Deferred();
    const request = new Promise((onEnd, reject) => {
      const client = grpcWebClient.grpc.unary({
        methodName: method.name,
        requestStream: false,
        responseStream: false,
        requestType: InputType,
        responseType: mapType(method.O),
        service: {
          serviceName: method.service.typeName
        }
      }, {
        host: this.host,
        transport: grpcWebClient.grpc.WebsocketTransport(),
        metadata: new grpcWebClient.grpc.Metadata(options.meta),
        request: new InputType(input),
        onEnd
      });
      if (options.abort) {
        options.abort.addEventListener('abort', () => {
          var _options$abort;
          reject(((_options$abort = options.abort) == null ? void 0 : _options$abort.reason) || new runtimeRpc.RpcError('Canceled by client', GrpcStatus[GrpcStatus.CANCELLED]));
          client.close();
        });
      }
    });
    request.then(output => {
      defHeader.resolvePending(output.headers.headersMap);
      defTrailer.resolvePending(output.headers.headersMap);
      defStatus.resolvePending({
        code: GrpcStatus[output.status],
        detail: output.statusMessage
      });
      if (output.status !== grpcWebClient.grpc.Code.OK) {
        throw new runtimeRpc.RpcError(output.statusMessage, GrpcStatus[output.status]);
      }
      if (output.message) {
        defMessage.resolvePending(output.message.toObject());
      }
    }).catch(error => {
      error.methodName = method.name;
      error.serviceName = method.service.typeName;
      defHeader.rejectPending(error);
      defMessage.rejectPending(error);
      defStatus.rejectPending(error);
      defTrailer.rejectPending(error);
    });
    return new runtimeRpc.UnaryCall(method, (_options$meta3 = options.meta) != null ? _options$meta3 : {}, input, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);
  }
}
const mapType = NativeType => {
  var _WebType;
  class WebType {
    constructor(payload = NativeType.create()) {
      this.payload = void 0;
      this.payload = payload;
    }
    serializeBinary() {
      return NativeType.toBinary(this.payload);
    }
    toObject() {
      return this.payload;
    }
  }
  _WebType = WebType;
  WebType.deserializeBinary = bytes => {
    const message = NativeType.fromBinary(bytes);
    return new _WebType(message);
  };
  return WebType;
};

class DefaultTransport extends GrpcTransport {}

/**
 * The `Piece` class represents a piece of content.
 *
 * @group Files
 *
 * @example
 *
 * ```typescript
 * const content = new Uint8Array([1, 2, 3]);
 * const piece = new Piece(content, { size: 3 });
 *
 * console.log(Piece.isPiece(piece)); // true
 * ```
 */
class Piece {
  constructor(content, meta = {}) {
    this.contentLength = void 0;
    this.content = void 0;
    /**
     * The offset of the piece in a multipart upload.
     */
    this.offset = void 0;
    /**
     * The content of the piece as a stream.
     */
    this.body = void 0;
    /**
     * The metadata for the piece.
     */
    this.meta = void 0;
    this.offset = meta.multipartOffset;
    this.body = isContentStream(content) ? content : createContentStream(content);
    this.contentLength = getContentSize(content, meta.size);
    this.meta = meta;
    this.content = content;
  }
  /**
   * Checks if the piece is part of a multipart upload.
   */
  get isPart() {
    return this.offset !== undefined;
  }
  /**
   * The size of the piece.
   */
  get size() {
    if (!this.contentLength) {
      throw new Error('The piece size can not be determined');
    }
    return this.contentLength;
  }
  /**
   * Checks if an object is an instance of `Piece`.
   *
   * @param object - The object to check.
   *
   * @returns `true` if the object is an instance of `Piece` or has the same properties as a `Piece`, `false` otherwise.
   */
  static isPiece(object) {
    const maybePiece = object;
    if (object instanceof Piece) {
      return true;
    }
    return typeof maybePiece === 'object' && typeof (maybePiece == null ? void 0 : maybePiece.meta) === 'object' && typeof maybePiece.isPart === 'boolean' && !!maybePiece.body;
  }
  /**
   * Checks if an object is an instance of `Piece` with static content.
   *
   * @param object - The object to check.
   *
   * @returns `true` if the object is an instance of `Piece` and its content is a `Uint8Array`, `false` otherwise.
   */
  static isStaticPiece(object) {
    return Piece.isPiece(object) && object.content instanceof Uint8Array;
  }
  /**
   * Creates a new `Piece` from an existing one.
   *
   * @param piece - The existing `Piece` to create a new one from.
   *
   * @returns A new `Piece` with the same content and metadata as the existing one.
   */
  static from(piece) {
    if (isContentStream(piece.content) && piece.content.locked) {
      throw new Error('The content stream is locked and can not be reused');
    }
    return new Piece(piece.content, piece.meta);
  }
}
/**
 * The `MultipartPiece` class represents a piece cobined from multiple parts (raw pieces).
 *
 * @group Files
 *
 * @example
 *
 * ```typescript
 * const parts = ['CID1', 'CID2'];
 * const multipartPiece = new MultipartPiece(parts, {
 *  partSize: 1024,
 *  totalSize: 2048,
 * });
 *
 * console.log(MultipartPiece.isMultipartPiece(multipartPiece)); // true
 * ```
 */
class MultipartPiece {
  constructor(parts, meta) {
    /**
     * The hashes of the parts of the multipart piece.
     */
    this.partHashes = void 0;
    /**
     * The metadata of the multipart piece.
     */
    this.meta = void 0;
    /**
     * The parts of the multipart piece.
     */
    this.parts = void 0;
    this.partHashes = parts.map(part => new Cid(part).contentHash);
    this.meta = meta;
    this.parts = parts;
  }
  /**
   * Checks if an object is an instance of `MultipartPiece`.
   *
   * @param object - The object to check.
   *
   * @returns `true` if the object is an instance of `MultipartPiece` or has the same properties as a `MultipartPiece`, `false` otherwise.
   */
  static isMultipartPiece(object) {
    const maybeMultipartPiece = object;
    if (object instanceof MultipartPiece) {
      return true;
    }
    return typeof maybeMultipartPiece === 'object' && typeof (maybeMultipartPiece == null ? void 0 : maybeMultipartPiece.meta) === 'object' && typeof maybeMultipartPiece.meta.partSize === 'number' && typeof maybeMultipartPiece.meta.totalSize === 'number' && Array.isArray(maybeMultipartPiece.parts) && Array.isArray(maybeMultipartPiece.partHashes);
  }
}
/**
 * The `PieceResponse` class represents a response for a piece content.
 *
 * @group Files
 */
class PieceResponse {
  constructor(cid, body, meta) {
    this.cidObject = void 0;
    this.meta = void 0;
    /**
     * The content of the piece response as a stream.
     */
    this.body = void 0;
    this.cidObject = cid instanceof Cid ? cid : new Cid(cid);
    this.body = body;
    this.meta = meta;
  }
  /**
   * The range of the piece response.
   */
  get range() {
    var _this$meta;
    return (_this$meta = this.meta) == null ? void 0 : _this$meta.range;
  }
  /**
   * The hash of the piece response content.
   */
  get hash() {
    return this.cidObject.contentHash;
  }
  /**
   * The content identifier (CID) of the piece.
   */
  get cid() {
    return this.cidObject.toString();
  }
  /**
   * Converts the body stream of the piece to an `ArrayBuffer`.
   *
   * @returns The piece content as an `ArrayBuffer`.
   */
  async arrayBuffer() {
    return consumers$1.arrayBuffer(this.body);
  }
  /**
   * Converts the body stream of the piece to a string.
   *
   * @returns The piece content as a string.
   */
  async text() {
    return consumers$1.text(this.body);
  }
  /**
   * Converts the body stream of the piece to a JSON object.
   *
   * @returns The piece content as a JSON object.
   */
  async json() {
    return consumers$1.json(this.body);
  }
}

/**
 * The `Link` class represents a link in a DAG.
 *
 * @group Directed Acyclic Graph (DAG)
 *
 * @example
 *
 * ```typescript
 * const cid = '...';
 * const size = 10;
 * const name = 'example';
 * const link = new Link(cid, size, name);
 *
 * console.log(link);
 * ```
 */
class Link {
  constructor(cid, size, name = '') {
    /**
     * The content identifier of the link.
     */
    this.cid = void 0;
    /**
     * The content size on which the link points to.
     */
    this.size = void 0;
    /**
     * The name of the link.
     */
    this.name = '';
    this.cid = cid;
    this.size = size;
    this.name = name;
  }
}
/**
 * The `Tag` class represents a DAG Node tag.
 *
 * @group Directed Acyclic Graph (DAG)
 * @example
 *
 * ```typescript
 * const key = 'exampleKey';
 * const value = 'exampleValue';
 * const tag = new Tag(key, value);
 *
 * console.log(tag);
 * ```
 */
class Tag {
  constructor(key, value) {
    /**
     * The key of the tag.
     */
    this.key = void 0;
    /**
     * The value of the tag.
     */
    this.value = void 0;
    this.key = key;
    this.value = value;
  }
}
/**
 * The `DagNode` class represents a node in a Directed Acyclic Graph (DAG).
 *
 * @group Directed Acyclic Graph (DAG)
 *
 * @example
 *
 * ```typescript
 * const data = 'Node data';
 * const links = [new Link('...', 10, 'link1')];
 * const tags = [new Tag('exampleKey', 'exampleValue')];
 * const node = new DagNode(data, links, tags);
 *
 * console.log(DagNode.isDagNode(node)); // true
 * ```
 */
class DagNode {
  constructor(data, links = [], tags = []) {
    this.dataBuffer = void 0;
    /**
     * The links of the node.
     */
    this.links = void 0;
    /**
     * The tags of the node.
     */
    this.tags = void 0;
    this.dataBuffer = buffer.Buffer.from(data || []);
    this.links = links;
    this.tags = tags;
  }
  /**
   * The size of the node in bytes.
   */
  get size() {
    return Node.toBinary(mapDagNodeToAPI(this)).byteLength;
  }
  /**
   * The data of the node as a `Buffer`.
   */
  get data() {
    return this.dataBuffer;
  }
  set data(data) {
    this.dataBuffer = buffer.Buffer.from(data);
  }
  /**
   * Checks if an object is an instance of `DagNode`.
   *
   * @param object - The object to check.
   *
   * @returns `true` if the object is an instance of `DagNode` or has the same properties as a `DagNode`, `false` otherwise.
   */
  static isDagNode(object) {
    const maybeNode = object;
    if (object instanceof DagNode) {
      return true;
    }
    return typeof maybeNode === 'object' && (maybeNode == null ? void 0 : maybeNode.data) instanceof Uint8Array && Array.isArray(maybeNode.links) && Array.isArray(maybeNode.tags);
  }
}
/**
 * The `DagNodeResponse` class represents a response for a DAG Node.
 *
 * @group Directed Acyclic Graph (DAG)
 * @extends DagNode
 */
class DagNodeResponse extends DagNode {
  constructor(cid, data, dagLinks = [], tags = []) {
    const links = dagLinks.map(link => ({
      ...link,
      cid: new Cid(link.cid).toString()
    }));
    super(new Uint8Array(data), links, tags);
    this.cidObject = void 0;
    this.cidObject = new Cid(cid);
  }
  /**
   * The content identifier of the response as a string.
   */
  get cid() {
    return this.cidObject.toString();
  }
}
const mapDagNodeToAPI = node => ({
  ...node,
  data: node.data,
  links: node.links.map(link => ({
    ...link,
    cid: new Cid(link.cid).toBytes()
  }))
});

/**
 * The `CnsRecord` class represents a CNS record.
 *
 * @group Content Name System (CNS)
 *
 * @example
 *
 * ```typescript
 * const cid = '...';
 * const name = 'example';
 * const record = new CnsRecord(cid, name);
 *
 * console.log(CnsRecord.isCnsRecord(record)); // true
 * ```
 */
class CnsRecord {
  constructor(cid, name) {
    /**
     * The content identifier (CID) of the CNS record.
     */
    this.cid = void 0;
    /**
     * The name of the CNS record.
     */
    this.name = void 0;
    this.cid = cid;
    this.name = name;
  }
  /**
   * Checks if an object is an instance of `CnsRecord`.
   *
   * @param object - The object to check.
   *
   * @returns `true` if the object is an instance of `CnsRecord` or has the same properties as a `CnsRecord`, `false` otherwise.
   */
  static isCnsRecord(object) {
    const maybeRecord = object;
    if (object instanceof CnsRecord) {
      return true;
    }
    return typeof maybeRecord === 'object' && typeof (maybeRecord == null ? void 0 : maybeRecord.cid) === 'string' && typeof maybeRecord.name === 'string';
  }
}
/**
 * The `CnsRecordResponse` class represents a response for a CNS record.
 *
 * @group Content Name System (CNS)
 */
class CnsRecordResponse extends CnsRecord {
  constructor(cid, name, signature) {
    super(new Cid(cid).toString(), name);
    /**
     * The signature of the response as a `Signature` object.
     */
    this.signature = void 0;
    this.signature = signature;
  }
}
const mapCnsRecordToAPI = ({
  name,
  cid
}) => ({
  name,
  cid: new Cid(cid).toBytes()
});

/**
 * The `StorageNode` class provides methods for communicating with a DDC storage node.
 *
 * @group Storage Node
 * @example
 *
 * ```typescript
 * const signer = new UriSigner('hybrid label reunion ...');
 *
 * const storageNode = new StorageNode(signer, {
 *   mode: StorageNodeMode.Storage,
 * });
 * ```
 */
class StorageNode {
  constructor(signer, config) {
    var _config$timeout;
    this.signer = void 0;
    this.config = void 0;
    this.nodeId = void 0;
    this.displayName = void 0;
    this.dagApi = void 0;
    this.fileApi = void 0;
    this.cnsApi = void 0;
    this.logger = void 0;
    this.rootTokenPromise = void 0;
    this.mode = void 0;
    this.signer = signer;
    this.config = config;
    const authToken = AuthToken.maybeToken(config.authToken);
    const transport = new DefaultTransport({
      ...config,
      timeout: (_config$timeout = config.timeout) != null ? _config$timeout : GRPC_REQUEST_INACTIVITY_TIMEOUT
    });
    this.nodeId = config.nodeId || uuid.v4();
    this.mode = config.mode;
    this.logger = createLogger('StorageNode', config);
    this.rootTokenPromise = authToken && Promise.resolve(authToken);
    /**
     * Use the HTTP URL as the display name.
     */
    this.displayName = config.httpUrl;
    const options = {
      signer,
      logger: this.logger,
      authenticate: config.authenticate,
      enableAcks: config.enableAcks
    };
    this.cnsApi = new CnsApi(transport, options);
    this.dagApi = new DagApi(transport, options);
    this.fileApi = new FileApi(transport, options);
    this.logger.debug(config, 'Storage node initialized');
    if (config.logErrors !== false) {
      bindErrorLogger(this, this.logger, ['storePiece', 'storeDagNode', 'readPiece', 'getDagNode', 'storeCnsRecord', 'getCnsRecord', 'resolveName']);
    }
  }
  async getRootToken() {
    this.rootTokenPromise || (this.rootTokenPromise = createSdkToken(this.signer));
    return this.rootTokenPromise;
  }
  async createAuthToken({
    accessToken
  } = {}) {
    const inputToken = AuthToken.maybeToken(accessToken);
    if (inputToken != null && inputToken.isSigned) {
      return inputToken;
    }
    const unsignedToken = inputToken || (await this.getRootToken());
    const sdkSigner = unsignedToken.subject && getSdkSigner(this.signer, unsignedToken.subject);
    return AuthToken.from(unsignedToken).sign(sdkSigner || this.signer);
  }
  /**
   * Stores a piece (raw or multipart) of data in a specific bucket.
   *
   * @param bucketId - The ID of the bucket to store the piece in.
   * @param piece - The instance of Piece or MultipartPiece.
   * @param options - Optional parameters for storing the piece.
   *
   * @returns A promise that resolves to the CID of the stored piece.
   *
   * @example
   *
   * ```typescript
   * const bucketId: BucketId = 1n;
   * const piece: Piece = new Piece(new Uint8Array([1, 2, 3]));
   * const pieceCid = await storageNode.storePiece(bucketId, piece);
   *
   * console.log(pieceCid);
   * ```
   *
   * ```typescript
   * const bucketId: BucketId = 1n;
   * const piece: MultipartPiece = new MultipartPiece(['CID1', 'CID2'], {
   *  partSize: 1024,
   *  totalSize: 2048,
   * });
   *
   * const pieceCid = await storageNode.storePiece(bucketId, piece);
   *
   * console.log(pieceCid);
   * ```
   */
  async storePiece(bucketId, piece, options) {
    let cidBytes = undefined;
    const token = await this.createAuthToken(options);
    const correlationId = (options == null ? void 0 : options.correlationId) || createCorrelationId();
    if (MultipartPiece.isMultipartPiece(piece)) {
      this.logger.info('Storing multipart piece into bucket %s', bucketId);
      cidBytes = await this.fileApi.putMultipartPiece({
        bucketId,
        token,
        correlationId,
        partHashes: piece.partHashes,
        partSize: piece.meta.partSize,
        totalSize: piece.meta.totalSize
      });
    }
    if (Piece.isPiece(piece)) {
      this.logger.info('Storing raw piece into bucket %s', bucketId);
      cidBytes = await this.fileApi.putRawPiece({
        bucketId,
        token,
        correlationId,
        isMultipart: piece.isPart,
        offset: piece.offset,
        size: piece.size
      }, piece.body);
    }
    if (!cidBytes) {
      throw new Error('`piece` argument is neither Piece nor MultipartPiece');
    }
    const cid = new Cid(cidBytes).toString();
    if (options != null && options.name) {
      await this.storeCnsRecord(bucketId, new CnsRecord(cid, options.name), options);
    }
    this.logger.info('Stored piece into bucket %s with CID %s', bucketId, cid);
    return cid;
  }
  /**
   * Stores a DAG node in a specific bucket.
   *
   * @param bucketId - The ID of the bucket to store the DAG node in.
   * @param node - The DAGNode instance to store.
   * @param options - Optional parameters for storing the DAG node.
   *
   * @returns A promise that resolves to the CID of the stored DAG node.
   *
   * @example
   *
   * ```typescript
   * const bucketId: BucketId = 1n;
   * const firstLink = new Link('CID', 10, 'first-link');
   * const node: DagNode = new DagNode('node content', [firstLink]);
   * const nodeCid = await storageNode.storeDagNode(bucketId, node, {
   *  name: 'node-name', // CNS name for the DAG node
   * });
   *
   * console.log(nodeCid);
   * ```
   */
  async storeDagNode(bucketId, node, options) {
    const token = await this.createAuthToken(options);
    const correlationId = (options == null ? void 0 : options.correlationId) || createCorrelationId();
    this.logger.info('Storing DAG node into bucket %s', bucketId);
    const cidBytes = await this.dagApi.putNode({
      bucketId,
      token,
      correlationId,
      node: mapDagNodeToAPI(node)
    });
    const cid = new Cid(cidBytes).toString();
    if (options != null && options.name) {
      await this.storeCnsRecord(bucketId, new CnsRecord(cid, options.name), options);
    }
    this.logger.info('Stored DAG Node into bucket %s with CID %s', bucketId, cid);
    return cid;
  }
  /**
   * Reads a piece of data from a specific bucket.
   *
   * @param bucketId - The ID of the bucket to read the piece from.
   * @param cidOrName - The CID or CNS name of the piece to read.
   * @param options - Optional parameters for reading the piece.
   *
   * @returns A promise that resolves to a PieceResponse instance.
   *
   * @example
   *
   * ```typescript
   * const bucketId: BucketId = 1n;
   * const cidOrName = '...'; // CID or CNS name of the piece
   * const piece = await storageNode.readPiece(bucketId, cidOrName);
   *
   * console.log(piece);
   * ```
   */
  async readPiece(bucketId, cidOrName, options) {
    const token = await this.createAuthToken(options);
    const correlationId = (options == null ? void 0 : options.correlationId) || createCorrelationId();
    this.logger.info('Reading piece by CID or name "%s" from bucket %s', cidOrName, bucketId);
    const cid = await this.resolveName(bucketId, cidOrName, options);
    const contentStream = await this.fileApi.getFile({
      bucketId,
      token,
      correlationId,
      cid: cid.toBytes(),
      range: options == null ? void 0 : options.range
    });
    const response = new PieceResponse(cid, contentStream, {
      range: options == null ? void 0 : options.range
    });
    this.logger.info('Read piece by CID or name "%s" from bucket %s', cidOrName, bucketId);
    return response;
  }
  /**
   * Retrieves a DAG node from a specific bucket.
   *
   * @param bucketId - The ID of the bucket to retrieve the DAG node from.
   * @param cidOrName - The CID or CNS name of the DAG node to retrieve.
   * @param options - Optional parameters for retrieving the DAG node.
   *
   * @returns A promise that resolves to a DagNodeResponse instance.
   *
   * @example
   *
   * ```typescript
   * const bucketId: bigint = 1n;
   * const cidOrName = '...'; // CID or CNS name of the DAG node
   * const dagNode = await storageNode.getDagNode(bucketId, cidOrName);
   *
   * console.log(dagNode);
   * ```
   */
  async getDagNode(bucketId, cidOrName, options) {
    const token = await this.createAuthToken(options);
    const correlationId = (options == null ? void 0 : options.correlationId) || createCorrelationId();
    this.logger.info('Getting DAG Node by CID or name "%s" from bucket %s', cidOrName, bucketId);
    const cid = await this.resolveName(bucketId, cidOrName, options);
    const node = await this.dagApi.getNode({
      bucketId,
      token,
      correlationId,
      cid: cid.toBytes(),
      path: options == null ? void 0 : options.path
    });
    const response = node && new DagNodeResponse(cid, new Uint8Array(node.data), node.links, node.tags);
    this.logger.info('Got DAG Node by CID or name "%s" from bucket %s', cidOrName, bucketId);
    return response;
  }
  /**
   * Stores a Content Name System (CNS) record in a specific bucket.
   *
   * @param bucketId - The ID of the bucket to store the CNS record in.
   * @param record - The CNS record to store.
   * @param options - Optional parameters for storing the CNS record.
   *
   * @returns A promise that resolves to the CID of the stored CNS record.
   *
   * @example
   *
   * ```typescript
   * const bucketId: bigint = 1n;
   * const record: CnsRecord = new CnsRecord('CID', 'record-name');
   * const recordCid = await storageNode.storeCnsRecord(bucketId, record);
   *
   * console.log(recordCid);
   * ```
   */
  async storeCnsRecord(bucketId, record, options) {
    const token = await this.createAuthToken(options);
    const correlationId = (options == null ? void 0 : options.correlationId) || createCorrelationId();
    this.logger.info('Storing CNS record into bucket %s', bucketId);
    const storredRecord = await this.cnsApi.putRecord({
      bucketId,
      token,
      correlationId,
      record: mapCnsRecordToAPI(record)
    });
    this.logger.info('Stored CNS record into bucket %s', bucketId);
    return storredRecord;
  }
  /**
   * Retrieves a Content Name System (CNS) record from a specific bucket.
   *
   * @param bucketId - The ID of the bucket to retrieve the CNS record from.
   * @param name - The name of the CNS record to retrieve.
   * @param options - Optional parameters for retrieving the CNS record.
   *
   * @returns A promise that resolves to CnsRecordResponse .
   *
   * @example
   *
   * ```typescript
   * const bucketId = 1n;
   * const name = 'record-name';
   * const cnsRecord = await storageNode.getCnsRecord(bucketId, name);
   *
   * console.log(cnsRecord);
   * ```
   */
  async getCnsRecord(bucketId, name, options) {
    const token = await this.createAuthToken(options);
    const {
      cacheControl,
      correlationId = createCorrelationId()
    } = options || {};
    this.logger.info(`Getting CNS record by name "${name}" from bucket ${bucketId}`);
    const record = await this.cnsApi.getRecord({
      bucketId,
      name,
      token,
      correlationId,
      cacheControl
    });
    this.logger.info('Got CNS record by name "%s" from bucket %s', name, bucketId);
    return record && new CnsRecordResponse(record.cid, record.name, record.signature);
  }
  /**
   * Resolves a name to a CID in the Content Name System (CNS).
   *
   * @param name - The CNS name to resolve.
   * @param options - Optional parameters for resolving the name.
   *
   * @returns A promise that resolves to the CID corresponding to the CNS name.
   *
   * @example
   *
   * ```typescript
   * const name: string = 'record-name';
   * const cid = await storageNode.resolveName(name, options);
   *
   * console.log(cid);
   * ```
   */
  async resolveName(bucketId, cidOrName, options) {
    if (Cid.isCid(cidOrName)) {
      return new Cid(cidOrName);
    }
    this.logger.info('Resolving CNS name "%s" from bucket %s', cidOrName, bucketId);
    const record = await this.getCnsRecord(bucketId, cidOrName, options);
    if (!record) {
      throw new Error(`Cannot resolve CNS name: "${cidOrName}"`);
    }
    this.logger.info('Resolved CNS name "%s" from bucket %s to "%s"', cidOrName, bucketId, record.cid);
    return new Cid(record.cid);
  }
}

exports.RouterOperation = void 0;
(function (RouterOperation) {
  RouterOperation["READ_DAG_NODE"] = "read-dag-node";
  RouterOperation["STORE_DAG_NODE"] = "store-dag-node";
  RouterOperation["READ_PIECE"] = "read-piece";
  RouterOperation["STORE_PIECE"] = "store-piece";
  RouterOperation["STORE_CNS_RECORD"] = "store-cns-record";
  RouterOperation["READ_CNS_RECORD"] = "read-cns-record";
})(exports.RouterOperation || (exports.RouterOperation = {}));
class RoutingStrategy {
  constructor(logger) {
    this.logger = void 0;
    this.logger = logger;
  }
}

const isSSLRequired = () => {
  var _globalThis$location;
  return ((_globalThis$location = globalThis.location) == null ? void 0 : _globalThis$location.protocol) === 'https:';
};
class BaseStrategy extends RoutingStrategy {
  async marshalNodes(operation, allNodes) {
    if (!isSSLRequired()) {
      return allNodes;
    }
    return allNodes.filter(node => node.ssl);
  }
}

/**
 * The `priorityMap` defines the priority of the operation for each mode.
 * The lower the number, the higher the priority.
 */
const priorityMap = {
  [exports.RouterOperation.READ_DAG_NODE]: {
    [blockchain.StorageNodeMode.Full]: 1,
    [blockchain.StorageNodeMode.Cache]: 1,
    [blockchain.StorageNodeMode.Storage]: 2
  },
  [exports.RouterOperation.STORE_DAG_NODE]: {
    [blockchain.StorageNodeMode.Full]: 1,
    [blockchain.StorageNodeMode.Storage]: 2,
    [blockchain.StorageNodeMode.Cache]: undefined // Not applicable for the operation
  },
  [exports.RouterOperation.READ_PIECE]: {
    [blockchain.StorageNodeMode.Full]: 1,
    [blockchain.StorageNodeMode.Cache]: 1,
    [blockchain.StorageNodeMode.Storage]: 2
  },
  [exports.RouterOperation.STORE_PIECE]: {
    [blockchain.StorageNodeMode.Full]: 1,
    [blockchain.StorageNodeMode.Storage]: 2,
    [blockchain.StorageNodeMode.Cache]: undefined // Not applicable for the operation
  },
  [exports.RouterOperation.READ_CNS_RECORD]: {
    [blockchain.StorageNodeMode.Full]: 1,
    [blockchain.StorageNodeMode.Cache]: 1,
    [blockchain.StorageNodeMode.Storage]: 2
  },
  [exports.RouterOperation.STORE_CNS_RECORD]: {
    [blockchain.StorageNodeMode.Full]: 1,
    [blockchain.StorageNodeMode.Storage]: 2,
    [blockchain.StorageNodeMode.Cache]: undefined // Not applicable for the operation
  }
};
/**
 * The `NodeTypeStrategy` selects a node based on the operation type and node mode.
 */
class NodeTypeStrategy extends BaseStrategy {
  async marshalNodes(operation, allNodes) {
    const nodes = await super.marshalNodes(operation, allNodes);
    const opertaionPriorityMap = priorityMap[operation];
    const operationNodes = nodes.filter(({
      mode
    }) => opertaionPriorityMap[mode] !== undefined);
    return operationNodes.sort((a, b) => {
      var _ref, _a$priority, _ref2, _b$priority;
      const aPriority = (_ref = (_a$priority = a.priority) != null ? _a$priority : opertaionPriorityMap[a.mode]) != null ? _ref : 0;
      const bPriority = (_ref2 = (_b$priority = b.priority) != null ? _b$priority : opertaionPriorityMap[b.mode]) != null ? _ref2 : 0;
      return aPriority - bPriority;
    });
  }
  selectNode(operation, nodes) {
    return nodes[0]; // select first node from the rundomly shuffled list
  }
}

const shuffle = array => {
  for (let index = array.length - 1; index > 0; index--) {
    const random = Math.floor(Math.random() * (index + 1));
    [array[index], array[random]] = [array[random], array[index]];
  }
  return array;
};

/**
 * The `PingStrategy` selects a node based on the operation type and ping latency.
 */
class PingStrategy extends NodeTypeStrategy {
  constructor(...args) {
    super(...args);
    this.nodesMap = new Map();
  }
  getPingedNodes(state) {
    const pings = Array.from(this.nodesMap.values());
    const foundPings = pings.filter(({
      isDone
    }) => state ? isDone.state === state : isDone.state !== runtimeRpc.DeferredState.REJECTED);
    return foundPings.map(({
      node
    }) => node);
  }
  async ping(record) {
    const start = Date.now();
    const pingUrl = new URL('/info', record.node.httpUrl);
    try {
      const response = await fetch__default["default"](pingUrl, {
        cache: 'no-cache',
        signal: AbortSignal.timeout(PING_ABORT_TIMEOUT)
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} ${response.statusText}`);
      }
    } catch (err) {
      this.logger.debug({
        err
      }, 'Node ping %s failed with error %s', record.node.httpUrl, err);
      throw err;
    }
    record.latency = Date.now() - start;
    this.logger.info('Node ping completed %s with latency %d ms', record.node.httpUrl, record.latency);
    return record;
  }
  enqueuePing(node) {
    const existingPing = this.nodesMap.get(node.httpUrl);
    if (existingPing) {
      return existingPing;
    }
    const isDone = new runtimeRpc.Deferred();
    const pingRecord = {
      node,
      isDone
    };
    this.nodesMap.set(node.httpUrl, pingRecord);
    this.ping(pingRecord).then(() => isDone.resolve(true)).catch(err => isDone.reject(err));
    return isDone.promise;
  }
  async marshalNodes(operation, allNodes) {
    const allNodesShuffled = shuffle([...allNodes]);
    const pingedNodes = await super.marshalNodes(operation, this.getPingedNodes());
    const allOperationNodes = await super.marshalNodes(operation, allNodesShuffled);
    const notPingedNodes = allOperationNodes.filter(node => !this.nodesMap.has(node.httpUrl));
    const toPingSync = notPingedNodes.slice(0, Math.max(0, PING_THRESHOLD - pingedNodes.length));
    const toPingAsync = notPingedNodes.slice(0, PING_THRESHOLD_INC);
    const syncPings = [...pingedNodes,
    // Include already pinged nodes to make sure they are settled
    ...toPingSync].map(node => this.enqueuePing(node));
    /**
     * Wait for all sync pings to complete
     */
    await Promise.allSettled(syncPings);
    /**
     * After a short delay, start async pings in background
     */
    setTimeout(() => toPingAsync.forEach(node => this.enqueuePing(node)), PING_BACKGROUND_DELAY);
    /**
     * Sort opperation nodes by latency
     */
    return allOperationNodes.sort((a, b) => {
      var _this$nodesMap$get, _this$nodesMap$get2;
      const latencyA = (_this$nodesMap$get = this.nodesMap.get(a.httpUrl)) == null ? void 0 : _this$nodesMap$get.latency;
      const latencyB = (_this$nodesMap$get2 = this.nodesMap.get(b.httpUrl)) == null ? void 0 : _this$nodesMap$get2.latency;
      /**
       * Group latency by PING_LATENCY_GROUP ms levels to avaoid sorting by small differences.
       * Keep nodes without ping at the end for fallback scenarios when all pings fail.
       */
      const levelA = latencyA ? Math.ceil(latencyA / PING_LATENCY_GROUP) : Infinity;
      const levelB = latencyB ? Math.ceil(latencyB / PING_LATENCY_GROUP) : Infinity;
      return levelA - levelB;
    });
  }
}

/**
 * The `BlockchainStrategy` retrieves nodes from the blockchain. And appiles the `PingStrategy` + `NodeTypeStrategy` to select the best node.
 */
class BlockchainStrategy extends PingStrategy {
  constructor(logger, {
    blockchain
  }) {
    super(logger);
    this.blockchain = void 0;
    this.bucketCache = new Map();
    this.clusterNodes = new Map();
    this.mapNodeProps = node => {
      const {
        grpcPort,
        host,
        httpPort,
        ssl,
        domain
      } = node.props;
      const httpHost = domain || host;
      const httpUrl = ssl ? `https://${httpHost}` : `http://${httpHost}:${httpPort}`;
      return {
        ssl,
        httpUrl,
        grpcUrl: `grpc://${host}:${grpcPort}`,
        mode: node.props.mode
      };
    };
    this.blockchain = blockchain;
  }
  async isReady() {
    await this.blockchain.isReady();
    return true;
  }
  async getNodes(bucketId) {
    const {
      clusterId
    } = await this.getBucket(bucketId);
    const nodes = await this.getClusterNodes(clusterId);
    this.logger.debug({
      nodes
    }, 'Using nodes from blockchain');
    if (!nodes.length) {
      throw new Error(`No nodes found in the cluster: ${clusterId}`);
    }
    return nodes;
  }
  async getClusterNodes(clusterId) {
    if (this.clusterNodes.has(clusterId)) {
      return this.clusterNodes.get(clusterId);
    }
    /**
     * TODO: Revise the solution and if the blockchain pallet adds a method to fetch nodes with props by clusterId then use it here.
     */
    const allNodes = await this.blockchain.ddcNodes.listStorageNodes();
    const clusterNodes = allNodes.filter(node => node.clusterId === clusterId).map(this.mapNodeProps);
    this.clusterNodes.set(clusterId, clusterNodes);
    return clusterNodes;
  }
  async getBucket(bucketId) {
    if (this.bucketCache.has(bucketId)) {
      return this.bucketCache.get(bucketId);
    }
    const bucket = await this.blockchain.ddcCustomers.getBucket(bucketId);
    if (!bucket) {
      throw new Error(`Failed to get bucket ${bucketId} on blockchain`);
    }
    this.logger.debug({
      bucket
    }, 'Got bucket from blockchain');
    this.bucketCache.set(bucketId, bucket);
    return bucket;
  }
}

class StaticStrategy extends PingStrategy {
  constructor(logger, {
    nodes
  }) {
    super(logger);
    this.nodes = void 0;
    this.nodes = nodes;
  }
  async getNodes(bucketId) {
    return this.nodes;
  }
  async isReady() {
    return true;
  }
}

const getNodeId = node => node.nodeId || node.grpcUrl;
/**
 * The `Router` class provides methods for routing operations to different nodes based on a routing strategy.
 *
 * @internal
 * @example
 *
 * ```typescript
 * const router = new Router({
 *   signer: new UriSigner('...'),
 *   nodes: [...],
 * });
 * ```
 */
class Router {
  constructor({
    signer,
    ...config
  }) {
    this.strategy = void 0;
    this.signer = void 0;
    this.logger = void 0;
    this.sdkTokenPromise = void 0;
    this.logger = createLogger('Router', config);
    this.signer = signer;
    if ('nodes' in config) {
      this.strategy = new StaticStrategy(this.logger, config);
      this.logger.debug({
        strategy: 'static'
      }, 'Router created');
    } else {
      this.strategy = new BlockchainStrategy(this.logger, config);
      this.logger.debug({
        strategy: 'blockchain'
      }, 'Router created');
    }
  }
  /**
   * Returns an SDK token for the current signer
   */
  getSdkToken() {
    this.sdkTokenPromise = Promise.all([this.sdkTokenPromise, this.signer.isReady()]).then(([token]) => token && isValidSdkToken(this.signer, token) ? token : createSdkToken(this.signer));
    return this.sdkTokenPromise;
  }
  /**
   * Retrieves a node for a specific operation in a specific bucket, excluding certain nodes.
   *
   * @param operation - The operation for which to retrieve a node.
   * @param bucketId - The ID of the bucket in which to retrieve a node.
   * @param exclude - An optional array of node IDs to exclude from the retrieval.
   *
   * @returns A promise that resolves to the `StorageNode` selected for the operation.
   *
   * @throws Will throw an error if no nodes are available to handle the operation.
   */
  async getNode(operation, bucketId, config = {}, exclude = []) {
    this.logger.info('Getting node for operation "%s" in bucket %s', operation, bucketId);
    const sdkTokenPromise = this.getSdkToken();
    await this.strategy.isReady();
    const allNodes = await this.strategy.getNodes(bucketId);
    const nodes = allNodes.filter(node => !exclude.includes(getNodeId(node)));
    const finalNodes = await this.strategy.marshalNodes(operation, nodes);
    const node = this.strategy.selectNode(operation, finalNodes);
    if (!node) {
      throw new Error('No nodes available to handle the operation');
    }
    const storageNode = new StorageNode(this.signer, {
      ...node,
      logger: this.logger,
      authToken: await sdkTokenPromise,
      nodeId: node.nodeId || node.grpcUrl,
      ...config
    });
    this.logger.info(`Selected node for operation "%s" in bucket %s: %s`, operation, bucketId, storageNode.displayName);
    this.logger.debug({
      bucketId,
      node
    }, 'Selected node');
    return storageNode;
  }
}

class NodeError extends runtimeRpc.RpcError {
  constructor(...args) {
    super(...args);
    this.correlationId = void 0;
    this.nodeId = void 0;
  }
  static fromRpcError(error) {
    const finalError = new NodeError(error.message, error.code, error.meta);
    finalError.methodName = error.methodName;
    finalError.serviceName = error.serviceName;
    return finalError;
  }
}

const withCorrelationId = options => ({
  ...options,
  correlationId: options.correlationId || createCorrelationId()
});
/**
 * The `BalancedNode` class implements the `NodeInterface` and provides methods for interacting with storage nodes.
 *
 * A balanced node is a node that distributes operations across multiple underlying nodes to balance the load.
 *
 * @group Storage Node
 * @example
 *
 * ```typescript
 * const router = new Router(...);
 * const balancedNode = new BalancedNode({ router });
 * ```
 */
class BalancedNode {
  constructor({
    router,
    ...config
  }) {
    this.nodeId = 'BalancedNode';
    this.displayName = 'BalancedNode';
    this.router = void 0;
    this.logger = void 0;
    this.retryOptions = {
      minTimeout: 50,
      // Starting timeout from which to increase exponentially
      factor: 2,
      // Exponential backoff
      retries: RETRY_MAX_ATTEPTS
    };
    this.router = router;
    this.logger = createLogger('BalancedNode', config);
    if (typeof config.retries === 'number') {
      this.retryOptions.retries = config.retries;
    } else if (config.retries) {
      const {
        attempts = RETRY_MAX_ATTEPTS,
        ...retryOptions
      } = config.retries;
      this.retryOptions = {
        ...this.retryOptions,
        ...retryOptions,
        retries: attempts
      };
    }
    if (config.logErrors !== false) {
      bindErrorLogger(this, this.logger, ['storePiece', 'storeDagNode', 'readPiece', 'getDagNode', 'storeCnsRecord', 'getCnsRecord', 'resolveName']);
    }
  }
  /**
   * Executes a function with automatic retry on failure.
   *
   * @param fn - The function to execute.
   * @param options - Optional parameters for retrying the function.
   *
   * @returns A promise that resolves to the result of the function.
   */
  async withRetry(bucketId, operation, {
    correlationId
  }, body) {
    let lastOperationError;
    let lastRouterError;
    const exclude = [];
    return retry__default["default"](async (bail, attempt) => {
      let node;
      try {
        node = await this.router.getNode(operation, bucketId, {
          logErrors: false
        }, exclude.map(node => node.nodeId));
        exclude.unshift(node);
      } catch (error) {
        /**
         * In case we fail to get a node, we retry with previous nodes that failed until the max attempts.
         */
        node = exclude.pop() || node;
        if (node) {
          this.logger.info(`Reusing previous node for operation "%s" in bucket %s: %s`, operation, bucketId, node.displayName);
        }
        if (error instanceof Error) {
          lastRouterError = error;
        }
      }
      if (!node) {
        var _ref;
        throw (_ref = lastOperationError != null ? lastOperationError : lastRouterError) != null ? _ref : new Error('No nodes available to handle the operation');
      }
      try {
        return await body(node, bail, attempt);
      } catch (error) {
        const nodeError = error instanceof runtimeRpc.RpcError ? NodeError.fromRpcError(error) : undefined;
        if (nodeError) {
          nodeError.nodeId = node.nodeId;
          nodeError.correlationId = correlationId;
          if (RETRYABLE_GRPC_ERROR_CODES.map(status => GrpcStatus[status]).includes(nodeError.code)) {
            lastOperationError = nodeError;
            throw nodeError;
          }
        }
        bail(nodeError || error);
      }
    }, {
      ...this.retryOptions,
      onRetry: (err, attempt) => {
        var _this$retryOptions$on, _this$retryOptions;
        (_this$retryOptions$on = (_this$retryOptions = this.retryOptions).onRetry) == null || _this$retryOptions$on.call(_this$retryOptions, err, attempt);
        this.logger.warn({
          err,
          attempt
        }, 'Retrying operation');
      }
    });
  }
  async storePiece(bucketId, piece, storeOptions = {}) {
    const options = withCorrelationId(storeOptions);
    return this.withRetry(bucketId, exports.RouterOperation.STORE_PIECE, options, (node, bail, attempt) =>
    /**
     * Clone the piece if it is a piece and this is not the first attempt.
     * This is done to avoid reusing the same stream multiple times.
     */
    node.storePiece(bucketId, Piece.isPiece(piece) && attempt > 0 ? Piece.from(piece) : piece, options));
  }
  async readPiece(bucketId, cidOrName, readOptions = {}) {
    const options = withCorrelationId(readOptions);
    return this.withRetry(bucketId, exports.RouterOperation.READ_PIECE, options, node => node.readPiece(bucketId, cidOrName, options));
  }
  async storeDagNode(bucketId, dagNode, storeOptions = {}) {
    const options = withCorrelationId(storeOptions);
    return this.withRetry(bucketId, exports.RouterOperation.STORE_DAG_NODE, options, node => node.storeDagNode(bucketId, dagNode, options));
  }
  async getDagNode(bucketId, cidOrName, getOptions = {}) {
    const options = withCorrelationId(getOptions);
    return this.withRetry(bucketId, exports.RouterOperation.READ_DAG_NODE, options, node => node.getDagNode(bucketId, cidOrName, options));
  }
  async storeCnsRecord(bucketId, record, storeOptions = {}) {
    const options = withCorrelationId(storeOptions);
    return this.withRetry(bucketId, exports.RouterOperation.STORE_CNS_RECORD, options, node => node.storeCnsRecord(bucketId, record, options));
  }
  async getCnsRecord(bucketId, name, getOptions = {}) {
    const options = withCorrelationId(getOptions);
    return this.withRetry(bucketId, exports.RouterOperation.READ_CNS_RECORD, options, node => node.getCnsRecord(bucketId, name, options));
  }
  async resolveName(bucketId, cidOrName, resolveOptions = {}) {
    const options = withCorrelationId(resolveOptions);
    return this.withRetry(bucketId, exports.RouterOperation.READ_CNS_RECORD, options, node => node.resolveName(bucketId, cidOrName, options));
  }
}

/**
 * DDC mainnet configuration preset
 *
 * @hidden
 */
const MAINNET = {
  blockchain: 'wss://rpc.mainnet.cere.network/ws'
};
/**
 * DDC testnet configuration preset
 *
 * @hidden
 */
const TESTNET = {
  blockchain: 'wss://rpc.testnet.cere.network/ws'
};
/**
 * DDC devnet configuration preset
 *
 * @hidden
 */
const DEVNET = {
  blockchain: 'wss://archive.devnet.cere.network/ws'
};
const DEFAULT_PRESET = TESTNET;
/**
 * Static DEVNET preset
 *
 * TODO: Remove after full migration to on-chain topology
 *
 * @deprecated Use `DEVNET` instead
 * @ignore
 */
const DEVNET_STATIC = {
  blockchain: 'wss://archive.devnet.cere.network/ws',
  nodes: [{
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://38.242.236.247:9090',
    httpUrl: 'https://storage-1.devnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://38.242.236.247:9091',
    httpUrl: 'https://storage-2.devnet.cere.network'
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://158.220.87.61:9090',
    httpUrl: 'https://storage-3.devnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://158.220.87.61:9091',
    httpUrl: 'https://storage-4.devnet.cere.network'
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://89.117.79.111:9090',
    httpUrl: 'https://storage-5.devnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://89.117.79.111:9091',
    httpUrl: 'https://storage-6.devnet.cere.network'
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://154.53.57.124:9090',
    httpUrl: 'https://storage-7.devnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://154.53.57.124:9091',
    httpUrl: 'https://storage-8.devnet.cere.network'
  }]
};
/**
 * Static TESTENT preset
 *
 * TODO: Remove after full migration to on-chain topology
 *
 * @deprecated Use `TESTNET` instead
 * @ignore
 */
const TESTNET_STATIC = {
  blockchain: 'wss://rpc.testnet.cere.network/ws',
  nodes: [{
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://128.140.103.37:9090',
    httpUrl: 'https://storage-1.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.55.218.0:9090',
    httpUrl: 'https://storage-2.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://94.130.27.127:9090',
    httpUrl: 'https://storage-3.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://157.90.226.137:9090',
    httpUrl: 'https://storage-4.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://116.203.211.74:9090',
    httpUrl: 'https://storage-5.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://116.203.188.159:9090',
    httpUrl: 'https://storage-6.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://66.135.3.185:9090',
    httpUrl: 'https://storage-7.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://207.246.92.234:9090',
    httpUrl: 'https://storage-8.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://116.203.153.145:9090',
    httpUrl: 'https://storage-9.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://94.130.183.14:9090',
    httpUrl: 'https://storage-10.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://78.47.189.200:9090',
    httpUrl: 'https://storage-11.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://116.203.83.55:9090',
    httpUrl: 'https://storage-12.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://95.217.155.6:9090',
    httpUrl: 'https://storage-13.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.108.154.151:9090',
    httpUrl: 'https://storage-14.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://37.27.18.247:9090',
    httpUrl: 'https://storage-15.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.109.138.28:9090',
    httpUrl: 'https://storage-16.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.158.22:9090',
    httpUrl: 'https://storage-17.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.154.25:9090',
    httpUrl: 'https://storage-18.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.154.242:9090',
    httpUrl: 'https://storage-19.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.154.168:9090',
    httpUrl: 'https://storage-20.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.157.36:9090',
    httpUrl: 'https://storage-21.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.157.4:9090',
    httpUrl: 'https://storage-22.testnet.cere.network',
    ssl: false
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.154.45:9090',
    httpUrl: 'https://storage-23.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://162.212.157.254:9090',
    httpUrl: 'https://storage-24.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://38.242.148.54:9090',
    httpUrl: 'https://storage-25.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://38.242.148.67:9090',
    httpUrl: 'https://storage-26.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://38.242.148.78:9090',
    httpUrl: 'https://storage-27.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://154.12.245.135:9090',
    httpUrl: 'https://storage-28.testnet.cere.network',
    ssl: false
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://154.12.245.139:9090',
    httpUrl: 'https://storage-29.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://154.12.245.141:9090',
    httpUrl: 'https://storage-30.testnet.cere.network',
    ssl: false
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://31.220.96.197:9090',
    httpUrl: 'https://storage-31.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Storage,
    grpcUrl: 'grpc://31.220.96.198:9090',
    httpUrl: 'https://storage-32.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://37.27.26.9:9090',
    httpUrl: 'https://storage-33.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://37.27.15.104:9090',
    httpUrl: 'https://storage-34.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.108.244.154:9090',
    httpUrl: 'https://storage-35.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.21.111.73:9090',
    httpUrl: 'https://storage-36.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://135.181.80.135:9090',
    httpUrl: 'https://storage-37.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.109.174.181:9090',
    httpUrl: 'https://storage-38.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.109.227.87:9090',
    httpUrl: 'https://storage-39.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.108.211.60:9090',
    httpUrl: 'https://storage-40.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://78.47.122.10:9090',
    httpUrl: 'https://storage-41.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://128.140.97.160:9090',
    httpUrl: 'https://storage-42.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://49.13.23.245:9090',
    httpUrl: 'https://storage-43.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://167.235.231.47:9090',
    httpUrl: 'https://storage-44.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.21.54.218:9090',
    httpUrl: 'https://storage-45.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://37.27.15.137:9090',
    httpUrl: 'https://storage-46.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://95.216.139.48:9090',
    httpUrl: 'https://storage-47.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://95.217.167.158:9090',
    httpUrl: 'https://storage-48.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://149.248.2.7:9090',
    httpUrl: 'https://storage-49.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://140.82.50.92:9090',
    httpUrl: 'https://storage-50.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://149.28.111.44:9090',
    httpUrl: 'https://storage-51.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://66.135.30.145:9090',
    httpUrl: 'https://storage-52.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://45.63.65.67:9090',
    httpUrl: 'https://storage-53.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://137.220.57.81:9090',
    httpUrl: 'https://storage-54.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://207.148.2.17:9090',
    httpUrl: 'https://storage-55.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://149.28.242.196:9090',
    httpUrl: 'https://storage-56.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://64.176.183.175:9090',
    httpUrl: 'https://storage-57.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://45.76.131.46:9090',
    httpUrl: 'https://storage-58.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://108.61.198.218:9090',
    httpUrl: 'https://storage-59.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://80.240.22.212:9090',
    httpUrl: 'https://storage-60.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://107.191.63.179:9090',
    httpUrl: 'https://storage-61.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.20.100.39:9090',
    httpUrl: 'https://storage-62.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://65.20.112.89:9090',
    httpUrl: 'https://storage-63.testnet.cere.network',
    ssl: true
  }, {
    mode: blockchain.StorageNodeMode.Full,
    grpcUrl: 'grpc://64.176.67.225:9090',
    httpUrl: 'https://storage-64.testnet.cere.network',
    ssl: true
  }]
};

Object.defineProperty(exports, 'CereWalletSigner', {
  enumerable: true,
  get: function () { return blockchain.CereWalletSigner; }
});
Object.defineProperty(exports, 'JsonSigner', {
  enumerable: true,
  get: function () { return blockchain.JsonSigner; }
});
Object.defineProperty(exports, 'KeyringSigner', {
  enumerable: true,
  get: function () { return blockchain.KeyringSigner; }
});
Object.defineProperty(exports, 'StorageNodeMode', {
  enumerable: true,
  get: function () { return blockchain.StorageNodeMode; }
});
Object.defineProperty(exports, 'UriSigner', {
  enumerable: true,
  get: function () { return blockchain.UriSigner; }
});
exports.ActivityAcknowledgment = ActivityAcknowledgment;
exports.ActivityRequest = ActivityRequest;
exports.AuthToken = AuthToken;
exports.BalancedNode = BalancedNode;
exports.Cid = Cid;
exports.CnsApi = CnsApi;
exports.CnsRecord = CnsRecord;
exports.CnsRecordResponse = CnsRecordResponse;
exports.DEFAULT_PRESET = DEFAULT_PRESET;
exports.DEVNET = DEVNET;
exports.DEVNET_STATIC = DEVNET_STATIC;
exports.DagApi = DagApi;
exports.DagNode = DagNode;
exports.DagNodeResponse = DagNodeResponse;
exports.FileApi = FileApi;
exports.GrpcTransport = GrpcTransport;
exports.KB = KB;
exports.Link = Link;
exports.MAINNET = MAINNET;
exports.MAX_PIECE_SIZE = MAX_PIECE_SIZE;
exports.MB = MB;
exports.MIN_PIECE_SIZE = MIN_PIECE_SIZE;
exports.MultipartPiece = MultipartPiece;
exports.NodeError = NodeError;
exports.Piece = Piece;
exports.PieceResponse = PieceResponse;
exports.Router = Router;
exports.StorageNode = StorageNode;
exports.TESTNET = TESTNET;
exports.TESTNET_STATIC = TESTNET_STATIC;
exports.Tag = Tag;
exports.WebsocketTransport = WebsocketTransport;
exports.bindErrorLogger = bindErrorLogger;
exports.createContentStream = createContentStream;
exports.createCorrelationId = createCorrelationId;
exports.createLogger = createLogger;
exports.isContentStream = isContentStream;
exports.streamConsumers = consumers;
exports.withChunkSize = withChunkSize;
//# sourceMappingURL=index.cjs.map
