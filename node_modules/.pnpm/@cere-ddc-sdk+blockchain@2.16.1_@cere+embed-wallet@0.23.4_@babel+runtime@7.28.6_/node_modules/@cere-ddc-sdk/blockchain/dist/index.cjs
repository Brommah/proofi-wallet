var api = require('@polkadot/api');
var util = require('@polkadot/util');
var keyring = require('@polkadot/keyring');
var cryptoUtil = require('@polkadot/util-crypto');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return n;
}

var cryptoUtil__namespace = /*#__PURE__*/_interopNamespace(cryptoUtil);

exports.ClusterStatus = void 0;
(function (ClusterStatus) {
  ClusterStatus["Unbonded"] = "Unbonded";
  ClusterStatus["Bonded"] = "Bonded";
  ClusterStatus["Activated"] = "Activated";
  ClusterStatus["Unbonding"] = "Unbonding";
})(exports.ClusterStatus || (exports.ClusterStatus = {}));
exports.ClusterMember = void 0;
(function (ClusterMember) {
  ClusterMember["ClusterManager"] = "ClusterManager";
  ClusterMember["NodeProvider"] = "NodeProvider";
})(exports.ClusterMember || (exports.ClusterMember = {}));
exports.StorageNodeMode = void 0;
(function (StorageNodeMode) {
  StorageNodeMode["Full"] = "Full";
  StorageNodeMode["Storage"] = "Storage";
  StorageNodeMode["Cache"] = "Cache";
})(exports.StorageNodeMode || (exports.StorageNodeMode = {}));
exports.ClusterNodeKind = void 0;
(function (ClusterNodeKind) {
  ClusterNodeKind["Genesis"] = "Genesis";
  ClusterNodeKind["External"] = "External";
})(exports.ClusterNodeKind || (exports.ClusterNodeKind = {}));

/**
 * This abstract class provides a blueprint for creating different types of signers.
 *
 * @group Signers
 * @example
 *
 * ```typescript
 * class MySigner extends Signer {
 *   // Implement abstract properties and methods...
 * }
 *
 * const mySigner = new MySigner();
 * const isReady = await mySigner.isReady();
 * console.log(isReady);
 * ```
 */
class Signer {
  /**
   * Unlocks the signer with a passphrase.
   *
   * @param passphrase - The passphrase to unlock the signer.
   */
  async unlock(passphrase) {}
  /**
   * Checks if an object is a signer.
   *
   * @param signer - The object to check.
   * @returns A boolean indicating whether the object is a signer.
   */
  static isSigner(signer) {
    if (!signer || typeof signer !== 'object') {
      return false;
    }
    return signer instanceof Signer || 'isReady' in signer && 'sign' in signer && 'getSigner' in signer;
  }
}

const CERE_SS58_PREFIX = 54;

/**
 * Signer that uses a keyring pair to sign data.
 *
 * @group Signers
 * @extends Signer
 * @example
 *
 * ```typescript
 * const pair = new Keyring().addFromUri('//Alice');
 * const keyringSigner = new KeyringSigner(pair);
 * const signature = await keyringSigner.sign('data');
 *
 * console.log(signature);
 * ```
 */
class KeyringSigner extends Signer {
  constructor(pair) {
    super();
    this.pair = void 0;
    this.pair = pair;
    this.isReady();
  }
  get isLocked() {
    if (!this.pair) {
      throw new Error('Key pair is not ready!');
    }
    return this.pair.isLocked;
  }
  async unlock(passphrase) {
    await this.isReady();
    if (!this.pair) {
      throw new Error('Key pair is not ready!');
    }
    if (this.pair.isLocked) {
      this.pair.unlock(passphrase);
    }
  }
  createPair() {
    if (!this.pair) {
      throw new Error('Key pair is not provided!');
    }
    return this.pair;
  }
  async isReady() {
    if (this.pair) {
      return true;
    }
    const isCryptoReady = await cryptoUtil.cryptoWaitReady();
    if (!isCryptoReady) {
      return false;
    }
    this.pair = this.createPair();
    return true;
  }
  getPair() {
    if (this.pair) {
      return this.pair;
    }
    throw new Error('Signer is not ready');
  }
  get type() {
    return this.getPair().type;
  }
  get address() {
    return this.getPair().address;
  }
  get publicKey() {
    return this.getPair().publicKey;
  }
  async sign(data) {
    return this.getPair().sign(data);
  }
  async getSigner() {
    return {
      signRaw: async ({
        data
      }) => {
        const signature = this.getPair().sign(data, {
          withType: true
        });
        return {
          id: 0,
          signature: util.u8aToHex(signature)
        };
      }
    };
  }
}

/**
 * Signer that uses a Substrate URI to create a keypair.
 *
 * @group Signers
 * @extends Signer
 * @example
 *
 * ```typescript
 * const uriSigner = new UriSigner('//Alice', );
 * const signature = await uriSigner.sign('data');
 *
 * console.log(signature);
 * ```
 */
class UriSigner extends KeyringSigner {
  constructor(uri, options = {}) {
    super();
    this.uri = void 0;
    this.options = void 0;
    this.uri = uri;
    this.options = options;
  }
  createPair() {
    return new keyring.Keyring({
      ss58Format: CERE_SS58_PREFIX,
      type: this.type
    }).addFromUri(this.uri);
  }
  get type() {
    return this.options.type || 'sr25519';
  }
  static async create(uri, options = {}) {
    const signer = new UriSigner(uri, options);
    await signer.isReady();
    return signer;
  }
}

// @ts-ignore
class Web3Signer extends Signer {
  constructor() {
    super();
    throw new Error('Web3Signer in not supported in NodeJS environment');
  }
}

// @ts-ignore
class CereWalletSigner extends Signer {
  constructor() {
    super();
    throw new Error('CereWalletSigner in not supported in NodeJS environment');
  }
}

/**
 * Signer that uses a JSON object to create a keypair.
 *
 * @group Signers
 * @extends Signer
 * @example
 *
 * ```typescript
 * const accountDataJson = {}; // Exported from Cere Wallet or other wallets
 * const jsonSigner = new JsonSigner(accountDataJson, { passphrase: '1234' });
 * const signature = await jsonSigner.sign('data');
 *
 * console.log(signature);
 * ```
 */
class JsonSigner extends KeyringSigner {
  constructor(account, options = {}) {
    super();
    this.account = void 0;
    this.options = void 0;
    this.account = account;
    this.options = options;
  }
  createPair() {
    const keyPair = new keyring.Keyring({
      ss58Format: CERE_SS58_PREFIX
    }).addFromJson(this.account);
    if (this.options.passphrase) {
      keyPair.unlock(this.options.passphrase);
    }
    return keyPair;
  }
  static async create(account) {
    const signer = new JsonSigner(account);
    await signer.isReady();
    return signer;
  }
}

/**
 * This class provides methods to interact with the DDC Nodes pallet on the blockchain.
 *
 * @group Pallets
 * @example
 *
 * ```typescript
 * const storageNodePublicKey = '0x...';
 * const storageNode = await blockchain.ddcNodes.findStorageNodeByPublicKey(storageNodePublicKey);
 *
 * console.log(storageNode);
 * ```
 */
class DDCNodesPallet {
  constructor(apiPromise) {
    this.apiPromise = void 0;
    this.apiPromise = apiPromise;
  }
  /**
   * Creates a new storage node.
   *
   * @param storageNodePublicKey - The public key of the storage node.
   * @param storageNodeProps - The properties of the storage node.
   * @returns An extrinsic to create the storage node.
   *
   * @example
   *
   * ```typescript
   * const storageNodePublicKey = '0x...';
   * const storageNodeProps = { ... };
   * const tx = blockchain.ddcNodes.createStorageNode(storageNodePublicKey, storageNodeProps);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  createStorageNode(storageNodePublicKey, storageNodeProps) {
    const defaultProps = {
      domain: '',
      ssl: false
    };
    return this.apiPromise.tx.ddcNodes.createNode({
      StoragePubKey: storageNodePublicKey
    }, {
      StorageParams: encodeNodeProps({
        ...defaultProps,
        ...storageNodeProps
      })
    });
  }
  /**
   * Finds a storage node by public key.
   *
   * @param storageNodePublicKey - The public key of the storage node.
   * @returns A promise that resolves to the storage node.
   *
   * @example
   *
   * ```typescript
   * const storageNodePublicKey = '0x...';
   * const storageNode = await blockchain.ddcNodes.findStorageNodeByPublicKey(storageNodePublicKey);
   *
   * console.log(storageNode);
   * ```
   */
  async findStorageNodeByPublicKey(storageNodePublicKey) {
    const result = await this.apiPromise.query.ddcNodes.storageNodes(storageNodePublicKey);
    const storageNode = result.toJSON();
    return storageNode == null ? undefined : {
      ...storageNode,
      props: decodeNodeProps(storageNode.props)
    };
  }
  /**
   * Returns a list of storage nodes.
   *
   * @returns A promise that resolves to a list of storage nodes.
   *
   * @example
   *
   * ```typescript
   * const storageNodes = await blockchain.ddcNodes.listStorageNodes();
   *
   * console.log(storageNodes);
   * ```
   */
  async listStorageNodes() {
    const result = await this.apiPromise.query.ddcNodes.storageNodes.entries();
    return result.map(([, storageNodeOption]) => {
      const storageNode = storageNodeOption.toJSON();
      return storageNode == null ? undefined : {
        ...storageNode,
        props: decodeNodeProps(storageNode.props)
      };
    }).filter(storageNode => storageNode != null);
  }
  /**
   * Sets the properties of a storage node.
   *
   * @param storageNodePublicKey - The public key of the storage node.
   * @param storageNodeProps - The properties of the storage node.
   * @returns An extrinsic to set the storage node properties.
   *
   * @example
   *
   * ```typescript
   * const storageNodePublicKey = '0x...';
   * const storageNodeProps = { ... };
   * const tx = blockchain.ddcNodes.setStorageNodeProps(storageNodePublicKey, storageNodeProps);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  setStorageNodeProps(storageNodePublicKey, storageNodeProps) {
    return this.apiPromise.tx.ddcNodes.setNodeParams({
      StoragePubKey: storageNodePublicKey
    }, {
      StorageParams: encodeNodeProps(storageNodeProps)
    });
  }
  /**
   * Deletes a storage node.
   *
   * @param storageNodePublicKey - The public key of the storage node.
   * @returns An extrinsic to delete the storage node.
   *
   * @example
   *
   * ```typescript
   * const storageNodePublicKey = '0x...';
   * const tx = blockchain.ddcNodes.deleteStorageNode(storageNodePublicKey);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  deleteStorageNode(storageNodePublicKey) {
    return this.apiPromise.tx.ddcNodes.deleteNode({
      StoragePubKey: storageNodePublicKey
    });
  }
}
function decodeNodeProps(nodeProps) {
  return {
    ...nodeProps,
    host: util.hexToString(nodeProps.host),
    domain: util.hexToString(nodeProps.domain)
  };
}
function encodeNodeProps(nodeProps) {
  return {
    ...nodeProps,
    host: util.stringToHex(nodeProps.host),
    domain: util.stringToHex(nodeProps.domain)
  };
}

/**
 * This class provides methods to interact with the DDC Clusters pallet on the blockchain.
 *
 * @group Pallets
 * @example
 *
 * ```typescript
 * const clusters = await blockchain.ddcClusters.listClusters();
 *
 * console.log(clusters);
 * ```
 */
class DDCClustersPallet {
  constructor(apiPromise) {
    this.apiPromise = void 0;
    this.apiPromise = apiPromise;
  }
  /**
   * Lists all clusters.
   *
   * @returns A promise that resolves to an array of clusters.
   *
   * @example
   *
   * ```typescript
   * const clusters = await blockchain.ddcClustersPallet.listClusters();
   *
   * console.log(clusters);
   * ```
   */
  async listClusters() {
    var _this$apiPromise$quer;
    const entries = (await ((_this$apiPromise$quer = this.apiPromise.query.ddcClusters) == null ? void 0 : _this$apiPromise$quer.clusters.entries())) || [];
    return entries.map(([, clusterOption]) => clusterOption.toJSON());
  }
  /**
   * Filters node keys by cluster ID.
   *
   * @param clusterId - The ID of the cluster.
   * @returns A promise that resolves to an array of node keys.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const nodeKeys = await blockchain.ddcClustersPallet.filterNodeKeysByClusterId(clusterId);
   *
   * console.log(nodeKeys);
   * ```
   */
  async filterNodeKeysByClusterId(clusterId) {
    const entries = await this.apiPromise.query.ddcClusters.clustersNodes.entries(clusterId);
    return entries.map(([key]) => key.args[1].asStoragePubKey.toJSON());
  }
  /**
   * Checks if a cluster has a storage node.
   *
   * @param clusterId - The ID of the cluster.
   * @param storageNodePublicKey - The public key of the storage node.
   * @returns A promise that resolves to a boolean indicating whether the cluster has the storage node.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const storageNodePublicKey = '0x...';
   * const hasStorageNode = await blockchain.ddcClustersPallet.clusterHasStorageNode(clusterId, storageNodePublicKey);
   *
   * console.log(hasStorageNode);
   * ```
   */
  async clusterHasStorageNode(clusterId, storageNodePublicKey) {
    const result = await this.apiPromise.query.ddcClusters.clustersNodes(clusterId, {
      StoragePubKey: storageNodePublicKey
    });
    return !result.isEmpty;
  }
  /**
   * Creates a new cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param clusterManagerId - The ID of the cluster manager.
   * @param clusterReserveId - The ID of the cluster reserve.
   * @param clusterParams - The properties of the cluster.
   * @param clusterGovernmentParams - The government parameters of the cluster.
   * @returns An extrinsic to create the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const clusterReserveId = '0x...';
   * const clusterParams = { ... };
   * const clusterGovernmentParams = { ... };
   *
   * const tx = blockchain.ddcClustersPallet.createCluster(
   *   clusterId,
   *   clusterReserveId,
   *   clusterParams,
   *   clusterGovernmentParams
   * );
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  createCluster(clusterId, clusterReserveId, clusterParams, clusterGovernmentParams) {
    const clusterParamsDefaults = {
      nodeProviderAuthContract: null,
      erasureCodingRequired: 16,
      erasureCodingTotal: 48,
      replicationTotal: 20
    };
    return this.apiPromise.tx.ddcClusters.createCluster(clusterId, clusterReserveId, {
      ...clusterParamsDefaults,
      ...clusterParams
    }, clusterGovernmentParams);
  }
  /**
   * Finds a cluster by ID.
   *
   * @param clusterId - The ID of the cluster.
   * @returns A promise that resolves to the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const cluster = await blockchain.ddcClustersPallet.findClusterById(clusterId);
   *
   * console.log(cluster);
   * ```
   */
  async findClusterById(clusterId) {
    const result = await this.apiPromise.query.ddcClusters.clusters(clusterId);
    return result.toJSON();
  }
  /**
   * Sets the properties of a cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param clusterParams - The properties of the cluster.
   * @returns An extrinsic to set the cluster properties.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const clusterParams = { ... };
   *
   * const tx = blockchain.ddcClustersPallet.setClusterParams(clusterId, clusterParams);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  setClusterParams(clusterId, clusterParams) {
    return this.apiPromise.tx.ddcClusters.setClusterParams(clusterId, clusterParams);
  }
  /**
   * Adds a storage node to a cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param storageNodePublicKey - The public key of the storage node.
   * @returns An extrinsic to add the storage node to the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const storageNodePublicKey = '0x...';
   *
   * const tx = blockchain.ddcClustersPallet.addStorageNodeToCluster(clusterId, storageNodePublicKey, ClusterNodeKind.Genesis);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  addStorageNodeToCluster(clusterId, storageNodePublicKey, nodeKind) {
    return this.apiPromise.tx.ddcClusters.addNode(clusterId, {
      StoragePubKey: storageNodePublicKey
    }, nodeKind);
  }
  /**
   * Removes a storage node from a cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param storageNodePublicKey - The public key of the storage node.
   * @returns An extrinsic to remove the storage node from the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const storageNodePublicKey = '0x...';
   *
   * const tx = blockchain.ddcClustersPallet.removeStorageNodeFromCluster(clusterId, storageNodePublicKey);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  removeStorageNodeFromCluster(clusterId, storageNodePublicKey) {
    return this.apiPromise.tx.ddcClusters.removeNode(clusterId, {
      StoragePubKey: storageNodePublicKey
    });
  }
  /**
   * Gets the government parameters of a cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @returns A promise that resolves to the government parameters of the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const clusterGovernmentParams = await blockchain.ddcClustersPallet.getClusterGovernmentParams(clusterId);
   *
   * console.log(clusterGovernmentParams);
   * ```
   */
  async getClusterGovernmentParams(clusterId) {
    const result = await this.apiPromise.query.ddcClusters.clustersGovParams(clusterId);
    return result.toJSON();
  }
}

/**
 * This class provides methods to interact with the DDC Staking pallet on the blockchain.
 *
 * @group Pallets
 * @example
 *
 * ```typescript
 * const storageNodePublicKey = '0x...';
 * const stashAccountId = await blockchain.ddcStaking.findStashAccountIdByStorageNodePublicKey(storageNodePublicKey);
 *
 * console.log(stashAccountId);
 * ```
 */
class DDCStakingPallet {
  constructor(apiPromise) {
    this.apiPromise = void 0;
    this.apiPromise = apiPromise;
  }
  /**
   * Binds the storage node.
   *
   * @param controller - The account that will control the storage node.
   * @param storageNodePublicKey - The public key of the storage node.
   * @param bondAmount - The amount to bond.
   * @returns An extrinsic to bind the storage node.
   *
   * @example
   *
   * ```typescript
   * const controller = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
   * const storageNodePublicKey = '0x...';
   * const bondAmount = 100n;
   * const tx = blockchain.ddcStaking.bondStorageNode(controller, storageNodePublicKey, bondAmount);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  bondStorageNode(controller, storageNodePublicKey, bondAmount) {
    return this.apiPromise.tx.ddcStaking.bond(controller, {
      StoragePubKey: storageNodePublicKey
    }, bondAmount);
  }
  /**
   * Chills the controller.
   *
   * @returns An extrinsic to chill the controller.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcStaking.chill();
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  chill() {
    return this.apiPromise.tx.ddcStaking.chill();
  }
  /**
   * Initiates a fast chill of storage.
   *
   * @returns An extrinsic to initiate a fast chill of storage.
   *
   * Example usage:
   * ```typescript
   * const tx = blockchain.ddcStaking.fastChillStorage();
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  fastChillStorage() {
    return this.apiPromise.tx.ddcStaking.fastChill();
  }
  /**
   * Unbonds the amount.
   *
   * @param amount - The amount to unbond.
   * @returns An extrinsic to unbond the amount.
   *
   * @example
   *
   * ```typescript
   * const amount = 100n;
   * const tx = blockchain.ddcStaking.unbond(amount);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  unbond(amount) {
    return this.apiPromise.tx.ddcStaking.unbond(amount);
  }
  /**
   * Withdraws unbonded funds.
   *
   * @returns An extrinsic to withdraw unbonded funds.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcStaking.withdrawUnbonded();
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  withdrawUnbonded() {
    return this.apiPromise.tx.ddcStaking.withdrawUnbonded();
  }
  /**
   * Finds the stash account ID associated with a given storage node public key.
   *
   * @param storageNodePublicKey - The public key of the storage node.
   * @returns A promise that resolves to the stash account ID, or undefined if no stash account is found.
   *
   * @example
   *
   * ```typescript
   * const storageNodePublicKey = '0x...';
   * const stashAccountId = await blockchain.ddcStaking.findStashAccountIdByStorageNodePublicKey(storageNodePublicKey);
   *
   * console.log(stashAccountId);
   * ```
   */
  async findStashAccountIdByStorageNodePublicKey(storageNodePublicKey) {
    const result = await this.apiPromise.query.ddcStaking.nodes({
      StoragePubKey: storageNodePublicKey
    });
    return result.toJSON();
  }
  /**
   * Returns the list of staked storage nodes, their stash accounts, and their cluster IDs.
   *
   * @returns A promise that resolves to the list of staked storage nodes, their stash accounts, and their cluster IDs.
   *
   * @example
   *
   * ```typescript
   * const stakedStorageNodes = await blockchain.ddcStaking.listStakedStorageNodesStashAccountsAndClusterIds();
   *
   * console.log(stakedStorageNodes);
   * ```
   */
  async listStakedStorageNodesStashAccountsAndClusterIds() {
    const result = await this.apiPromise.query.ddcStaking.storages.entries();
    return result.map(([key, clusterId]) => ({
      stashAccountId: key.args[0].toJSON(),
      clusterId: clusterId.toJSON()
    }));
  }
  /**
   * Finds the cluster ID associated with a given CDN node stash account ID.
   *
   * @param stashAccountId - The stash account ID of the CDN node.
   * @returns A promise that resolves to the cluster ID, or undefined if no cluster is found.
   *
   * @example
   *
   * ```typescript
   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
   * const clusterId = await blockchain.ddcStaking.findStakedClusterIdByCdnNodeStashAccountId(stashAccountId);
   *
   * console.log(clusterId);
   * ```
   */
  async findStakedClusterIdByCdnNodeStashAccountId(stashAccountId) {
    const result = await this.apiPromise.query.ddcStaking.cdNs(stashAccountId);
    return result.toJSON();
  }
  /**
   * Returns the list of staked CDN nodes, their stash accounts, and their cluster IDs.
   *
   * @returns A promise that resolves to the list of staked CDN nodes, their stash accounts, and their cluster IDs.
   *
   * @example
   *
   * ```typescript
   * const stakedCdnNodes = await blockchain.ddcStaking.listStakedCdnNodesStashAccountsAndClusterIds();
   *
   * console.log(stakedCdnNodes);
   * ```
   */
  async listStakedCdnNodesStashAccountsAndClusterIds() {
    const result = await this.apiPromise.query.ddcStaking.cdNs.entries();
    return result.map(([key, clusterId]) => ({
      stashAccountId: key.args[0].toJSON(),
      clusterId: clusterId.toJSON()
    }));
  }
  /**
   * Finds the cluster ID associated with a given storage node stash account ID.
   *
   * @param stashAccountId - The stash account ID of the storage node.
   * @returns A promise that resolves to the cluster ID, or undefined if no cluster is found.
   *
   * @example
   *
   * ```typescript
   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
   * const clusterId = await blockchain.ddcStaking.findStakedClusterIdByStorageNodeStashAccountId(stashAccountId);
   *
   * console.log(clusterId);
   * ```
   */
  async findStakedClusterIdByStorageNodeStashAccountId(stashAccountId) {
    const result = await this.apiPromise.query.ddcStaking.storages(stashAccountId);
    return result.toJSON();
  }
  /**
   * Sets the controller account for the stash account.
   *
   * @param accountId - The account ID of the new controller.
   * @returns An extrinsic to set the controller account.
   *
   * @example
   *
   * ```typescript
   * const newControllerAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
   * const tx = blockchain.ddcStaking.setController(newControllerAccountId);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  setController(accountId) {
    return this.apiPromise.tx.ddcStaking.setController(accountId);
  }
  /**
   * Sets the storage node for the stash account.
   *
   * @param storageNodePublicKey - The public key of the storage node.
   * @returns An extrinsic to set the storage node.
   *
   * @example
   *
   * ```typescript
   * const storageNodePublicKey = '0x...';
   * const tx = blockchain.ddcStaking.setStorageNode(storageNodePublicKey);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  setStorageNode(storageNodePublicKey) {
    return this.apiPromise.tx.ddcStaking.setNode({
      StoragePubKey: storageNodePublicKey
    });
  }
  /**
   * Stores the cluster ID.
   *
   * @param clusterId - The ID of the cluster.
   * @returns An extrinsic to store the cluster ID.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const tx = blockchain.ddcStaking.store(clusterId);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  store(clusterId) {
    return this.apiPromise.tx.ddcStaking.store(clusterId);
  }
  /**
   * Serves the cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @returns An extrinsic to serve the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const tx = blockchain.ddcStaking.serve(clusterId);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  serve(clusterId) {
    return this.apiPromise.tx.ddcStaking.serve(clusterId);
  }
  /**
   * Finds the staking ledger associated with a given controller account ID.
   *
   * @param controllerAccountId - The account ID of the controller.
   * @returns A promise that resolves to the staking ledger, or undefined if no staking ledger is found.
   *
   * @example
   *
   * ```typescript
   * const controllerAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
   * const stakingLedger = await blockchain.ddcStaking.findStakingLedgerByControllerAccountId(controllerAccountId);
   *
   * console.log(stakingLedger);
   * ```
   */
  async findStakingLedgerByControllerAccountId(controllerAccountId) {
    const result = await this.apiPromise.query.ddcStaking.ledger(controllerAccountId);
    return result.toJSON();
  }
  /**
   * Finds the controller account associated with a given stash account ID.
   *
   * @param stashAccountId - The account ID of the stash.
   * @returns A promise that resolves to the controller account ID, or undefined if no controller account is found.
   *
   * @example
   *
   * ```typescript
   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
   * const controllerAccountId = await blockchain.ddcStaking.findControllerAccountByStashAccountId(stashAccountId);
   *
   * console.log(controllerAccountId);
   * ```
   */
  async findControllerAccountByStashAccountId(stashAccountId) {
    const result = await this.apiPromise.query.ddcStaking.bonded(stashAccountId);
    return result.toJSON();
  }
  /**
   * Finds the node public key associated with a given stash account ID.
   *
   * @param stashAccountId - The account ID of the stash.
   * @returns A promise that resolves to the node public key, or undefined if no node public key is found.
   *
   * @example
   *
   * ```typescript
   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
   * const nodePublicKey = await blockchain.ddcStaking.findNodePublicKeyByStashAccountId(stashAccountId);
   *
   * console.log(nodePublicKey);
   * ```
   */
  async findNodePublicKeyByStashAccountId(stashAccountId) {
    const result = await this.apiPromise.query.ddcStaking.providers(stashAccountId);
    return result.toJSON();
  }
  /**
   * Bonds the cluster.
   *
   * @param clusterId - The cluster ID to bond
   * @returns An extrinsic to bond the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const tx = blockchain.ddcStaking.bondCluster(clusterId);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  bondCluster(clusterId) {
    return this.apiPromise.tx.ddcStaking.bondCluster(clusterId);
  }
  /**
   * Unbonds the cluster.
   *
   * @param clusterId - The cluster ID to bond
   * @returns An extrinsic to unbond the cluster.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const tx = blockchain.ddcStaking.unbondCluster(clusterId);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  unbondCluster(clusterId) {
    return this.apiPromise.tx.ddcStaking.unbondCluster(clusterId);
  }
  /**
   * Withdraws unbonded cluster funds.
   *
   * @param clusterId - The cluster ID to withdraw
   * @returns An extrinsic to withdraw the cluster funds.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const tx = blockchain.ddcStaking.withdrawUnbondedCluster(clusterId);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  withdrawUnbondedCluster(clusterId) {
    return this.apiPromise.tx.ddcStaking.withdrawUnbondedCluster(clusterId);
  }
}

/**
 * This class provides methods to interact with the DDC Customers pallet on the blockchain.
 *
 * @group Pallets
 * @example
 *
 * ```typescript
 * const bucket = await blockchain.ddcCustomers.getBucket(1n);
 *
 * console.log(bucket);
 * ```
 */
class DDCCustomersPallet {
  constructor(apiPromise) {
    this.apiPromise = void 0;
    this.apiPromise = apiPromise;
  }
  /**
   * Returns the bucket with the given ID.
   *
   * @param bucketId - The ID of the bucket.
   * @returns A promise that resolves to the bucket.
   *
   * @example
   *
   * ```typescript
   * const bucket = await blockchain.ddcCustomers.getBucket(1n);
   *
   * console.log(bucket);
   * ```
   */
  async getBucket(bucketId) {
    const result = await this.apiPromise.query.ddcCustomers.buckets(bucketId);
    const bucket = result.toJSON();
    return bucket == null ? undefined : {
      ...bucket,
      bucketId: BigInt(bucket.bucketId)
    };
  }
  /**
   * Returns the number of buckets.
   *
   * @returns A promise that resolves to the number of buckets.
   *
   * @example
   *
   * ```typescript
   * const bucketsCount = await blockchain.ddcCustomers.getBucketsCount();
   *
   * console.log(bucketsCount);
   * ```
   */
  async getBucketsCount() {
    const result = await this.apiPromise.query.ddcCustomers.bucketsCount();
    return result.toJSON();
  }
  /**
   * Returns the staking info for the given account in the specified cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param accountId - The ID of the account.
   * @returns A promise that resolves to the staking info.
   *
   * @example
   *
   * ```typescript
   * const stakingInfo = await blockchain.ddcCustomers.getStackingInfo('0x...', '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu');
   *
   * console.log(stakingInfo);
   * ```
   */
  async getStackingInfo(clusterId, accountId) {
    const result = await this.apiPromise.query.ddcCustomers.clusterLedger(clusterId, accountId);
    return result.toJSON();
  }
  /**
   * Returns the staking info for the given account (legacy method - deprecated).
   * This method is deprecated because the storage has migrated to cluster-based ledger.
   * Use getStackingInfo(clusterId, accountId) instead.
   *
   * @deprecated Use getStackingInfo(clusterId, accountId) instead.
   * @param accountId - The ID of the account.
   * @returns A promise that resolves to the staking info.
   */
  async getStackingInfoLegacy(accountId) {
    // For backward compatibility, try to get from the first available cluster
    // This is a fallback and should not be used in new code
    const result = await this.apiPromise.query.ddcCustomers.ledger(accountId);
    return result.toJSON();
  }
  /**
   * Creates a new bucket.
   *
   * @param clusterId - The ID of the cluster.
   * @param params - The bucket parameters.
   * @returns An extrinsic to create the bucket.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.createBucket('0x...', { isPublic: true });
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  createBucket(clusterId, params) {
    return this.apiPromise.tx.ddcCustomers.createBucket(clusterId, params);
  }
  /**
   * Sets the parameters of the bucket with the given ID.
   *
   * @param bucketId - The ID of the bucket.
   * @param params - The bucket parameters.
   * @returns An extrinsic to set the bucket parameters.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.setBucketParams(1n, { isPublic: true });
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  setBucketParams(bucketId, params) {
    return this.apiPromise.tx.ddcCustomers.setBucketParams(bucketId, params);
  }
  /**
   * Deposits funds to the account for the specified cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param value - The amount to deposit.
   * @returns An extrinsic to deposit funds.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.deposit('0x...', 100n);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  deposit(clusterId, value) {
    return this.apiPromise.tx.ddcCustomers.deposit(clusterId, value);
  }
  /**
   * Deposits additional funds to the account for the specified cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param maxAdditional - The maximum amount to deposit.
   * @returns An extrinsic to deposit additional funds.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.depositExtra('0x...', 100n);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  depositExtra(clusterId, maxAdditional) {
    return this.apiPromise.tx.ddcCustomers.depositExtra(clusterId, maxAdditional);
  }
  /**
   * Deposits funds to the target address for the specified cluster.
   * This allows a third party to deposit funds on behalf of another address.
   *
   * @param targetAddress - The target address to deposit funds for.
   * @param clusterId - The ID of the cluster.
   * @param amount - The amount to deposit.
   * @returns An extrinsic to deposit funds for the target address.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.depositFor('5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu', '0x...', 100n);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  depositFor(targetAddress, clusterId, amount) {
    return this.apiPromise.tx.ddcCustomers.depositFor(targetAddress, clusterId, amount);
  }
  /**
   * Unlocks deposit funds from the account for the specified cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @param value - The amount to unlock.
   * @returns An extrinsic to unlock deposit funds.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.unlockDeposit('0x...', 100n);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  unlockDeposit(clusterId, value) {
    return this.apiPromise.tx.ddcCustomers.unlockDeposit(clusterId, value);
  }
  /**
   * Withdraws unlocked funds from the account for the specified cluster.
   *
   * @param clusterId - The ID of the cluster.
   * @returns An extrinsic to withdraw unlocked funds.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.withdrawUnlockedDeposit('0x...');
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  withdrawUnlockedDeposit(clusterId) {
    return this.apiPromise.tx.ddcCustomers.withdrawUnlockedDeposit(clusterId);
  }
  /**
   * Returns the list of buckets.
   *
   * @returns A promise that resolves to the list of buckets.
   *
   * @example
   *
   * ```typescript
   * const buckets = await blockchain.ddcCustomers.listBuckets();
   *
   * console.log(buckets);
   * ```
   */
  async listBuckets() {
    var _this$apiPromise$quer;
    const entries = (await ((_this$apiPromise$quer = this.apiPromise.query.ddcCustomers) == null ? void 0 : _this$apiPromise$quer.buckets.entries())) || [];
    return entries.map(([, bucketOption]) => {
      const bucket = bucketOption.toJSON();
      return bucket == null ? undefined : {
        ...bucket,
        bucketId: BigInt(bucket.bucketId)
      };
    }).filter(bucket => bucket !== undefined);
  }
  /**
   * Extracts the IDs of the created buckets from the given events.
   *
   * @param events - The events to extract the bucket IDs from.
   * @returns The IDs of the created buckets.
   *
   * @example
   *
   * ```typescript
   * const bucketIds = blockchain.ddcCustomers.extractCreatedBucketIds(events);
   *
   * console.log(bucketIds);
   * ```
   */
  extractCreatedBucketIds(events) {
    return events.filter(event => event.section === 'ddcCustomers' && event.method === 'BucketCreated').map(event => {
      var _event$payload;
      return (_event$payload = event.payload) == null ? void 0 : _event$payload.bucket_id;
    }).filter(Boolean).map(BigInt);
  }
  /**
   * Mark existing buckets with specified bucket ids as removed.
   *
   * @param bucketIds - The IDs of the buckets to remove.
   * @returns An extrinsic to remove the buckets.
   *
   * @example
   *
   * ```typescript
   * const tx = blockchain.ddcCustomers.removeBuckets(1n, 2n);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  removeBuckets(...bucketIds) {
    if (bucketIds.length === 0) {
      throw new Error('At least one bucket ID must be provided');
    } else if (bucketIds.length === 1) {
      return this.apiPromise.tx.ddcCustomers.removeBucket(bucketIds[0]);
    }
    return this.apiPromise.tx.utility.batch(bucketIds.map(bucketId => this.apiPromise.tx.ddcCustomers.removeBucket(bucketId)));
  }
  /**
   * Extracts the IDs of the removed buckets from the given events.
   *
   * @param events - The events to extract the bucket IDs from.
   * @returns The IDs of the removed buckets.
   *
   * @example
   *
   * ```typescript
   * const bucketIds = blockchain.ddcCustomers.extractRemovedBucketIds(events);
   *
   * console.log(bucketIds);
   * ```
   */
  extractRemovedBucketIds(events) {
    return events.filter(event => event.section === 'ddcCustomers' && event.method === 'BucketRemoved').map(event => {
      var _event$payload2;
      return (_event$payload2 = event.payload) == null ? void 0 : _event$payload2.bucket_id;
    }).filter(Boolean).map(BigInt);
  }
}

/**
 * This class provides methods to interact with the DDC Cluster Goverment pallet on the blockchain.
 *
 * @group Pallets
 * @example
 *
 * ```typescript
 * const clusterId = '0x...';
 * const protocolParams = { ... };
 * const member = ClusterMember.ClusterManager;
 *
 * const tx = blockchain.ddcClusterGov.proposeUpdateClusterProtocol(clusterId, protocolParams, member);
 *
 * await blockchain.send(tx, { account });
 * ```
 */
class DDCClustersGovPallet {
  constructor(apiPromise) {
    this.apiPromise = void 0;
    this.apiPromise = apiPromise;
  }
  /**
   * Creates a local proposal within a cluster, intended to activate the cluster in the network with specific protocol parameters such as validators, treasury fees, and pricing for stored and streamed bytes.
   * Only cluster members, namely the cluster manager and node providers, have voting rights on this proposal.
   * Furthermore, only the cluster manager has the authority to create this type of proposal.
   *
   * @param clusterId - The ID of the cluster.
   */
  proposeActivateClusterProtocol(clusterId, protocolParams) {
    return this.apiPromise.tx.ddcClusterGov.proposeActivateClusterProtocol(clusterId, protocolParams);
  }
  /**
   * Creates a local proposal within a cluster, intended to update protocol parameters (like validators, treasury fee, pricing for stored and streamed bytes, etc.) of a previously activated cluster in the network.
   * Only cluster members, such as the cluster manager and node providers, can vote on this type of proposal.
   * Any cluster member has the ability to create this type of proposal.
   *
   * @param clusterId - The ID of the cluster.
   * @param protocolParams - The new protocol parameters.
   * @param member - The member who is creating the proposal.
   * @param nodePublicKey - The public key of the node provider. Needed in case the member is ClusterMember.NodeProvider.
   *
   * @returns An extrinsic to propose the update of the cluster protocol.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const protocolParams = { ... };
   * const member = ClusterMember.ClusterManager;
   *
   * const tx = blockchain.ddcClusterGov.proposeUpdateClusterProtocol(clusterId, protocolParams, member);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  proposeUpdateClusterProtocol(clusterId, protocolParams, member, nodePublicKey) {
    return this.apiPromise.tx.ddcClusterGov.proposeUpdateClusterProtocol(clusterId, protocolParams, this.createClusterMember(member, nodePublicKey));
  }
  /**
   * Votes for a local proposal within a cluster. Only cluster members, such as the cluster manager and node providers, are permitted to vote.
   *
   * @param clusterId - The ID of the cluster.
   * @param approve - Whether to approve the proposal.
   * @param member - The member who is voting.
   * @param nodePublicKey - The public key of the node provider. Needed in case the member is ClusterMember.NodeProvider.
   *
   * @returns An extrinsic to vote on the proposal.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const approve = true;
   * const member = ClusterMember.ClusterManager;
   *
   * const tx = blockchain.ddcClusterGov.voteProposal(clusterId, approve, member);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  voteProposal(clusterId, approve, member, nodePublicKey) {
    return this.apiPromise.tx.ddcClusterGov.voteProposal(clusterId, approve, this.createClusterMember(member, nodePublicKey));
  }
  /**
   * This method allows to retract a local proposal within a cluster. Only the proposal's author can submit it.
   *
   * @param clusterId - The ID of the cluster.
   * @param member - The member who is retracting the proposal.
   * @param nodePublicKey - The public key of the node provider. Needed in case the member is ClusterMember.NodeProvider.
   * @returns An extrinsic to retract the proposal.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const member = ClusterMember.ClusterManager;
   *
   * const tx = blockchain.ddcClusterGov.retractProposal(clusterId, member);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  closeProposal(clusterId, member, nodePublicKey) {
    return this.apiPromise.tx.ddcClusterGov.closeProposal(clusterId, this.createClusterMember(member, nodePublicKey));
  }
  /**
   * Closes a local proposal within a cluster. If the required approval threshold is met, it will automatically initiate a public referendum in the OpenGov.
   * Here, any CERE token holder can vote on the cluster's proposal, thereby influencing the network's economics.
   * If the required approval threshold is not met, the local (internal) proposal will be withdrawn without initiating a public referendum.
   * Any cluster member can close the proposal once the approval threshold or expiration time is reached.
   *
   * @param clusterId - The ID of the cluster.
   * @returns An extrinsic to retract the proposal.
   *
   * @example
   *
   * ```typescript
   * const clusterId = '0x...';
   * const tx = blockchain.ddcClusterGov.retractProposal(clusterId);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  retractProposal(clusterId) {
    return this.apiPromise.tx.ddcClusterGov.retractProposal(clusterId);
  }
  /**
   * Refunds the submission deposit made by the proposal's author when creating a local proposal.
   *
   * @param referendaIndex - The index of the referendum.
   *
   * @returns An extrinsic to refund the submission deposit.
   *
   * @example
   *
   * ```typescript
   * const referendaIndex = 0;
   * const tx = blockchain.ddcClusterGov.refundSubmissionDeposit(referendaIndex);
   *
   * await blockchain.send(tx, { account });
   * ```
   */
  refundSubmissionDeposit(referendaIndex) {
    return this.apiPromise.tx.ddcClusterGov.refundSubmissionDeposit(referendaIndex);
  }
  createClusterMember(member, nodePublicKey) {
    if (member === exports.ClusterMember.ClusterManager) {
      return exports.ClusterMember.ClusterManager;
    }
    if (!nodePublicKey) {
      throw new Error('Node public key is required to create a cluster member enum.');
    }
    return {
      [exports.ClusterMember.NodeProvider]: nodePublicKey
    };
  }
}

/**
 * This class provides methods to interact with the Cere blockchain.
 *
 * @group Blockchain
 * @example
 *
 * ```typescript
 * const blockchain = await Blockchain.connect({ wsEndpoint: 'wss://rpc.testnet.cere.network/ws' });
 * const account = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';
 * const balance = await blockchain.getAccountFreeBalance(account);
 *
 * console.log(balance);
 * ```
 */
class Blockchain {
  constructor(options) {
    this.api = void 0;
    /**
     * The DDC Nodes pallet.
     *
     * @category Pallets
     */
    this.ddcNodes = void 0;
    /**
     * The DDC Clusters pallet.
     *
     * @category Pallets
     */
    this.ddcClusters = void 0;
    /**
     * The DDC Staking pallet.
     *
     * @category Pallets
     */
    this.ddcStaking = void 0;
    /**
     * The DDC Customers pallet.
     *
     * @category Pallets
     */
    this.ddcCustomers = void 0;
    /**
     * The DDC Cluster government pallet.
     *
     * @category Pallets
     */
    this.ddcClustersGov = void 0;
    this.api = 'apiPromise' in options ? options.apiPromise : new api.ApiPromise({
      provider: new api.WsProvider(options.wsEndpoint),
      ...options.apiOptions
    });
    this.ddcNodes = new DDCNodesPallet(this.api);
    this.ddcClusters = new DDCClustersPallet(this.api);
    this.ddcStaking = new DDCStakingPallet(this.api);
    this.ddcCustomers = new DDCCustomersPallet(this.api);
    this.ddcClustersGov = new DDCClustersGovPallet(this.api);
  }
  /**
   * Connects to the blockchain and returns a new instance of the Blockchain class.
   *
   * @param options - Options for connecting to the blockchain.
   * @returns A promise that resolves to a new instance of the Blockchain class.
   *
   * Example usage:
   * ```typescript
   * const blockchain = await Blockchain.connect({ wsEndpoint: 'wss://rpc.testnet.cere.network/ws' });
   * ```
   */
  static async connect(options) {
    const blockchain = new Blockchain(options);
    await blockchain.isReady();
    return blockchain;
  }
  /**
   * Checks if the blockchain is ready.
   *
   * @returns A promise that resolves to `true` if the blockchain is ready.
   *
   * @example
   * ```typescript
   * const isReady = await blockchain.isReady();
   * console.log(isReady);
   * ```
   */
  async isReady() {
    await this.api.isReady;
    return true;
  }
  /**
   * The decimals of the chain's native token.
   */
  get chainDecimals() {
    const [decimals] = this.api.registry.chainDecimals;
    return decimals;
  }
  /**
   * Retrieves the next nonce for an account.
   *
   * @param address - The address of the account.
   * @returns A promise that resolves to the next nonce for the account.
   *
   * Example usage:
   * ```typescript
   * const nonce = await blockchain.getNextNonce('5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu');
   *
   * console.log(nonce);
   * ```
   */
  async getNextNonce(address) {
    const nonce = await this.api.rpc.system.accountNextIndex(address);
    return nonce.toNumber();
  }
  /**
   * Sends a transaction to the blockchain.
   *
   * @param sendable - The transaction to send.
   * @param options - Options for sending the transaction.
   * @returns A promise that resolves to the result of the transaction.
   *
   * Example usage:
   * ```typescript
   * const account = new UriSigner('//Alice');
   * const tx = blockchain.ddcCustomers.createBucket('0x...', { isPublic: true });
   *
   * const result = await blockchain.send(sendable, { account });
   *
   * console.log(result);
   * ```
   */
  async send(sendable, {
    account,
    nonce,
    signer
  }) {
    let finalAccount;
    let finalSigner = signer;
    /**
     * If the account is a Signer instance, we need to convert it to a blockchain signer
     */
    if (Signer.isSigner(account)) {
      finalSigner || (finalSigner = await account.getSigner());
      finalAccount = account.address;
    } else {
      finalAccount = account;
    }
    return new Promise((resolve, reject) => {
      sendable.signAndSend(finalAccount, {
        nonce,
        signer: finalSigner
      }, result => {
        if (result.status.isFinalized) {
          const events = result.events.map(({
            event
          }) => ({
            method: event.method,
            section: event.section,
            meta: event.meta.toJSON(),
            data: event.data.toJSON(),
            payload: Object.fromEntries(event.meta.fields.map((field, index) => [field.name, event.data[index].toJSON()]))
          }));
          resolve({
            events,
            txHash: result.status.asFinalized.toHex()
          });
        } else if (result.dispatchError) {
          let errorMessage;
          if (result.dispatchError.isModule) {
            const decoded = this.api.registry.findMetaError(result.dispatchError.asModule);
            errorMessage = `${decoded.section}.${decoded.name}: ${decoded.docs.join(' ')}`;
          } else {
            errorMessage = result.dispatchError.toString();
          }
          reject(new Error(errorMessage));
        }
      }).catch(reject);
    });
  }
  /**
   * Sends a batch of transactions to the blockchain.
   * The transactions are sent in a single batch and are executed in the order they are provided.
   * If one transaction in the batch fails, the rest of the transactions in the batch will still be processed. The batch itself does not fail.
   *
   * @param sendables - The transactions to send.
   * @param options - Options for sending the transactions.
   * @returns A promise that resolves to the result of the batch of transactions.
   *
   * @example
   *
   * ```typescript
   * const account = new UriSigner('//Alice');
   * const tx1 = blockchain.ddcCustomers.createBucket('0x...');
   * const tx2 = blockchain.ddcCustomers.createBucket('0x...');
   *
   * const result = await blockchain.batchSend([tx1, tx2], { account });
   *
   * console.log(result);
   * ```
   */
  batchSend(sendables, options) {
    return this.send(this.api.tx.utility.batch(sendables), options);
  }
  /**
   * Sends a batch of transactions to the blockchain.
   * The transactions are sent in a single batch and are executed in the order they are provided.
   * If one transaction in the batch fails, the entire batch fails and no further transactions in the batch are processed.
   *
   * @param sendables - The transactions to send.
   * @param options - Options for sending the transactions.
   * @returns A promise that resolves to the result of the batch of transactions.
   *
   * @example
   *
   * ```typescript
   * const account = new UriSigner('//Alice');
   * const tx1 = blockchain.ddcCustomers.createBucket('0x...');
   * const tx2 = blockchain.ddcCustomers.createBucket('0x...');
   *
   * const result = await blockchain.batchAllSend([tx1, tx2], { account });
   *
   * console.log(result);
   * ```
   */
  batchAllSend(sendables, options) {
    return this.send(this.api.tx.utility.batchAll(sendables), options);
  }
  sudo(sendable) {
    return this.api.tx.sudo.sudo(sendable);
  }
  sudoAs(who, sendable) {
    return this.api.tx.sudo.sudoAs(who, sendable);
  }
  /**
   * Disconnects from the blockchain.
   *
   * @returns A promise that resolves when the connection is closed.
   *
   * @example
   * ```typescript
   * await blockchain.disconnect();
   * ```
   */
  disconnect() {
    return this.api.disconnect();
  }
  formatBalance(balance, withUnit = 'CERE') {
    return util.formatBalance(balance, {
      withSiFull: true,
      decimals: this.chainDecimals,
      withUnit
    });
  }
  /**
   * Retrieves the free balance of an account.
   *
   * @param accountId - The account ID.
   * @returns A promise that resolves to the free balance of the account.
   *
   * @example
   * ```typescript
   * const balance = await blockchain.getAccountFreeBalance('5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu');
   *
   * console.log(balance);
   * ```
   */
  async getAccountFreeBalance(accountId) {
    const {
      data
    } = await this.api.query.system.account(accountId);
    return data.free.toBigInt();
  }
  /**
   * Retrieves the current block number.
   *
   * @returns A promise that resolves to the current block number.
   *
   * Example usage:
   * ```typescript
   * const blockchain = await Blockchain.connect({ wsEndpoint: 'wss://rpc.testnet.cere.network/ws' });
   * const blockNumber = await blockchain.getCurrentBlockNumber();
   *
   * console.log(blockNumber);
   * ```
   */
  async getCurrentBlockNumber() {
    const {
      number
    } = await this.api.rpc.chain.getHeader();
    return number.toNumber();
  }
}

const decodeAddress = (address, ignoreChecksum) => {
  return cryptoUtil__namespace.decodeAddress(address, ignoreChecksum, CERE_SS58_PREFIX);
};
const encodeAddress = address => {
  return cryptoUtil__namespace.encodeAddress(address, CERE_SS58_PREFIX);
};
const createRandomSigner = (options = {}) => {
  const uri = cryptoUtil__namespace.mnemonicGenerate();
  return new UriSigner(uri, options);
};

Object.defineProperty(exports, 'cryptoWaitReady', {
  enumerable: true,
  get: function () { return cryptoUtil.cryptoWaitReady; }
});
exports.Blockchain = Blockchain;
exports.CERE_SS58_PREFIX = CERE_SS58_PREFIX;
exports.CereWalletSigner = CereWalletSigner;
exports.DDCClustersGovPallet = DDCClustersGovPallet;
exports.DDCClustersPallet = DDCClustersPallet;
exports.DDCCustomersPallet = DDCCustomersPallet;
exports.DDCNodesPallet = DDCNodesPallet;
exports.DDCStakingPallet = DDCStakingPallet;
exports.JsonSigner = JsonSigner;
exports.KeyringSigner = KeyringSigner;
exports.Signer = Signer;
exports.UriSigner = UriSigner;
exports.Web3Signer = Web3Signer;
exports.createRandomSigner = createRandomSigner;
exports.decodeAddress = decodeAddress;
exports.encodeAddress = encodeAddress;
//# sourceMappingURL=index.cjs.map
