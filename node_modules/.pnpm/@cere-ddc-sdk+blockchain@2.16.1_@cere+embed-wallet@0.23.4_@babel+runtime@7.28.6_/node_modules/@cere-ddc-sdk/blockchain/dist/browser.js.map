{"version":3,"file":"browser.js","sources":["../src/types.ts","../src/Signer/Signer.ts","../src/constants.ts","../src/Signer/KeyringSigner.ts","../src/Signer/UriSigner.ts","../src/Signer/Web3Signer.ts","../src/utils/index.ts","../src/Signer/CereWalletSigner.ts","../src/Signer/JsonSigner.ts","../src/DDCNodesPallet.ts","../src/DDCClustersPallet.ts","../src/DDCStakingPallet.ts","../src/DDCCustomersPallet.ts","../src/DDCClustersGovPallet.ts","../src/Blockchain.ts"],"sourcesContent":["import { HexString } from '@polkadot/util/types';\n\nexport type ClusterId = HexString;\nexport type ClusterParams = {\n  readonly nodeProviderAuthContract?: AccountId | null;\n  readonly erasureCodingRequired: number;\n  readonly erasureCodingTotal: number;\n  readonly replicationTotal: number;\n};\n\n/**\n * @deprecated Use ClusterParams instead.\n */\nexport type ClusterProps = ClusterParams;\n\nexport enum ClusterStatus {\n  Unbonded = 'Unbonded',\n  Bonded = 'Bonded',\n  Activated = 'Activated',\n  Unbonding = 'Unbonding',\n}\n\nexport type Cluster = {\n  readonly clusterId: ClusterId;\n  readonly managerId: AccountId;\n  readonly reserveId: AccountId;\n  readonly props: ClusterParams;\n  readonly status: ClusterStatus;\n};\n\nexport type PartsBerBillion = number;\nexport type BlockInterval = number;\nexport type ClusterProtocolParams = {\n  readonly treasuryShare: PartsBerBillion;\n  readonly validatorsShare: PartsBerBillion;\n  readonly clusterReserveShare: PartsBerBillion;\n  readonly storageBondSize: Amount;\n  readonly storageChillDelay: BlockInterval;\n  readonly storageUnbondingDelay: BlockInterval;\n  readonly unitPerMbStored: Amount;\n  readonly unitPerMbStreamed: Amount;\n  readonly unitPerPutRequest: Amount;\n  readonly unitPerGetRequest: Amount;\n};\n\n/**\n * @deprecated Use ClusterProtocolParams instead.\n */\nexport type ClusterGovernmentParams = ClusterProtocolParams;\n\nexport enum ClusterMember {\n  ClusterManager = 'ClusterManager',\n  NodeProvider = 'NodeProvider',\n}\n\nexport type ReferendumIndex = number;\n\nexport type BucketId = bigint;\nexport type BucketParams = {\n  isPublic: boolean;\n};\n\nexport type Bucket = {\n  readonly bucketId: BucketId;\n  readonly ownerId: AccountId;\n  readonly clusterId: ClusterId;\n  readonly isPublic: boolean;\n  readonly isRemoved: boolean;\n};\n\nexport type AccountId = string;\nexport type StakingInfo = {\n  readonly owner: AccountId;\n  readonly total: bigint;\n  readonly active: bigint;\n};\n\nexport type NodePublicKey = AccountId;\nexport type StorageNodePublicKey = NodePublicKey;\n\nexport enum StorageNodeMode {\n  Full = 'Full',\n  Storage = 'Storage',\n  Cache = 'Cache',\n}\n\nexport type StorageNodeProps = {\n  readonly host: string;\n  readonly httpPort: number;\n  readonly grpcPort: number;\n  readonly p2pPort: number;\n  readonly mode: StorageNodeMode;\n  readonly domain?: string;\n  readonly ssl?: boolean;\n};\n\nexport type StorageNode = {\n  readonly pubKey: StorageNodePublicKey;\n  readonly providerId: AccountId;\n  readonly clusterId: ClusterId | null | undefined;\n  readonly props: StorageNodeProps;\n};\n\nexport type Amount = bigint;\n\nexport type BlockNumber = number;\n\nexport type StakingLedger = {\n  stash: AccountId;\n  total: Amount;\n  active: Amount;\n  chilling: BlockNumber | undefined | null;\n  unlocking: any[];\n};\n\nexport enum ClusterNodeKind {\n  Genesis = 'Genesis',\n  External = 'External',\n}\n","import { Signer as BlockchainSigner } from '@polkadot/types/types';\nimport type { KeyringPair } from '@polkadot/keyring/types';\n\nexport type SignerType = KeyringPair['type'];\n\n/**\n * This abstract class provides a blueprint for creating different types of signers.\n *\n * @group Signers\n * @example\n *\n * ```typescript\n * class MySigner extends Signer {\n *   // Implement abstract properties and methods...\n * }\n *\n * const mySigner = new MySigner();\n * const isReady = await mySigner.isReady();\n * console.log(isReady);\n * ```\n */\nexport abstract class Signer {\n  /**\n   * The type of the signer ('ed25519' or 'sr25519').\n   */\n  abstract readonly type: SignerType;\n\n  /**\n   * The address of the signer.\n   */\n  abstract readonly address: string;\n\n  /**\n   * The public key of the signer.\n   */\n  abstract readonly publicKey: Uint8Array;\n\n  /**\n   * A boolean indicating whether the signer is locked.\n   */\n  abstract readonly isLocked: boolean;\n\n  /**\n   * Gets blockchain the signer.\n   *\n   * @internal\n   * @returns A promise that resolves to the signer.\n   */\n  abstract getSigner(): Promise<BlockchainSigner>;\n\n  /**\n   * Checks if the signer is ready.\n   *\n   * @returns A promise that resolves to a boolean indicating whether the signer is ready.\n   */\n  abstract isReady(): Promise<boolean>;\n\n  /**\n   * Unlocks the signer with a passphrase.\n   *\n   * @param passphrase - The passphrase to unlock the signer.\n   */\n  async unlock(passphrase?: string) {}\n\n  /**\n   * Signs data with the signer.\n   *\n   * @param data - The data to sign.\n   * @returns A promise that resolves to the signature.\n   */\n  abstract sign(data: Uint8Array | string): Promise<Uint8Array>;\n\n  /**\n   * Checks if an object is a signer.\n   *\n   * @param signer - The object to check.\n   * @returns A boolean indicating whether the object is a signer.\n   */\n  static isSigner(signer: unknown): signer is Signer {\n    if (!signer || typeof signer !== 'object') {\n      return false;\n    }\n\n    return signer instanceof Signer || ('isReady' in signer && 'sign' in signer && 'getSigner' in signer);\n  }\n}\n","export const CERE_SS58_PREFIX = 54;\n","import { Signer as BcSigner, SignerPayloadRaw } from '@polkadot/types/types';\nimport { KeyringPair } from '@polkadot/keyring/types';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { u8aToHex } from '@polkadot/util';\n\nimport { Signer } from './Signer';\n\n/**\n * Signer that uses a keyring pair to sign data.\n *\n * @group Signers\n * @extends Signer\n * @example\n *\n * ```typescript\n * const pair = new Keyring().addFromUri('//Alice');\n * const keyringSigner = new KeyringSigner(pair);\n * const signature = await keyringSigner.sign('data');\n *\n * console.log(signature);\n * ```\n */\nexport class KeyringSigner extends Signer {\n  constructor(private pair?: KeyringPair) {\n    super();\n\n    this.isReady();\n  }\n\n  get isLocked() {\n    if (!this.pair) {\n      throw new Error('Key pair is not ready!');\n    }\n\n    return this.pair.isLocked;\n  }\n\n  async unlock(passphrase?: string) {\n    await this.isReady();\n\n    if (!this.pair) {\n      throw new Error('Key pair is not ready!');\n    }\n\n    if (this.pair.isLocked) {\n      this.pair.unlock(passphrase);\n    }\n  }\n\n  protected createPair() {\n    if (!this.pair) {\n      throw new Error('Key pair is not provided!');\n    }\n\n    return this.pair;\n  }\n\n  async isReady() {\n    if (this.pair) {\n      return true;\n    }\n\n    const isCryptoReady = await cryptoWaitReady();\n\n    if (!isCryptoReady) {\n      return false;\n    }\n\n    this.pair = this.createPair();\n\n    return true;\n  }\n\n  private getPair() {\n    if (this.pair) {\n      return this.pair;\n    }\n\n    throw new Error('Signer is not ready');\n  }\n\n  get type() {\n    return this.getPair().type;\n  }\n\n  get address() {\n    return this.getPair().address;\n  }\n\n  get publicKey() {\n    return this.getPair().publicKey;\n  }\n\n  async sign(data: Uint8Array | string) {\n    return this.getPair().sign(data);\n  }\n\n  async getSigner(): Promise<BcSigner> {\n    return {\n      signRaw: async ({ data }: SignerPayloadRaw) => {\n        const signature = this.getPair().sign(data, { withType: true });\n\n        return {\n          id: 0,\n          signature: u8aToHex(signature),\n        };\n      },\n    };\n  }\n}\n","import { KeyringPair, KeyringOptions } from '@polkadot/keyring/types';\nimport { Keyring } from '@polkadot/keyring';\n\nimport { CERE_SS58_PREFIX } from '../constants';\nimport { KeyringSigner } from './KeyringSigner';\n\nexport type UriSignerOptions = Pick<KeyringOptions, 'type'>;\n\n/**\n * Signer that uses a Substrate URI to create a keypair.\n *\n * @group Signers\n * @extends Signer\n * @example\n *\n * ```typescript\n * const uriSigner = new UriSigner('//Alice', );\n * const signature = await uriSigner.sign('data');\n *\n * console.log(signature);\n * ```\n */\nexport class UriSigner extends KeyringSigner {\n  constructor(\n    private uri: string,\n    private options: UriSignerOptions = {},\n  ) {\n    super();\n  }\n\n  protected createPair(): KeyringPair {\n    return new Keyring({ ss58Format: CERE_SS58_PREFIX, type: this.type }).addFromUri(this.uri);\n  }\n\n  get type() {\n    return this.options.type || 'sr25519';\n  }\n\n  static async create(uri: string, options: UriSignerOptions = {}) {\n    const signer = new UriSigner(uri, options);\n    await signer.isReady();\n\n    return signer;\n  }\n}\n","import type { InjectedAccount } from '@polkadot/extension-inject/types';\nimport { hexToU8a, u8aToHex, u8aWrapBytes } from '@polkadot/util';\nimport { decodeAddress, encodeAddress, cryptoWaitReady } from '@polkadot/util-crypto';\nimport { web3Enable, web3Accounts, web3FromAddress, web3EnablePromise } from '@polkadot/extension-dapp';\n\nimport { Signer } from './Signer';\nimport { CERE_SS58_PREFIX } from '../constants';\n\nexport type Web3SignerOptions = {\n  address?: string;\n  accountIndex?: number;\n  originName?: string;\n  autoConnect?: boolean;\n  extensions?: string[];\n};\n\n/**\n * Signer that uses browser extensions (eg. PolkadotJs) to sign messages.\n *\n * @group Signers\n * @extends Signer\n * @example\n *\n * ```typescript\n * const web3Signer = new Web3Signer({ autoConnect: true });\n * const signature = await web3Signer.sign('data');\n *\n * console.log(signature);\n * ```\n */\nexport class Web3Signer extends Signer {\n  protected accountAddress?: string;\n  protected accountIndex: number;\n  protected originName: string;\n  protected autoConnect: boolean;\n  protected injectedAccount?: InjectedAccount;\n  protected extensions?: string[];\n\n  constructor({\n    address,\n    extensions,\n    autoConnect = true,\n    originName = 'DDC',\n    accountIndex = 0,\n  }: Web3SignerOptions = {}) {\n    super();\n\n    this.accountAddress = address;\n    this.originName = originName;\n    this.autoConnect = autoConnect;\n    this.accountIndex = accountIndex;\n    this.extensions = extensions;\n  }\n\n  get isLocked() {\n    return false;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get address() {\n    return this.accountAddress || encodeAddress(this.account.address, CERE_SS58_PREFIX);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get publicKey() {\n    return decodeAddress(this.address, true, CERE_SS58_PREFIX);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get type() {\n    return this.account.type || 'sr25519';\n  }\n\n  protected get account() {\n    if (!this.injectedAccount) {\n      throw new Error('Web3Signer account is not ready');\n    }\n\n    return this.injectedAccount;\n  }\n\n  protected async getInjector() {\n    return web3FromAddress(this.address);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async getSigner() {\n    const { signer } = await this.getInjector();\n\n    return signer;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async sign(message: string | Uint8Array) {\n    const injector = await this.getInjector();\n\n    if (!injector.signer.signRaw) {\n      throw new Error('Signer does not support signing raw messages');\n    }\n\n    /**\n     * Wrap the message in <Bytes>...</Bytes> to make it impossible to sign extrinsics with this method.\n     */\n    const data = u8aToHex(u8aWrapBytes(message));\n    const { signature } = await injector.signer.signRaw({ address: this.address, data, type: 'bytes' });\n\n    return hexToU8a(signature);\n  }\n\n  /**\n   * Connects to the underlying Web3 signer.\n   *\n   * @returns A promise that resolves to the signer.\n   * @throws An error if the signer cannot be detected.\n   *\n   * @example\n   *\n   * ```typescript\n   * await web3Signer.connect();\n   * ```\n   */\n  async connect() {\n    await web3Enable(this.originName);\n    const accounts = await web3Accounts({\n      extensions: this.extensions,\n      accountType: ['ed25519', 'sr25519'],\n    });\n\n    this.injectedAccount = this.accountAddress\n      ? accounts.find((account) => account.address === this.accountAddress)\n      : accounts[this.accountIndex];\n\n    if (!this.injectedAccount) {\n      throw new Error('Web3Signer account cannot be detected');\n    }\n\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async isReady() {\n    await cryptoWaitReady();\n\n    if (this.injectedAccount) {\n      return true;\n    }\n\n    if (this.autoConnect) {\n      await this.connect();\n    }\n\n    await web3EnablePromise;\n\n    return true;\n  }\n}\n","import * as cryptoUtil from '@polkadot/util-crypto';\n\nimport { CERE_SS58_PREFIX } from '../constants';\nimport { UriSigner, UriSignerOptions } from '../Signer';\n\nexport { cryptoWaitReady } from '@polkadot/util-crypto';\n\nexport const decodeAddress = (address: string, ignoreChecksum?: boolean) => {\n  return cryptoUtil.decodeAddress(address, ignoreChecksum, CERE_SS58_PREFIX);\n};\n\nexport const encodeAddress = (address: Uint8Array) => {\n  return cryptoUtil.encodeAddress(address, CERE_SS58_PREFIX);\n};\n\nexport const createRandomSigner = (options: UriSignerOptions = {}) => {\n  const uri = cryptoUtil.mnemonicGenerate();\n\n  return new UriSigner(uri, options);\n};\n","import type { InjectedAccount, InjectedExtension } from '@polkadot/extension-inject/types';\nimport { enable } from '@cere/embed-wallet-inject';\nimport type { EmbedWallet, WalletConnectOptions } from '@cere/embed-wallet';\n\nimport { Web3Signer, Web3SignerOptions } from './Web3Signer';\nimport { cryptoWaitReady } from '../utils';\n\nexport type CereWalletSignerOptions = Pick<Web3SignerOptions, 'autoConnect'> & {\n  connectOptions?: WalletConnectOptions;\n};\n\n/**\n * Signer that uses Cere Wallet to sign messages.\n *\n * @group Signers\n * @extends Web3Signer\n * @example\n *\n * ```typescript\n * import { EmbedWallet } from '@cere/embed-wallet';\n *\n * const cereWallet = new EmbedWallet({ env: 'dev' });\n * await cereWallet.init();\n *\n * const cereWalletSigner = new CereWalletSigner(cereWallet);\n * const signature = await cereWalletSigner.sign('data');\n *\n * console.log(signature);\n * ```\n */\nexport class CereWalletSigner extends Web3Signer {\n  private extensionPromise: Promise<InjectedExtension>;\n\n  constructor(\n    private wallet: EmbedWallet,\n    private options: CereWalletSignerOptions = {},\n  ) {\n    super(options);\n\n    this.extensionPromise = enable(this.wallet, { autoConnect: false }).then((injected) => {\n      injected.accounts.get().then(this.setAccount);\n      injected.accounts.subscribe(this.setAccount);\n\n      return injected as InjectedExtension;\n    });\n  }\n\n  private setAccount = ([account]: InjectedAccount[]) => {\n    this.injectedAccount = account;\n  };\n\n  private async syncAccount() {\n    const { accounts } = await this.extensionPromise;\n\n    await accounts.get().then(this.setAccount);\n  }\n\n  protected async getInjector() {\n    return this.extensionPromise;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async isReady() {\n    await Promise.all([this.extensionPromise, cryptoWaitReady()]);\n\n    if (this.injectedAccount) {\n      return true;\n    }\n\n    if (this.autoConnect) {\n      await this.connect(this.options.connectOptions);\n    }\n\n    /**\n     * Make sure the account is synced with the extension.\n     */\n    await this.syncAccount();\n\n    return true;\n  }\n\n  async connect(options?: WalletConnectOptions) {\n    await this.wallet.connect(options);\n\n    /**\n     * Make sure the account is synced with the extension after connecting the wallet.\n     */\n    await this.syncAccount();\n\n    return this;\n  }\n}\n","import { KeyringPair, KeyringPair$Json } from '@polkadot/keyring/types';\nimport { Keyring } from '@polkadot/keyring';\n\nimport { KeyringSigner } from './KeyringSigner';\nimport { CERE_SS58_PREFIX } from '../constants';\n\ntype JsonSignerOptions = {\n  passphrase?: string;\n};\n\n/**\n * Signer that uses a JSON object to create a keypair.\n *\n * @group Signers\n * @extends Signer\n * @example\n *\n * ```typescript\n * const accountDataJson = {}; // Exported from Cere Wallet or other wallets\n * const jsonSigner = new JsonSigner(accountDataJson, { passphrase: '1234' });\n * const signature = await jsonSigner.sign('data');\n *\n * console.log(signature);\n * ```\n */\nexport class JsonSigner extends KeyringSigner {\n  constructor(\n    private account: KeyringPair$Json,\n    private options: JsonSignerOptions = {},\n  ) {\n    super();\n  }\n\n  protected createPair(): KeyringPair {\n    const keyPair = new Keyring({ ss58Format: CERE_SS58_PREFIX }).addFromJson(this.account);\n\n    if (this.options.passphrase) {\n      keyPair.unlock(this.options.passphrase);\n    }\n\n    return keyPair;\n  }\n\n  static async create(account: KeyringPair$Json) {\n    const signer = new JsonSigner(account);\n    await signer.isReady();\n\n    return signer;\n  }\n}\n","import { ApiPromise } from '@polkadot/api';\nimport { Sendable } from './Blockchain';\nimport type { StorageNode, StorageNodeProps, StorageNodePublicKey } from './types';\nimport { hexToString, stringToHex } from '@polkadot/util';\n\n/**\n * This class provides methods to interact with the DDC Nodes pallet on the blockchain.\n *\n * @group Pallets\n * @example\n *\n * ```typescript\n * const storageNodePublicKey = '0x...';\n * const storageNode = await blockchain.ddcNodes.findStorageNodeByPublicKey(storageNodePublicKey);\n *\n * console.log(storageNode);\n * ```\n */\nexport class DDCNodesPallet {\n  constructor(private apiPromise: ApiPromise) {}\n\n  /**\n   * Creates a new storage node.\n   *\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @param storageNodeProps - The properties of the storage node.\n   * @returns An extrinsic to create the storage node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const storageNodePublicKey = '0x...';\n   * const storageNodeProps = { ... };\n   * const tx = blockchain.ddcNodes.createStorageNode(storageNodePublicKey, storageNodeProps);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  createStorageNode(storageNodePublicKey: StorageNodePublicKey, storageNodeProps: StorageNodeProps) {\n    const defaultProps: Partial<StorageNodeProps> = {\n      domain: '',\n      ssl: false,\n    };\n\n    return this.apiPromise.tx.ddcNodes.createNode(\n      { StoragePubKey: storageNodePublicKey },\n      { StorageParams: encodeNodeProps({ ...defaultProps, ...storageNodeProps }) },\n    ) as Sendable;\n  }\n\n  /**\n   * Finds a storage node by public key.\n   *\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @returns A promise that resolves to the storage node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const storageNodePublicKey = '0x...';\n   * const storageNode = await blockchain.ddcNodes.findStorageNodeByPublicKey(storageNodePublicKey);\n   *\n   * console.log(storageNode);\n   * ```\n   */\n  async findStorageNodeByPublicKey(storageNodePublicKey: StorageNodePublicKey) {\n    const result = await this.apiPromise.query.ddcNodes.storageNodes(storageNodePublicKey);\n    const storageNode = result.toJSON() as unknown as StorageNode | undefined;\n    return storageNode == null\n      ? undefined\n      : ({ ...storageNode, props: decodeNodeProps(storageNode.props) } as StorageNode);\n  }\n\n  /**\n   * Returns a list of storage nodes.\n   *\n   * @returns A promise that resolves to a list of storage nodes.\n   *\n   * @example\n   *\n   * ```typescript\n   * const storageNodes = await blockchain.ddcNodes.listStorageNodes();\n   *\n   * console.log(storageNodes);\n   * ```\n   */\n  async listStorageNodes() {\n    const result = await this.apiPromise.query.ddcNodes.storageNodes.entries();\n\n    return result\n      .map(([, storageNodeOption]) => {\n        const storageNode = storageNodeOption.toJSON() as unknown as StorageNode | undefined;\n        return storageNode == null\n          ? undefined\n          : ({ ...storageNode, props: decodeNodeProps(storageNode.props) } as StorageNode);\n      })\n      .filter((storageNode) => storageNode != null) as StorageNode[];\n  }\n\n  /**\n   * Sets the properties of a storage node.\n   *\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @param storageNodeProps - The properties of the storage node.\n   * @returns An extrinsic to set the storage node properties.\n   *\n   * @example\n   *\n   * ```typescript\n   * const storageNodePublicKey = '0x...';\n   * const storageNodeProps = { ... };\n   * const tx = blockchain.ddcNodes.setStorageNodeProps(storageNodePublicKey, storageNodeProps);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  setStorageNodeProps(storageNodePublicKey: StorageNodePublicKey, storageNodeProps: StorageNodeProps) {\n    return this.apiPromise.tx.ddcNodes.setNodeParams(\n      { StoragePubKey: storageNodePublicKey },\n      { StorageParams: encodeNodeProps(storageNodeProps) },\n    ) as Sendable;\n  }\n\n  /**\n   * Deletes a storage node.\n   *\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @returns An extrinsic to delete the storage node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const storageNodePublicKey = '0x...';\n   * const tx = blockchain.ddcNodes.deleteStorageNode(storageNodePublicKey);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  deleteStorageNode(storageNodePublicKey: StorageNodePublicKey) {\n    return this.apiPromise.tx.ddcNodes.deleteNode({ StoragePubKey: storageNodePublicKey }) as Sendable;\n  }\n}\n\nfunction decodeNodeProps(nodeProps: StorageNodeProps): StorageNodeProps {\n  return {\n    ...nodeProps,\n    host: hexToString(nodeProps.host),\n    domain: hexToString(nodeProps.domain),\n  };\n}\n\nfunction encodeNodeProps(nodeProps: StorageNodeProps): StorageNodeProps {\n  return {\n    ...nodeProps,\n    host: stringToHex(nodeProps.host),\n    domain: stringToHex(nodeProps.domain),\n  };\n}\n","import { ApiPromise } from '@polkadot/api';\nimport { Sendable } from './Blockchain';\nimport {\n  AccountId,\n  Cluster,\n  ClusterProtocolParams,\n  ClusterId,\n  ClusterNodeKind,\n  ClusterParams,\n  StorageNodePublicKey,\n} from './types';\n\n/**\n * This class provides methods to interact with the DDC Clusters pallet on the blockchain.\n *\n * @group Pallets\n * @example\n *\n * ```typescript\n * const clusters = await blockchain.ddcClusters.listClusters();\n *\n * console.log(clusters);\n * ```\n */\nexport class DDCClustersPallet {\n  constructor(private apiPromise: ApiPromise) {}\n\n  /**\n   * Lists all clusters.\n   *\n   * @returns A promise that resolves to an array of clusters.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusters = await blockchain.ddcClustersPallet.listClusters();\n   *\n   * console.log(clusters);\n   * ```\n   */\n  async listClusters() {\n    const entries = (await this.apiPromise.query.ddcClusters?.clusters.entries()) || [];\n\n    return entries.map(([, clusterOption]) => clusterOption.toJSON() as unknown as Cluster);\n  }\n\n  /**\n   * Filters node keys by cluster ID.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @returns A promise that resolves to an array of node keys.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const nodeKeys = await blockchain.ddcClustersPallet.filterNodeKeysByClusterId(clusterId);\n   *\n   * console.log(nodeKeys);\n   * ```\n   */\n  async filterNodeKeysByClusterId(clusterId: ClusterId) {\n    const entries = await this.apiPromise.query.ddcClusters.clustersNodes.entries(clusterId);\n\n    return entries.map(([key]: any) => key.args[1].asStoragePubKey.toJSON() as StorageNodePublicKey);\n  }\n\n  /**\n   * Checks if a cluster has a storage node.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @returns A promise that resolves to a boolean indicating whether the cluster has the storage node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const storageNodePublicKey = '0x...';\n   * const hasStorageNode = await blockchain.ddcClustersPallet.clusterHasStorageNode(clusterId, storageNodePublicKey);\n   *\n   * console.log(hasStorageNode);\n   * ```\n   */\n  async clusterHasStorageNode(clusterId: ClusterId, storageNodePublicKey: StorageNodePublicKey) {\n    const result = await this.apiPromise.query.ddcClusters.clustersNodes(clusterId, {\n      StoragePubKey: storageNodePublicKey,\n    });\n\n    return !result.isEmpty;\n  }\n\n  /**\n   * Creates a new cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param clusterManagerId - The ID of the cluster manager.\n   * @param clusterReserveId - The ID of the cluster reserve.\n   * @param clusterParams - The properties of the cluster.\n   * @param clusterGovernmentParams - The government parameters of the cluster.\n   * @returns An extrinsic to create the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const clusterReserveId = '0x...';\n   * const clusterParams = { ... };\n   * const clusterGovernmentParams = { ... };\n   *\n   * const tx = blockchain.ddcClustersPallet.createCluster(\n   *   clusterId,\n   *   clusterReserveId,\n   *   clusterParams,\n   *   clusterGovernmentParams\n   * );\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  createCluster(\n    clusterId: ClusterId,\n    clusterReserveId: AccountId,\n    clusterParams: Partial<ClusterParams>,\n    clusterGovernmentParams: ClusterProtocolParams,\n  ) {\n    const clusterParamsDefaults: ClusterParams = {\n      nodeProviderAuthContract: null,\n      erasureCodingRequired: 16,\n      erasureCodingTotal: 48,\n      replicationTotal: 20,\n    };\n\n    return this.apiPromise.tx.ddcClusters.createCluster(\n      clusterId,\n      clusterReserveId,\n      { ...clusterParamsDefaults, ...clusterParams },\n      clusterGovernmentParams,\n    ) as Sendable;\n  }\n\n  /**\n   * Finds a cluster by ID.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @returns A promise that resolves to the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const cluster = await blockchain.ddcClustersPallet.findClusterById(clusterId);\n   *\n   * console.log(cluster);\n   * ```\n   */\n  async findClusterById(clusterId: ClusterId) {\n    const result = await this.apiPromise.query.ddcClusters.clusters(clusterId);\n    return result.toJSON() as unknown as Cluster;\n  }\n\n  /**\n   * Sets the properties of a cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param clusterParams - The properties of the cluster.\n   * @returns An extrinsic to set the cluster properties.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const clusterParams = { ... };\n   *\n   * const tx = blockchain.ddcClustersPallet.setClusterParams(clusterId, clusterParams);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  setClusterParams(clusterId: ClusterId, clusterParams: Partial<ClusterParams>) {\n    return this.apiPromise.tx.ddcClusters.setClusterParams(clusterId, clusterParams) as Sendable;\n  }\n\n  /**\n   * Adds a storage node to a cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @returns An extrinsic to add the storage node to the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const storageNodePublicKey = '0x...';\n   *\n   * const tx = blockchain.ddcClustersPallet.addStorageNodeToCluster(clusterId, storageNodePublicKey, ClusterNodeKind.Genesis);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  addStorageNodeToCluster(clusterId: ClusterId, storageNodePublicKey: StorageNodePublicKey, nodeKind: ClusterNodeKind) {\n    return this.apiPromise.tx.ddcClusters.addNode(\n      clusterId,\n      { StoragePubKey: storageNodePublicKey },\n      nodeKind,\n    ) as Sendable;\n  }\n\n  /**\n   * Removes a storage node from a cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @returns An extrinsic to remove the storage node from the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const storageNodePublicKey = '0x...';\n   *\n   * const tx = blockchain.ddcClustersPallet.removeStorageNodeFromCluster(clusterId, storageNodePublicKey);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  removeStorageNodeFromCluster(clusterId: ClusterId, storageNodePublicKey: StorageNodePublicKey) {\n    return this.apiPromise.tx.ddcClusters.removeNode(clusterId, { StoragePubKey: storageNodePublicKey }) as Sendable;\n  }\n\n  /**\n   * Gets the government parameters of a cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @returns A promise that resolves to the government parameters of the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const clusterGovernmentParams = await blockchain.ddcClustersPallet.getClusterGovernmentParams(clusterId);\n   *\n   * console.log(clusterGovernmentParams);\n   * ```\n   */\n  async getClusterGovernmentParams(clusterId: ClusterId) {\n    const result = await this.apiPromise.query.ddcClusters.clustersGovParams(clusterId);\n    return result.toJSON() as unknown as ClusterProtocolParams | undefined;\n  }\n}\n","import { ApiPromise } from '@polkadot/api';\nimport { Sendable } from './Blockchain';\nimport type { AccountId, Amount, ClusterId, StakingLedger, StorageNodePublicKey } from './types';\n\n/**\n * This class provides methods to interact with the DDC Staking pallet on the blockchain.\n *\n * @group Pallets\n * @example\n *\n * ```typescript\n * const storageNodePublicKey = '0x...';\n * const stashAccountId = await blockchain.ddcStaking.findStashAccountIdByStorageNodePublicKey(storageNodePublicKey);\n *\n * console.log(stashAccountId);\n * ```\n */\nexport class DDCStakingPallet {\n  constructor(private apiPromise: ApiPromise) {}\n\n  /**\n   * Binds the storage node.\n   *\n   * @param controller - The account that will control the storage node.\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @param bondAmount - The amount to bond.\n   * @returns An extrinsic to bind the storage node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const controller = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const storageNodePublicKey = '0x...';\n   * const bondAmount = 100n;\n   * const tx = blockchain.ddcStaking.bondStorageNode(controller, storageNodePublicKey, bondAmount);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  bondStorageNode(controller: AccountId, storageNodePublicKey: StorageNodePublicKey, bondAmount: Amount) {\n    return this.apiPromise.tx.ddcStaking.bond(\n      controller,\n      { StoragePubKey: storageNodePublicKey },\n      bondAmount,\n    ) as Sendable;\n  }\n\n  /**\n   * Chills the controller.\n   *\n   * @returns An extrinsic to chill the controller.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcStaking.chill();\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  chill() {\n    return this.apiPromise.tx.ddcStaking.chill() as Sendable;\n  }\n\n  /**\n   * Initiates a fast chill of storage.\n   *\n   * @returns An extrinsic to initiate a fast chill of storage.\n   *\n   * Example usage:\n   * ```typescript\n   * const tx = blockchain.ddcStaking.fastChillStorage();\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  fastChillStorage() {\n    return this.apiPromise.tx.ddcStaking.fastChill() as Sendable;\n  }\n\n  /**\n   * Unbonds the amount.\n   *\n   * @param amount - The amount to unbond.\n   * @returns An extrinsic to unbond the amount.\n   *\n   * @example\n   *\n   * ```typescript\n   * const amount = 100n;\n   * const tx = blockchain.ddcStaking.unbond(amount);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  unbond(amount: Amount) {\n    return this.apiPromise.tx.ddcStaking.unbond(amount) as Sendable;\n  }\n\n  /**\n   * Withdraws unbonded funds.\n   *\n   * @returns An extrinsic to withdraw unbonded funds.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcStaking.withdrawUnbonded();\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  withdrawUnbonded() {\n    return this.apiPromise.tx.ddcStaking.withdrawUnbonded() as Sendable;\n  }\n\n  /**\n   * Finds the stash account ID associated with a given storage node public key.\n   *\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @returns A promise that resolves to the stash account ID, or undefined if no stash account is found.\n   *\n   * @example\n   *\n   * ```typescript\n   * const storageNodePublicKey = '0x...';\n   * const stashAccountId = await blockchain.ddcStaking.findStashAccountIdByStorageNodePublicKey(storageNodePublicKey);\n   *\n   * console.log(stashAccountId);\n   * ```\n   */\n  async findStashAccountIdByStorageNodePublicKey(storageNodePublicKey: StorageNodePublicKey) {\n    const result = await this.apiPromise.query.ddcStaking.nodes({ StoragePubKey: storageNodePublicKey });\n    return result.toJSON() as unknown as AccountId | undefined;\n  }\n\n  /**\n   * Returns the list of staked storage nodes, their stash accounts, and their cluster IDs.\n   *\n   * @returns A promise that resolves to the list of staked storage nodes, their stash accounts, and their cluster IDs.\n   *\n   * @example\n   *\n   * ```typescript\n   * const stakedStorageNodes = await blockchain.ddcStaking.listStakedStorageNodesStashAccountsAndClusterIds();\n   *\n   * console.log(stakedStorageNodes);\n   * ```\n   */\n  async listStakedStorageNodesStashAccountsAndClusterIds() {\n    const result = await this.apiPromise.query.ddcStaking.storages.entries();\n    return result.map(([key, clusterId]) => ({\n      stashAccountId: key.args[0].toJSON() as unknown as AccountId,\n      clusterId: clusterId.toJSON() as unknown as ClusterId,\n    }));\n  }\n\n  /**\n   * Finds the cluster ID associated with a given CDN node stash account ID.\n   *\n   * @param stashAccountId - The stash account ID of the CDN node.\n   * @returns A promise that resolves to the cluster ID, or undefined if no cluster is found.\n   *\n   * @example\n   *\n   * ```typescript\n   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const clusterId = await blockchain.ddcStaking.findStakedClusterIdByCdnNodeStashAccountId(stashAccountId);\n   *\n   * console.log(clusterId);\n   * ```\n   */\n  async findStakedClusterIdByCdnNodeStashAccountId(stashAccountId: AccountId) {\n    const result = await this.apiPromise.query.ddcStaking.cdNs(stashAccountId);\n    return result.toJSON() as unknown as ClusterId | undefined;\n  }\n\n  /**\n   * Returns the list of staked CDN nodes, their stash accounts, and their cluster IDs.\n   *\n   * @returns A promise that resolves to the list of staked CDN nodes, their stash accounts, and their cluster IDs.\n   *\n   * @example\n   *\n   * ```typescript\n   * const stakedCdnNodes = await blockchain.ddcStaking.listStakedCdnNodesStashAccountsAndClusterIds();\n   *\n   * console.log(stakedCdnNodes);\n   * ```\n   */\n  async listStakedCdnNodesStashAccountsAndClusterIds() {\n    const result = await this.apiPromise.query.ddcStaking.cdNs.entries();\n    return result.map(([key, clusterId]) => ({\n      stashAccountId: key.args[0].toJSON() as unknown as AccountId,\n      clusterId: clusterId.toJSON() as unknown as ClusterId,\n    }));\n  }\n\n  /**\n   * Finds the cluster ID associated with a given storage node stash account ID.\n   *\n   * @param stashAccountId - The stash account ID of the storage node.\n   * @returns A promise that resolves to the cluster ID, or undefined if no cluster is found.\n   *\n   * @example\n   *\n   * ```typescript\n   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const clusterId = await blockchain.ddcStaking.findStakedClusterIdByStorageNodeStashAccountId(stashAccountId);\n   *\n   * console.log(clusterId);\n   * ```\n   */\n  async findStakedClusterIdByStorageNodeStashAccountId(stashAccountId: AccountId) {\n    const result = await this.apiPromise.query.ddcStaking.storages(stashAccountId);\n    return result.toJSON() as unknown as ClusterId | undefined;\n  }\n\n  /**\n   * Sets the controller account for the stash account.\n   *\n   * @param accountId - The account ID of the new controller.\n   * @returns An extrinsic to set the controller account.\n   *\n   * @example\n   *\n   * ```typescript\n   * const newControllerAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const tx = blockchain.ddcStaking.setController(newControllerAccountId);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  setController(accountId: AccountId) {\n    return this.apiPromise.tx.ddcStaking.setController(accountId) as Sendable;\n  }\n\n  /**\n   * Sets the storage node for the stash account.\n   *\n   * @param storageNodePublicKey - The public key of the storage node.\n   * @returns An extrinsic to set the storage node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const storageNodePublicKey = '0x...';\n   * const tx = blockchain.ddcStaking.setStorageNode(storageNodePublicKey);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  setStorageNode(storageNodePublicKey: StorageNodePublicKey) {\n    return this.apiPromise.tx.ddcStaking.setNode({ StoragePubKey: storageNodePublicKey }) as Sendable;\n  }\n\n  /**\n   * Stores the cluster ID.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @returns An extrinsic to store the cluster ID.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const tx = blockchain.ddcStaking.store(clusterId);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  store(clusterId: ClusterId) {\n    return this.apiPromise.tx.ddcStaking.store(clusterId) as Sendable;\n  }\n\n  /**\n   * Serves the cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @returns An extrinsic to serve the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const tx = blockchain.ddcStaking.serve(clusterId);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  serve(clusterId: ClusterId) {\n    return this.apiPromise.tx.ddcStaking.serve(clusterId) as Sendable;\n  }\n\n  /**\n   * Finds the staking ledger associated with a given controller account ID.\n   *\n   * @param controllerAccountId - The account ID of the controller.\n   * @returns A promise that resolves to the staking ledger, or undefined if no staking ledger is found.\n   *\n   * @example\n   *\n   * ```typescript\n   * const controllerAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const stakingLedger = await blockchain.ddcStaking.findStakingLedgerByControllerAccountId(controllerAccountId);\n   *\n   * console.log(stakingLedger);\n   * ```\n   */\n  async findStakingLedgerByControllerAccountId(controllerAccountId: AccountId) {\n    const result = await this.apiPromise.query.ddcStaking.ledger(controllerAccountId);\n    return result.toJSON() as unknown as StakingLedger | undefined;\n  }\n\n  /**\n   * Finds the controller account associated with a given stash account ID.\n   *\n   * @param stashAccountId - The account ID of the stash.\n   * @returns A promise that resolves to the controller account ID, or undefined if no controller account is found.\n   *\n   * @example\n   *\n   * ```typescript\n   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const controllerAccountId = await blockchain.ddcStaking.findControllerAccountByStashAccountId(stashAccountId);\n   *\n   * console.log(controllerAccountId);\n   * ```\n   */\n  async findControllerAccountByStashAccountId(stashAccountId: AccountId) {\n    const result = await this.apiPromise.query.ddcStaking.bonded(stashAccountId);\n    return result.toJSON() as unknown as AccountId | undefined;\n  }\n\n  /**\n   * Finds the node public key associated with a given stash account ID.\n   *\n   * @param stashAccountId - The account ID of the stash.\n   * @returns A promise that resolves to the node public key, or undefined if no node public key is found.\n   *\n   * @example\n   *\n   * ```typescript\n   * const stashAccountId = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n   * const nodePublicKey = await blockchain.ddcStaking.findNodePublicKeyByStashAccountId(stashAccountId);\n   *\n   * console.log(nodePublicKey);\n   * ```\n   */\n  async findNodePublicKeyByStashAccountId(stashAccountId: AccountId) {\n    const result = await this.apiPromise.query.ddcStaking.providers(stashAccountId);\n\n    return result.toJSON() as unknown as { storagePubKey: StorageNodePublicKey } | undefined;\n  }\n\n  /**\n   * Bonds the cluster.\n   *\n   * @param clusterId - The cluster ID to bond\n   * @returns An extrinsic to bond the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const tx = blockchain.ddcStaking.bondCluster(clusterId);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  bondCluster(clusterId: ClusterId) {\n    return this.apiPromise.tx.ddcStaking.bondCluster(clusterId) as Sendable;\n  }\n\n  /**\n   * Unbonds the cluster.\n   *\n   * @param clusterId - The cluster ID to bond\n   * @returns An extrinsic to unbond the cluster.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const tx = blockchain.ddcStaking.unbondCluster(clusterId);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  unbondCluster(clusterId: ClusterId) {\n    return this.apiPromise.tx.ddcStaking.unbondCluster(clusterId) as Sendable;\n  }\n\n  /**\n   * Withdraws unbonded cluster funds.\n   *\n   * @param clusterId - The cluster ID to withdraw\n   * @returns An extrinsic to withdraw the cluster funds.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const tx = blockchain.ddcStaking.withdrawUnbondedCluster(clusterId);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  withdrawUnbondedCluster(clusterId: ClusterId) {\n    return this.apiPromise.tx.ddcStaking.withdrawUnbondedCluster(clusterId) as Sendable;\n  }\n}\n","import { ApiPromise } from '@polkadot/api';\n\nimport { Sendable, Event } from './Blockchain';\nimport type { AccountId, Bucket, BucketId, BucketParams, ClusterId, StakingInfo } from './types';\n\n/**\n * This class provides methods to interact with the DDC Customers pallet on the blockchain.\n *\n * @group Pallets\n * @example\n *\n * ```typescript\n * const bucket = await blockchain.ddcCustomers.getBucket(1n);\n *\n * console.log(bucket);\n * ```\n */\nexport class DDCCustomersPallet {\n  constructor(private apiPromise: ApiPromise) {}\n\n  /**\n   * Returns the bucket with the given ID.\n   *\n   * @param bucketId - The ID of the bucket.\n   * @returns A promise that resolves to the bucket.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucket = await blockchain.ddcCustomers.getBucket(1n);\n   *\n   * console.log(bucket);\n   * ```\n   */\n  async getBucket(bucketId: BucketId) {\n    const result = await this.apiPromise.query.ddcCustomers.buckets(bucketId);\n    const bucket = result.toJSON() as unknown as Bucket | undefined;\n    return bucket == null ? undefined : ({ ...bucket, bucketId: BigInt(bucket.bucketId) } as Bucket);\n  }\n\n  /**\n   * Returns the number of buckets.\n   *\n   * @returns A promise that resolves to the number of buckets.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketsCount = await blockchain.ddcCustomers.getBucketsCount();\n   *\n   * console.log(bucketsCount);\n   * ```\n   */\n  async getBucketsCount() {\n    const result = await this.apiPromise.query.ddcCustomers.bucketsCount();\n    return result.toJSON() as number;\n  }\n\n  /**\n   * Returns the staking info for the given account in the specified cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param accountId - The ID of the account.\n   * @returns A promise that resolves to the staking info.\n   *\n   * @example\n   *\n   * ```typescript\n   * const stakingInfo = await blockchain.ddcCustomers.getStackingInfo('0x...', '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu');\n   *\n   * console.log(stakingInfo);\n   * ```\n   */\n  async getStackingInfo(clusterId: ClusterId, accountId: AccountId) {\n    const result = await this.apiPromise.query.ddcCustomers.clusterLedger(clusterId, accountId);\n    return result.toJSON() as unknown as StakingInfo | undefined;\n  }\n\n  /**\n   * Returns the staking info for the given account (legacy method - deprecated).\n   * This method is deprecated because the storage has migrated to cluster-based ledger.\n   * Use getStackingInfo(clusterId, accountId) instead.\n   *\n   * @deprecated Use getStackingInfo(clusterId, accountId) instead.\n   * @param accountId - The ID of the account.\n   * @returns A promise that resolves to the staking info.\n   */\n  async getStackingInfoLegacy(accountId: AccountId) {\n    // For backward compatibility, try to get from the first available cluster\n    // This is a fallback and should not be used in new code\n    const result = await this.apiPromise.query.ddcCustomers.ledger(accountId);\n    return result.toJSON() as unknown as StakingInfo | undefined;\n  }\n\n  /**\n   * Creates a new bucket.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param params - The bucket parameters.\n   * @returns An extrinsic to create the bucket.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.createBucket('0x...', { isPublic: true });\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  createBucket(clusterId: ClusterId, params: BucketParams) {\n    return this.apiPromise.tx.ddcCustomers.createBucket(clusterId, params) as unknown as Sendable;\n  }\n\n  /**\n   * Sets the parameters of the bucket with the given ID.\n   *\n   * @param bucketId - The ID of the bucket.\n   * @param params - The bucket parameters.\n   * @returns An extrinsic to set the bucket parameters.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.setBucketParams(1n, { isPublic: true });\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  setBucketParams(bucketId: BucketId, params: BucketParams) {\n    return this.apiPromise.tx.ddcCustomers.setBucketParams(bucketId, params) as unknown as Sendable;\n  }\n\n  /**\n   * Deposits funds to the account for the specified cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param value - The amount to deposit.\n   * @returns An extrinsic to deposit funds.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.deposit('0x...', 100n);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  deposit(clusterId: ClusterId, value: bigint) {\n    return this.apiPromise.tx.ddcCustomers.deposit(clusterId, value) as unknown as Sendable;\n  }\n\n  /**\n   * Deposits additional funds to the account for the specified cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param maxAdditional - The maximum amount to deposit.\n   * @returns An extrinsic to deposit additional funds.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.depositExtra('0x...', 100n);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  depositExtra(clusterId: ClusterId, maxAdditional: bigint) {\n    return this.apiPromise.tx.ddcCustomers.depositExtra(clusterId, maxAdditional) as unknown as Sendable;\n  }\n\n  /**\n   * Deposits funds to the target address for the specified cluster.\n   * This allows a third party to deposit funds on behalf of another address.\n   *\n   * @param targetAddress - The target address to deposit funds for.\n   * @param clusterId - The ID of the cluster.\n   * @param amount - The amount to deposit.\n   * @returns An extrinsic to deposit funds for the target address.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.depositFor('5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu', '0x...', 100n);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  depositFor(targetAddress: AccountId, clusterId: ClusterId, amount: bigint) {\n    return this.apiPromise.tx.ddcCustomers.depositFor(targetAddress, clusterId, amount) as unknown as Sendable;\n  }\n\n  /**\n   * Unlocks deposit funds from the account for the specified cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param value - The amount to unlock.\n   * @returns An extrinsic to unlock deposit funds.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.unlockDeposit('0x...', 100n);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  unlockDeposit(clusterId: ClusterId, value: bigint) {\n    return this.apiPromise.tx.ddcCustomers.unlockDeposit(clusterId, value) as unknown as Sendable;\n  }\n\n  /**\n   * Withdraws unlocked funds from the account for the specified cluster.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @returns An extrinsic to withdraw unlocked funds.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.withdrawUnlockedDeposit('0x...');\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  withdrawUnlockedDeposit(clusterId: ClusterId) {\n    return this.apiPromise.tx.ddcCustomers.withdrawUnlockedDeposit(clusterId) as unknown as Sendable;\n  }\n\n  /**\n   * Returns the list of buckets.\n   *\n   * @returns A promise that resolves to the list of buckets.\n   *\n   * @example\n   *\n   * ```typescript\n   * const buckets = await blockchain.ddcCustomers.listBuckets();\n   *\n   * console.log(buckets);\n   * ```\n   */\n  async listBuckets() {\n    const entries = (await this.apiPromise.query.ddcCustomers?.buckets.entries()) || [];\n    return entries\n      .map(([, bucketOption]) => {\n        const bucket = bucketOption.toJSON() as unknown as Bucket | undefined;\n        return bucket == null ? undefined : ({ ...bucket, bucketId: BigInt(bucket.bucketId) } as Bucket);\n      })\n      .filter((bucket) => bucket !== undefined) as Bucket[];\n  }\n\n  /**\n   * Extracts the IDs of the created buckets from the given events.\n   *\n   * @param events - The events to extract the bucket IDs from.\n   * @returns The IDs of the created buckets.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketIds = blockchain.ddcCustomers.extractCreatedBucketIds(events);\n   *\n   * console.log(bucketIds);\n   * ```\n   */\n  extractCreatedBucketIds(events: Event[]) {\n    return events\n      .filter((event) => event.section === 'ddcCustomers' && event.method === 'BucketCreated')\n      .map((event) => event.payload?.bucket_id)\n      .filter(Boolean)\n      .map(BigInt);\n  }\n\n  /**\n   * Mark existing buckets with specified bucket ids as removed.\n   *\n   * @param bucketIds - The IDs of the buckets to remove.\n   * @returns An extrinsic to remove the buckets.\n   *\n   * @example\n   *\n   * ```typescript\n   * const tx = blockchain.ddcCustomers.removeBuckets(1n, 2n);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  removeBuckets(...bucketIds: BucketId[]) {\n    if (bucketIds.length === 0) {\n      throw new Error('At least one bucket ID must be provided');\n    } else if (bucketIds.length === 1) {\n      return this.apiPromise.tx.ddcCustomers.removeBucket(bucketIds[0]) as unknown as Sendable;\n    }\n\n    return this.apiPromise.tx.utility.batch(\n      bucketIds.map((bucketId) => this.apiPromise.tx.ddcCustomers.removeBucket(bucketId)),\n    ) as unknown as Sendable;\n  }\n\n  /**\n   * Extracts the IDs of the removed buckets from the given events.\n   *\n   * @param events - The events to extract the bucket IDs from.\n   * @returns The IDs of the removed buckets.\n   *\n   * @example\n   *\n   * ```typescript\n   * const bucketIds = blockchain.ddcCustomers.extractRemovedBucketIds(events);\n   *\n   * console.log(bucketIds);\n   * ```\n   */\n  extractRemovedBucketIds(events: Event[]) {\n    return events\n      .filter((event) => event.section === 'ddcCustomers' && event.method === 'BucketRemoved')\n      .map((event) => event.payload?.bucket_id)\n      .filter(Boolean)\n      .map(BigInt);\n  }\n}\n","import { ApiPromise } from '@polkadot/api';\nimport { Sendable } from './Blockchain';\nimport { ClusterId, ClusterMember, ClusterProtocolParams, NodePublicKey, ReferendumIndex } from './types';\n\n/**\n * This class provides methods to interact with the DDC Cluster Goverment pallet on the blockchain.\n *\n * @group Pallets\n * @example\n *\n * ```typescript\n * const clusterId = '0x...';\n * const protocolParams = { ... };\n * const member = ClusterMember.ClusterManager;\n *\n * const tx = blockchain.ddcClusterGov.proposeUpdateClusterProtocol(clusterId, protocolParams, member);\n *\n * await blockchain.send(tx, { account });\n * ```\n */\nexport class DDCClustersGovPallet {\n  constructor(private apiPromise: ApiPromise) {}\n\n  /**\n   * Creates a local proposal within a cluster, intended to activate the cluster in the network with specific protocol parameters such as validators, treasury fees, and pricing for stored and streamed bytes.\n   * Only cluster members, namely the cluster manager and node providers, have voting rights on this proposal.\n   * Furthermore, only the cluster manager has the authority to create this type of proposal.\n   *\n   * @param clusterId - The ID of the cluster.\n   */\n  proposeActivateClusterProtocol(clusterId: ClusterId, protocolParams: ClusterProtocolParams) {\n    return this.apiPromise.tx.ddcClusterGov.proposeActivateClusterProtocol(clusterId, protocolParams) as Sendable;\n  }\n\n  /**\n   * Creates a local proposal within a cluster, intended to update protocol parameters (like validators, treasury fee, pricing for stored and streamed bytes, etc.) of a previously activated cluster in the network.\n   * Only cluster members, such as the cluster manager and node providers, can vote on this type of proposal.\n   * Any cluster member has the ability to create this type of proposal.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param protocolParams - The new protocol parameters.\n   * @param member - The member who is creating the proposal.\n   * @param nodePublicKey - The public key of the node provider. Needed in case the member is ClusterMember.NodeProvider.\n   *\n   * @returns An extrinsic to propose the update of the cluster protocol.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const protocolParams = { ... };\n   * const member = ClusterMember.ClusterManager;\n   *\n   * const tx = blockchain.ddcClusterGov.proposeUpdateClusterProtocol(clusterId, protocolParams, member);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  proposeUpdateClusterProtocol(\n    clusterId: ClusterId,\n    protocolParams: ClusterProtocolParams,\n    member: ClusterMember,\n    nodePublicKey?: NodePublicKey,\n  ): Sendable {\n    return this.apiPromise.tx.ddcClusterGov.proposeUpdateClusterProtocol(\n      clusterId,\n      protocolParams,\n      this.createClusterMember(member, nodePublicKey),\n    ) as Sendable;\n  }\n\n  /**\n   * Votes for a local proposal within a cluster. Only cluster members, such as the cluster manager and node providers, are permitted to vote.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param approve - Whether to approve the proposal.\n   * @param member - The member who is voting.\n   * @param nodePublicKey - The public key of the node provider. Needed in case the member is ClusterMember.NodeProvider.\n   *\n   * @returns An extrinsic to vote on the proposal.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const approve = true;\n   * const member = ClusterMember.ClusterManager;\n   *\n   * const tx = blockchain.ddcClusterGov.voteProposal(clusterId, approve, member);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  voteProposal(clusterId: ClusterId, approve: boolean, member: ClusterMember, nodePublicKey?: NodePublicKey) {\n    return this.apiPromise.tx.ddcClusterGov.voteProposal(\n      clusterId,\n      approve,\n      this.createClusterMember(member, nodePublicKey),\n    ) as Sendable;\n  }\n\n  /**\n   * This method allows to retract a local proposal within a cluster. Only the proposal's author can submit it.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @param member - The member who is retracting the proposal.\n   * @param nodePublicKey - The public key of the node provider. Needed in case the member is ClusterMember.NodeProvider.\n   * @returns An extrinsic to retract the proposal.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const member = ClusterMember.ClusterManager;\n   *\n   * const tx = blockchain.ddcClusterGov.retractProposal(clusterId, member);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  closeProposal(clusterId: ClusterId, member: ClusterMember, nodePublicKey?: NodePublicKey) {\n    return this.apiPromise.tx.ddcClusterGov.closeProposal(\n      clusterId,\n      this.createClusterMember(member, nodePublicKey),\n    ) as Sendable;\n  }\n\n  /**\n   * Closes a local proposal within a cluster. If the required approval threshold is met, it will automatically initiate a public referendum in the OpenGov.\n   * Here, any CERE token holder can vote on the cluster's proposal, thereby influencing the network's economics.\n   * If the required approval threshold is not met, the local (internal) proposal will be withdrawn without initiating a public referendum.\n   * Any cluster member can close the proposal once the approval threshold or expiration time is reached.\n   *\n   * @param clusterId - The ID of the cluster.\n   * @returns An extrinsic to retract the proposal.\n   *\n   * @example\n   *\n   * ```typescript\n   * const clusterId = '0x...';\n   * const tx = blockchain.ddcClusterGov.retractProposal(clusterId);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  retractProposal(clusterId: ClusterId) {\n    return this.apiPromise.tx.ddcClusterGov.retractProposal(clusterId) as Sendable;\n  }\n\n  /**\n   * Refunds the submission deposit made by the proposal's author when creating a local proposal.\n   *\n   * @param referendaIndex - The index of the referendum.\n   *\n   * @returns An extrinsic to refund the submission deposit.\n   *\n   * @example\n   *\n   * ```typescript\n   * const referendaIndex = 0;\n   * const tx = blockchain.ddcClusterGov.refundSubmissionDeposit(referendaIndex);\n   *\n   * await blockchain.send(tx, { account });\n   * ```\n   */\n  refundSubmissionDeposit(referendaIndex: ReferendumIndex) {\n    return this.apiPromise.tx.ddcClusterGov.refundSubmissionDeposit(referendaIndex) as Sendable;\n  }\n\n  private createClusterMember(member: ClusterMember, nodePublicKey?: NodePublicKey) {\n    if (member === ClusterMember.ClusterManager) {\n      return ClusterMember.ClusterManager;\n    }\n\n    if (!nodePublicKey) {\n      throw new Error('Node public key is required to create a cluster member enum.');\n    }\n\n    return {\n      [ClusterMember.NodeProvider]: nodePublicKey,\n    };\n  }\n}\n","import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { AddressOrPair, SignerOptions, ApiOptions } from '@polkadot/api/types';\nimport { Index, AccountInfo } from '@polkadot/types/interfaces';\nimport { SubmittableExtrinsic } from '@polkadot/api-base/types';\nimport { formatBalance } from '@polkadot/util';\n\nimport { AccountId } from './types';\nimport { Signer } from './Signer';\nimport { DDCNodesPallet } from './DDCNodesPallet';\nimport { DDCClustersPallet } from './DDCClustersPallet';\nimport { DDCStakingPallet } from './DDCStakingPallet';\nimport { DDCCustomersPallet } from './DDCCustomersPallet';\nimport { DDCClustersGovPallet } from './DDCClustersGovPallet';\n\nexport type SendOptions = Pick<Partial<SignerOptions>, 'nonce' | 'signer'> & {\n  account: AddressOrPair | Signer;\n};\n\nexport type BlockchainConnectOptions =\n  | {\n      apiPromise: ApiPromise;\n    }\n  | {\n      wsEndpoint: string;\n      apiOptions?: Omit<ApiOptions, 'provider'>;\n    };\n\n/**\n * This class provides methods to interact with the Cere blockchain.\n *\n * @group Blockchain\n * @example\n *\n * ```typescript\n * const blockchain = await Blockchain.connect({ wsEndpoint: 'wss://rpc.testnet.cere.network/ws' });\n * const account = '5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu';\n * const balance = await blockchain.getAccountFreeBalance(account);\n *\n * console.log(balance);\n * ```\n */\nexport class Blockchain {\n  readonly api: ApiPromise;\n\n  /**\n   * The DDC Nodes pallet.\n   *\n   * @category Pallets\n   */\n  readonly ddcNodes: DDCNodesPallet;\n\n  /**\n   * The DDC Clusters pallet.\n   *\n   * @category Pallets\n   */\n  readonly ddcClusters: DDCClustersPallet;\n\n  /**\n   * The DDC Staking pallet.\n   *\n   * @category Pallets\n   */\n  readonly ddcStaking: DDCStakingPallet;\n\n  /**\n   * The DDC Customers pallet.\n   *\n   * @category Pallets\n   */\n  readonly ddcCustomers: DDCCustomersPallet;\n\n  /**\n   * The DDC Cluster government pallet.\n   *\n   * @category Pallets\n   */\n  readonly ddcClustersGov: DDCClustersGovPallet;\n\n  constructor(options: BlockchainConnectOptions) {\n    this.api =\n      'apiPromise' in options\n        ? options.apiPromise\n        : new ApiPromise({\n            provider: new WsProvider(options.wsEndpoint),\n            ...options.apiOptions,\n          });\n\n    this.ddcNodes = new DDCNodesPallet(this.api);\n    this.ddcClusters = new DDCClustersPallet(this.api);\n    this.ddcStaking = new DDCStakingPallet(this.api);\n    this.ddcCustomers = new DDCCustomersPallet(this.api);\n    this.ddcClustersGov = new DDCClustersGovPallet(this.api);\n  }\n\n  /**\n   * Connects to the blockchain and returns a new instance of the Blockchain class.\n   *\n   * @param options - Options for connecting to the blockchain.\n   * @returns A promise that resolves to a new instance of the Blockchain class.\n   *\n   * Example usage:\n   * ```typescript\n   * const blockchain = await Blockchain.connect({ wsEndpoint: 'wss://rpc.testnet.cere.network/ws' });\n   * ```\n   */\n  static async connect(options: BlockchainConnectOptions) {\n    const blockchain = new Blockchain(options);\n    await blockchain.isReady();\n\n    return blockchain;\n  }\n\n  /**\n   * Checks if the blockchain is ready.\n   *\n   * @returns A promise that resolves to `true` if the blockchain is ready.\n   *\n   * @example\n   * ```typescript\n   * const isReady = await blockchain.isReady();\n   * console.log(isReady);\n   * ```\n   */\n  async isReady() {\n    await this.api.isReady;\n\n    return true;\n  }\n\n  /**\n   * The decimals of the chain's native token.\n   */\n  get chainDecimals() {\n    const [decimals] = this.api.registry.chainDecimals;\n\n    return decimals;\n  }\n\n  /**\n   * Retrieves the next nonce for an account.\n   *\n   * @param address - The address of the account.\n   * @returns A promise that resolves to the next nonce for the account.\n   *\n   * Example usage:\n   * ```typescript\n   * const nonce = await blockchain.getNextNonce('5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu');\n   *\n   * console.log(nonce);\n   * ```\n   */\n  async getNextNonce(address: string | AccountId) {\n    const nonce = await this.api.rpc.system.accountNextIndex<Index>(address);\n\n    return nonce.toNumber();\n  }\n\n  /**\n   * Sends a transaction to the blockchain.\n   *\n   * @param sendable - The transaction to send.\n   * @param options - Options for sending the transaction.\n   * @returns A promise that resolves to the result of the transaction.\n   *\n   * Example usage:\n   * ```typescript\n   * const account = new UriSigner('//Alice');\n   * const tx = blockchain.ddcCustomers.createBucket('0x...', { isPublic: true });\n   *\n   * const result = await blockchain.send(sendable, { account });\n   *\n   * console.log(result);\n   * ```\n   */\n  async send(sendable: Sendable, { account, nonce, signer }: SendOptions) {\n    let finalAccount: AddressOrPair;\n    let finalSigner = signer;\n\n    /**\n     * If the account is a Signer instance, we need to convert it to a blockchain signer\n     */\n    if (Signer.isSigner(account)) {\n      finalSigner ||= await account.getSigner();\n      finalAccount = account.address;\n    } else {\n      finalAccount = account;\n    }\n\n    return new Promise<SendResult>((resolve, reject) => {\n      sendable\n        .signAndSend(finalAccount, { nonce, signer: finalSigner }, (result) => {\n          if (result.status.isFinalized) {\n            const events: Event[] = result.events.map(({ event }) => ({\n              method: event.method,\n              section: event.section,\n              meta: event.meta.toJSON(),\n              data: event.data.toJSON(),\n              payload: Object.fromEntries(\n                event.meta.fields.map((field, index) => [field.name, event.data[index].toJSON()]),\n              ),\n            }));\n\n            resolve({\n              events,\n              txHash: result.status.asFinalized.toHex(),\n            });\n          } else if (result.dispatchError) {\n            let errorMessage: string;\n\n            if (result.dispatchError.isModule) {\n              const decoded = this.api.registry.findMetaError(result.dispatchError.asModule);\n              errorMessage = `${decoded.section}.${decoded.name}: ${decoded.docs.join(' ')}`;\n            } else {\n              errorMessage = result.dispatchError.toString();\n            }\n            reject(new Error(errorMessage));\n          }\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Sends a batch of transactions to the blockchain.\n   * The transactions are sent in a single batch and are executed in the order they are provided.\n   * If one transaction in the batch fails, the rest of the transactions in the batch will still be processed. The batch itself does not fail.\n   *\n   * @param sendables - The transactions to send.\n   * @param options - Options for sending the transactions.\n   * @returns A promise that resolves to the result of the batch of transactions.\n   *\n   * @example\n   *\n   * ```typescript\n   * const account = new UriSigner('//Alice');\n   * const tx1 = blockchain.ddcCustomers.createBucket('0x...');\n   * const tx2 = blockchain.ddcCustomers.createBucket('0x...');\n   *\n   * const result = await blockchain.batchSend([tx1, tx2], { account });\n   *\n   * console.log(result);\n   * ```\n   */\n  batchSend(sendables: Sendable[], options: SendOptions) {\n    return this.send(this.api.tx.utility.batch(sendables), options);\n  }\n\n  /**\n   * Sends a batch of transactions to the blockchain.\n   * The transactions are sent in a single batch and are executed in the order they are provided.\n   * If one transaction in the batch fails, the entire batch fails and no further transactions in the batch are processed.\n   *\n   * @param sendables - The transactions to send.\n   * @param options - Options for sending the transactions.\n   * @returns A promise that resolves to the result of the batch of transactions.\n   *\n   * @example\n   *\n   * ```typescript\n   * const account = new UriSigner('//Alice');\n   * const tx1 = blockchain.ddcCustomers.createBucket('0x...');\n   * const tx2 = blockchain.ddcCustomers.createBucket('0x...');\n   *\n   * const result = await blockchain.batchAllSend([tx1, tx2], { account });\n   *\n   * console.log(result);\n   * ```\n   */\n  batchAllSend(sendables: Sendable[], options: SendOptions) {\n    return this.send(this.api.tx.utility.batchAll(sendables), options);\n  }\n\n  sudo(sendable: Sendable) {\n    return this.api.tx.sudo.sudo(sendable) as Sendable;\n  }\n\n  sudoAs(who: AccountId, sendable: Sendable) {\n    return this.api.tx.sudo.sudoAs(who, sendable) as Sendable;\n  }\n\n  /**\n   * Disconnects from the blockchain.\n   *\n   * @returns A promise that resolves when the connection is closed.\n   *\n   * @example\n   * ```typescript\n   * await blockchain.disconnect();\n   * ```\n   */\n  disconnect() {\n    return this.api.disconnect();\n  }\n\n  formatBalance(balance: string | number | bigint, withUnit: boolean | string = 'CERE') {\n    return formatBalance(balance, { withSiFull: true, decimals: this.chainDecimals, withUnit });\n  }\n\n  /**\n   * Retrieves the free balance of an account.\n   *\n   * @param accountId - The account ID.\n   * @returns A promise that resolves to the free balance of the account.\n   *\n   * @example\n   * ```typescript\n   * const balance = await blockchain.getAccountFreeBalance('5D5PhZQNJzcJXVBxwJxZcsutjKPqUPydrvpu6HeiBfMae2Qu');\n   *\n   * console.log(balance);\n   * ```\n   */\n  async getAccountFreeBalance(accountId: AccountId) {\n    const { data } = await this.api.query.system.account<AccountInfo>(accountId);\n    return data.free.toBigInt();\n  }\n\n  /**\n   * Retrieves the current block number.\n   *\n   * @returns A promise that resolves to the current block number.\n   *\n   * Example usage:\n   * ```typescript\n   * const blockchain = await Blockchain.connect({ wsEndpoint: 'wss://rpc.testnet.cere.network/ws' });\n   * const blockNumber = await blockchain.getCurrentBlockNumber();\n   *\n   * console.log(blockNumber);\n   * ```\n   */\n  async getCurrentBlockNumber() {\n    const { number } = await this.api.rpc.chain.getHeader();\n    return number.toNumber();\n  }\n}\n\nexport type Sendable = SubmittableExtrinsic<'promise'>;\n\nexport type SendResult = {\n  events: Event[];\n  txHash: string;\n};\n\nexport type Event = {\n  section: string;\n  method: string;\n  data?: any;\n  payload?: Record<string, any>;\n};\n"],"names":["ClusterStatus","ClusterMember","StorageNodeMode","ClusterNodeKind","Signer","unlock","passphrase","isSigner","signer","CERE_SS58_PREFIX","KeyringSigner","constructor","pair","super","this","isReady","isLocked","Error","createPair","cryptoWaitReady","getPair","type","address","publicKey","sign","data","getSigner","_this","signRaw","async","signature","withType","id","u8aToHex","UriSigner","uri","options","Keyring","ss58Format","addFromUri","create","Web3Signer","extensions","autoConnect","originName","accountIndex","accountAddress","injectedAccount","encodeAddress","account","decodeAddress","getInjector","web3FromAddress","message","injector","u8aWrapBytes","hexToU8a","connect","web3Enable","accounts","web3Accounts","accountType","find","web3EnablePromise","ignoreChecksum","cryptoUtil","createRandomSigner","mnemonicGenerate","CereWalletSigner","wallet","extensionPromise","setAccount","enable","then","injected","get","subscribe","syncAccount","Promise","all","connectOptions","JsonSigner","keyPair","addFromJson","DDCNodesPallet","apiPromise","createStorageNode","storageNodePublicKey","storageNodeProps","tx","ddcNodes","createNode","StoragePubKey","StorageParams","encodeNodeProps","_extends","domain","ssl","findStorageNodeByPublicKey","storageNode","query","storageNodes","toJSON","undefined","props","decodeNodeProps","listStorageNodes","entries","map","storageNodeOption","filter","setStorageNodeProps","setNodeParams","deleteStorageNode","deleteNode","nodeProps","host","hexToString","stringToHex","DDCClustersPallet","listClusters","_this$apiPromise$quer","ddcClusters","clusters","clusterOption","filterNodeKeysByClusterId","clusterId","clustersNodes","key","args","asStoragePubKey","clusterHasStorageNode","isEmpty","createCluster","clusterReserveId","clusterParams","clusterGovernmentParams","nodeProviderAuthContract","erasureCodingRequired","erasureCodingTotal","replicationTotal","findClusterById","setClusterParams","addStorageNodeToCluster","nodeKind","addNode","removeStorageNodeFromCluster","removeNode","getClusterGovernmentParams","clustersGovParams","DDCStakingPallet","bondStorageNode","controller","bondAmount","ddcStaking","bond","chill","fastChillStorage","fastChill","unbond","amount","withdrawUnbonded","findStashAccountIdByStorageNodePublicKey","nodes","listStakedStorageNodesStashAccountsAndClusterIds","storages","stashAccountId","findStakedClusterIdByCdnNodeStashAccountId","cdNs","listStakedCdnNodesStashAccountsAndClusterIds","findStakedClusterIdByStorageNodeStashAccountId","setController","accountId","setStorageNode","setNode","store","serve","findStakingLedgerByControllerAccountId","controllerAccountId","ledger","findControllerAccountByStashAccountId","bonded","findNodePublicKeyByStashAccountId","providers","bondCluster","unbondCluster","withdrawUnbondedCluster","DDCCustomersPallet","getBucket","bucketId","bucket","ddcCustomers","buckets","BigInt","getBucketsCount","bucketsCount","getStackingInfo","clusterLedger","getStackingInfoLegacy","createBucket","params","setBucketParams","deposit","value","depositExtra","maxAdditional","depositFor","targetAddress","unlockDeposit","withdrawUnlockedDeposit","listBuckets","bucketOption","extractCreatedBucketIds","events","event","section","method","_event$payload","payload","bucket_id","Boolean","removeBuckets","bucketIds","length","removeBucket","utility","batch","extractRemovedBucketIds","_event$payload2","DDCClustersGovPallet","proposeActivateClusterProtocol","protocolParams","ddcClusterGov","proposeUpdateClusterProtocol","member","nodePublicKey","createClusterMember","voteProposal","approve","closeProposal","retractProposal","refundSubmissionDeposit","referendaIndex","ClusterManager","NodeProvider","Blockchain","api","ddcClustersGov","ApiPromise","provider","WsProvider","wsEndpoint","apiOptions","blockchain","chainDecimals","decimals","registry","getNextNonce","rpc","system","accountNextIndex","toNumber","send","sendable","nonce","finalAccount","finalSigner","resolve","reject","signAndSend","result","status","isFinalized","meta","Object","fromEntries","fields","field","index","name","txHash","asFinalized","toHex","dispatchError","errorMessage","isModule","decoded","findMetaError","asModule","docs","join","toString","catch","batchSend","sendables","batchAllSend","batchAll","sudo","sudoAs","who","disconnect","formatBalance","balance","withUnit","withSiFull","getAccountFreeBalance","free","toBigInt","getCurrentBlockNumber","number","chain","getHeader"],"mappings":"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"}