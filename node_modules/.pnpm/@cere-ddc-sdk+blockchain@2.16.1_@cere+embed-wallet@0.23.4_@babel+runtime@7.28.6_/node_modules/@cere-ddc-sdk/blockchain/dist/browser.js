import{ApiPromise as t,WsProvider as e}from"@polkadot/api";import{u8aToHex as s,u8aWrapBytes as r,hexToU8a as i,hexToString as o,stringToHex as a,formatBalance as n}from"@polkadot/util";import{Keyring as d}from"@polkadot/keyring";import*as c from"@polkadot/util-crypto";import{cryptoWaitReady as u,encodeAddress as h,decodeAddress as p}from"@polkadot/util-crypto";export{cryptoWaitReady}from"@polkadot/util-crypto";import{web3FromAddress as l,web3Enable as m,web3Accounts as g,web3EnablePromise as y}from"@polkadot/extension-dapp";import{enable as P}from"@cere/embed-wallet-inject";var S,w,C,v;function k(){return k=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var r in s)({}).hasOwnProperty.call(s,r)&&(t[r]=s[r])}return t},k.apply(null,arguments)}!function(t){t.Unbonded="Unbonded",t.Bonded="Bonded",t.Activated="Activated",t.Unbonding="Unbonding"}(S||(S={})),function(t){t.ClusterManager="ClusterManager",t.NodeProvider="NodeProvider"}(w||(w={})),function(t){t.Full="Full",t.Storage="Storage",t.Cache="Cache"}(C||(C={})),function(t){t.Genesis="Genesis",t.External="External"}(v||(v={}));class N{async unlock(t){}static isSigner(t){return!(!t||"object"!=typeof t)&&(t instanceof N||"isReady"in t&&"sign"in t&&"getSigner"in t)}}const b=54;class x extends N{constructor(t){super(),this.pair=void 0,this.pair=t,this.isReady()}get isLocked(){if(!this.pair)throw new Error("Key pair is not ready!");return this.pair.isLocked}async unlock(t){if(await this.isReady(),!this.pair)throw new Error("Key pair is not ready!");this.pair.isLocked&&this.pair.unlock(t)}createPair(){if(!this.pair)throw new Error("Key pair is not provided!");return this.pair}async isReady(){return!!this.pair||!!await u()&&(this.pair=this.createPair(),!0)}getPair(){if(this.pair)return this.pair;throw new Error("Signer is not ready")}get type(){return this.getPair().type}get address(){return this.getPair().address}get publicKey(){return this.getPair().publicKey}async sign(t){return this.getPair().sign(t)}async getSigner(){var t=this;return{signRaw:async function({data:e}){const r=t.getPair().sign(e,{withType:!0});return{id:0,signature:s(r)}}}}}class f extends x{constructor(t,e={}){super(),this.uri=void 0,this.options=void 0,this.uri=t,this.options=e}createPair(){return new d({ss58Format:b,type:this.type}).addFromUri(this.uri)}get type(){return this.options.type||"sr25519"}static async create(t,e={}){const s=new f(t,e);return await s.isReady(),s}}class A extends N{constructor({address:t,extensions:e,autoConnect:s=!0,originName:r="DDC",accountIndex:i=0}={}){super(),this.accountAddress=void 0,this.accountIndex=void 0,this.originName=void 0,this.autoConnect=void 0,this.injectedAccount=void 0,this.extensions=void 0,this.accountAddress=t,this.originName=r,this.autoConnect=s,this.accountIndex=i,this.extensions=e}get isLocked(){return!1}get address(){return this.accountAddress||h(this.account.address,b)}get publicKey(){return p(this.address,!0,b)}get type(){return this.account.type||"sr25519"}get account(){if(!this.injectedAccount)throw new Error("Web3Signer account is not ready");return this.injectedAccount}async getInjector(){return l(this.address)}async getSigner(){const{signer:t}=await this.getInjector();return t}async sign(t){const e=await this.getInjector();if(!e.signer.signRaw)throw new Error("Signer does not support signing raw messages");const o=s(r(t)),{signature:a}=await e.signer.signRaw({address:this.address,data:o,type:"bytes"});return i(a)}async connect(){await m(this.originName);const t=await g({extensions:this.extensions,accountType:["ed25519","sr25519"]});if(this.injectedAccount=this.accountAddress?t.find(t=>t.address===this.accountAddress):t[this.accountIndex],!this.injectedAccount)throw new Error("Web3Signer account cannot be detected");return this}async isReady(){return await u(),this.injectedAccount||(this.autoConnect&&await this.connect(),await y),!0}}const I=(t,e)=>c.decodeAddress(t,e,b),B=t=>c.encodeAddress(t,b),O=(t={})=>{const e=c.mnemonicGenerate();return new f(e,t)};class J extends A{constructor(t,e={}){super(e),this.wallet=void 0,this.options=void 0,this.extensionPromise=void 0,this.setAccount=([t])=>{this.injectedAccount=t},this.wallet=t,this.options=e,this.extensionPromise=P(this.wallet,{autoConnect:!1}).then(t=>(t.accounts.get().then(this.setAccount),t.accounts.subscribe(this.setAccount),t))}async syncAccount(){const{accounts:t}=await this.extensionPromise;await t.get().then(this.setAccount)}async getInjector(){return this.extensionPromise}async isReady(){return await Promise.all([this.extensionPromise,u()]),this.injectedAccount||(this.autoConnect&&await this.connect(this.options.connectOptions),await this.syncAccount()),!0}async connect(t){return await this.wallet.connect(t),await this.syncAccount(),this}}class E extends x{constructor(t,e={}){super(),this.account=void 0,this.options=void 0,this.account=t,this.options=e}createPair(){const t=new d({ss58Format:b}).addFromJson(this.account);return this.options.passphrase&&t.unlock(this.options.passphrase),t}static async create(t){const e=new E(t);return await e.isReady(),e}}class q{constructor(t){this.apiPromise=void 0,this.apiPromise=t}createStorageNode(t,e){return this.apiPromise.tx.ddcNodes.createNode({StoragePubKey:t},{StorageParams:R(k({},{domain:"",ssl:!1},e))})}async findStorageNodeByPublicKey(t){const e=(await this.apiPromise.query.ddcNodes.storageNodes(t)).toJSON();return null==e?void 0:k({},e,{props:K(e.props)})}async listStorageNodes(){return(await this.apiPromise.query.ddcNodes.storageNodes.entries()).map(([,t])=>{const e=t.toJSON();return null==e?void 0:k({},e,{props:K(e.props)})}).filter(t=>null!=t)}setStorageNodeProps(t,e){return this.apiPromise.tx.ddcNodes.setNodeParams({StoragePubKey:t},{StorageParams:R(e)})}deleteStorageNode(t){return this.apiPromise.tx.ddcNodes.deleteNode({StoragePubKey:t})}}function K(t){return k({},t,{host:o(t.host),domain:o(t.domain)})}function R(t){return k({},t,{host:a(t.host),domain:a(t.domain)})}class j{constructor(t){this.apiPromise=void 0,this.apiPromise=t}async listClusters(){var t;return(await(null==(t=this.apiPromise.query.ddcClusters)?void 0:t.clusters.entries())||[]).map(([,t])=>t.toJSON())}async filterNodeKeysByClusterId(t){return(await this.apiPromise.query.ddcClusters.clustersNodes.entries(t)).map(([t])=>t.args[1].asStoragePubKey.toJSON())}async clusterHasStorageNode(t,e){return!(await this.apiPromise.query.ddcClusters.clustersNodes(t,{StoragePubKey:e})).isEmpty}createCluster(t,e,s,r){return this.apiPromise.tx.ddcClusters.createCluster(t,e,k({},{nodeProviderAuthContract:null,erasureCodingRequired:16,erasureCodingTotal:48,replicationTotal:20},s),r)}async findClusterById(t){return(await this.apiPromise.query.ddcClusters.clusters(t)).toJSON()}setClusterParams(t,e){return this.apiPromise.tx.ddcClusters.setClusterParams(t,e)}addStorageNodeToCluster(t,e,s){return this.apiPromise.tx.ddcClusters.addNode(t,{StoragePubKey:e},s)}removeStorageNodeFromCluster(t,e){return this.apiPromise.tx.ddcClusters.removeNode(t,{StoragePubKey:e})}async getClusterGovernmentParams(t){return(await this.apiPromise.query.ddcClusters.clustersGovParams(t)).toJSON()}}class U{constructor(t){this.apiPromise=void 0,this.apiPromise=t}bondStorageNode(t,e,s){return this.apiPromise.tx.ddcStaking.bond(t,{StoragePubKey:e},s)}chill(){return this.apiPromise.tx.ddcStaking.chill()}fastChillStorage(){return this.apiPromise.tx.ddcStaking.fastChill()}unbond(t){return this.apiPromise.tx.ddcStaking.unbond(t)}withdrawUnbonded(){return this.apiPromise.tx.ddcStaking.withdrawUnbonded()}async findStashAccountIdByStorageNodePublicKey(t){return(await this.apiPromise.query.ddcStaking.nodes({StoragePubKey:t})).toJSON()}async listStakedStorageNodesStashAccountsAndClusterIds(){return(await this.apiPromise.query.ddcStaking.storages.entries()).map(([t,e])=>({stashAccountId:t.args[0].toJSON(),clusterId:e.toJSON()}))}async findStakedClusterIdByCdnNodeStashAccountId(t){return(await this.apiPromise.query.ddcStaking.cdNs(t)).toJSON()}async listStakedCdnNodesStashAccountsAndClusterIds(){return(await this.apiPromise.query.ddcStaking.cdNs.entries()).map(([t,e])=>({stashAccountId:t.args[0].toJSON(),clusterId:e.toJSON()}))}async findStakedClusterIdByStorageNodeStashAccountId(t){return(await this.apiPromise.query.ddcStaking.storages(t)).toJSON()}setController(t){return this.apiPromise.tx.ddcStaking.setController(t)}setStorageNode(t){return this.apiPromise.tx.ddcStaking.setNode({StoragePubKey:t})}store(t){return this.apiPromise.tx.ddcStaking.store(t)}serve(t){return this.apiPromise.tx.ddcStaking.serve(t)}async findStakingLedgerByControllerAccountId(t){return(await this.apiPromise.query.ddcStaking.ledger(t)).toJSON()}async findControllerAccountByStashAccountId(t){return(await this.apiPromise.query.ddcStaking.bonded(t)).toJSON()}async findNodePublicKeyByStashAccountId(t){return(await this.apiPromise.query.ddcStaking.providers(t)).toJSON()}bondCluster(t){return this.apiPromise.tx.ddcStaking.bondCluster(t)}unbondCluster(t){return this.apiPromise.tx.ddcStaking.unbondCluster(t)}withdrawUnbondedCluster(t){return this.apiPromise.tx.ddcStaking.withdrawUnbondedCluster(t)}}class F{constructor(t){this.apiPromise=void 0,this.apiPromise=t}async getBucket(t){const e=(await this.apiPromise.query.ddcCustomers.buckets(t)).toJSON();return null==e?void 0:k({},e,{bucketId:BigInt(e.bucketId)})}async getBucketsCount(){return(await this.apiPromise.query.ddcCustomers.bucketsCount()).toJSON()}async getStackingInfo(t,e){return(await this.apiPromise.query.ddcCustomers.clusterLedger(t,e)).toJSON()}async getStackingInfoLegacy(t){return(await this.apiPromise.query.ddcCustomers.ledger(t)).toJSON()}createBucket(t,e){return this.apiPromise.tx.ddcCustomers.createBucket(t,e)}setBucketParams(t,e){return this.apiPromise.tx.ddcCustomers.setBucketParams(t,e)}deposit(t,e){return this.apiPromise.tx.ddcCustomers.deposit(t,e)}depositExtra(t,e){return this.apiPromise.tx.ddcCustomers.depositExtra(t,e)}depositFor(t,e,s){return this.apiPromise.tx.ddcCustomers.depositFor(t,e,s)}unlockDeposit(t,e){return this.apiPromise.tx.ddcCustomers.unlockDeposit(t,e)}withdrawUnlockedDeposit(t){return this.apiPromise.tx.ddcCustomers.withdrawUnlockedDeposit(t)}async listBuckets(){var t;return(await(null==(t=this.apiPromise.query.ddcCustomers)?void 0:t.buckets.entries())||[]).map(([,t])=>{const e=t.toJSON();return null==e?void 0:k({},e,{bucketId:BigInt(e.bucketId)})}).filter(t=>void 0!==t)}extractCreatedBucketIds(t){return t.filter(t=>"ddcCustomers"===t.section&&"BucketCreated"===t.method).map(t=>{var e;return null==(e=t.payload)?void 0:e.bucket_id}).filter(Boolean).map(BigInt)}removeBuckets(...t){if(0===t.length)throw new Error("At least one bucket ID must be provided");return 1===t.length?this.apiPromise.tx.ddcCustomers.removeBucket(t[0]):this.apiPromise.tx.utility.batch(t.map(t=>this.apiPromise.tx.ddcCustomers.removeBucket(t)))}extractRemovedBucketIds(t){return t.filter(t=>"ddcCustomers"===t.section&&"BucketRemoved"===t.method).map(t=>{var e;return null==(e=t.payload)?void 0:e.bucket_id}).filter(Boolean).map(BigInt)}}class G{constructor(t){this.apiPromise=void 0,this.apiPromise=t}proposeActivateClusterProtocol(t,e){return this.apiPromise.tx.ddcClusterGov.proposeActivateClusterProtocol(t,e)}proposeUpdateClusterProtocol(t,e,s,r){return this.apiPromise.tx.ddcClusterGov.proposeUpdateClusterProtocol(t,e,this.createClusterMember(s,r))}voteProposal(t,e,s,r){return this.apiPromise.tx.ddcClusterGov.voteProposal(t,e,this.createClusterMember(s,r))}closeProposal(t,e,s){return this.apiPromise.tx.ddcClusterGov.closeProposal(t,this.createClusterMember(e,s))}retractProposal(t){return this.apiPromise.tx.ddcClusterGov.retractProposal(t)}refundSubmissionDeposit(t){return this.apiPromise.tx.ddcClusterGov.refundSubmissionDeposit(t)}createClusterMember(t,e){if(t===w.ClusterManager)return w.ClusterManager;if(!e)throw new Error("Node public key is required to create a cluster member enum.");return{[w.NodeProvider]:e}}}class D{constructor(s){this.api=void 0,this.ddcNodes=void 0,this.ddcClusters=void 0,this.ddcStaking=void 0,this.ddcCustomers=void 0,this.ddcClustersGov=void 0,this.api="apiPromise"in s?s.apiPromise:new t(k({provider:new e(s.wsEndpoint)},s.apiOptions)),this.ddcNodes=new q(this.api),this.ddcClusters=new j(this.api),this.ddcStaking=new U(this.api),this.ddcCustomers=new F(this.api),this.ddcClustersGov=new G(this.api)}static async connect(t){const e=new D(t);return await e.isReady(),e}async isReady(){return await this.api.isReady,!0}get chainDecimals(){const[t]=this.api.registry.chainDecimals;return t}async getNextNonce(t){return(await this.api.rpc.system.accountNextIndex(t)).toNumber()}async send(t,{account:e,nonce:s,signer:r}){let i,o=r;return N.isSigner(e)?(o||(o=await e.getSigner()),i=e.address):i=e,new Promise((e,r)=>{t.signAndSend(i,{nonce:s,signer:o},t=>{if(t.status.isFinalized){const s=t.events.map(({event:t})=>({method:t.method,section:t.section,meta:t.meta.toJSON(),data:t.data.toJSON(),payload:Object.fromEntries(t.meta.fields.map((e,s)=>[e.name,t.data[s].toJSON()]))}));e({events:s,txHash:t.status.asFinalized.toHex()})}else if(t.dispatchError){let e;if(t.dispatchError.isModule){const s=this.api.registry.findMetaError(t.dispatchError.asModule);e=`${s.section}.${s.name}: ${s.docs.join(" ")}`}else e=t.dispatchError.toString();r(new Error(e))}}).catch(r)})}batchSend(t,e){return this.send(this.api.tx.utility.batch(t),e)}batchAllSend(t,e){return this.send(this.api.tx.utility.batchAll(t),e)}sudo(t){return this.api.tx.sudo.sudo(t)}sudoAs(t,e){return this.api.tx.sudo.sudoAs(t,e)}disconnect(){return this.api.disconnect()}formatBalance(t,e="CERE"){return n(t,{withSiFull:!0,decimals:this.chainDecimals,withUnit:e})}async getAccountFreeBalance(t){const{data:e}=await this.api.query.system.account(t);return e.free.toBigInt()}async getCurrentBlockNumber(){const{number:t}=await this.api.rpc.chain.getHeader();return t.toNumber()}}export{D as Blockchain,b as CERE_SS58_PREFIX,J as CereWalletSigner,w as ClusterMember,v as ClusterNodeKind,S as ClusterStatus,G as DDCClustersGovPallet,j as DDCClustersPallet,F as DDCCustomersPallet,q as DDCNodesPallet,U as DDCStakingPallet,E as JsonSigner,x as KeyringSigner,N as Signer,C as StorageNodeMode,f as UriSigner,A as Web3Signer,O as createRandomSigner,I as decodeAddress,B as encodeAddress};
//# sourceMappingURL=browser.js.map
