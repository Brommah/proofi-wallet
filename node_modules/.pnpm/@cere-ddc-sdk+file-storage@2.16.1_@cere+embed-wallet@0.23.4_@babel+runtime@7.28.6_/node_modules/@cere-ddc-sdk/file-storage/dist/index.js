import { isContentStream, createContentStream, PieceResponse, MAX_PIECE_SIZE, Router, createLogger, BalancedNode, bindErrorLogger, UriSigner, DEFAULT_PRESET, withChunkSize, Piece, MultipartPiece, streamConsumers, MIN_PIECE_SIZE } from '@cere-ddc-sdk/ddc';
export { CereWalletSigner, DEVNET, JsonSigner, KeyringSigner, MAINNET, MAX_PIECE_SIZE as MAX_BUFFER_SIZE, MIN_PIECE_SIZE as MIN_BUFFER_SIZE, TESTNET, UriSigner, createCorrelationId } from '@cere-ddc-sdk/ddc';
import { Blockchain } from '@cere-ddc-sdk/blockchain';

/**
 * Represents a file with content and metadata.
 *
 * @group Files
 */
class File {
  constructor(content, meta = {}) {
    /**
     * The content of the file as a stream.
     */
    this.body = void 0;
    /**
     * The size of the file in bytes.
     */
    this.size = void 0;
    /**
     * The metadata for the file.
     */
    this.meta = void 0;
    this.body = isContentStream(content) ? content : createContentStream(content);
    this.size = content instanceof Uint8Array ? content.byteLength : meta.size;
    this.meta = meta;
  }
  /**
   * Checks if a given object is an instance of the `File` class.
   *
   * @param object - The object to check.
   *
   * @returns True if the object is a `File` instance, false otherwise.
   */
  static isFile(object) {
    const maybeFile = object;
    if (object instanceof File) {
      return true;
    }
    return typeof maybeFile === 'object' && typeof (maybeFile == null ? void 0 : maybeFile.size) === 'number' && !!maybeFile.body;
  }
}
/**
 * Represents a response from a file read operation.
 *
 * @group Files
 * @extends PieceResponse
 */
class FileResponse extends PieceResponse {}

const DEFAULT_BUFFER_SIZE = MAX_PIECE_SIZE;

/**
 * Represents a storage system for files.
 *
 * It provides methods to read and store files in the DDC.
 *
 * @group Files
 */
class FileStorage {
  constructor(configOrRouter, config) {
    var _finalConfig;
    this.ddcNode = void 0;
    this.logger = void 0;
    this.blockchain = void 0;
    let finalConfig;
    if (configOrRouter instanceof Router) {
      finalConfig = config;
      this.logger = createLogger('FileStorage', config);
      this.ddcNode = new BalancedNode({
        ...config,
        router: configOrRouter,
        logger: this.logger
      });
      this.logger.debug(config, 'FileStorage created');
    } else {
      finalConfig = configOrRouter;
      this.logger = createLogger('FileStorage', configOrRouter);
      this.blockchain = 'blockchain' in configOrRouter ? configOrRouter.blockchain : undefined;
      this.ddcNode = new BalancedNode({
        logger: this.logger,
        retries: configOrRouter.retries,
        router: new Router({
          ...configOrRouter,
          logger: this.logger
        })
      });
      this.logger.debug(configOrRouter, 'FileStorage created');
    }
    if (((_finalConfig = finalConfig) == null ? void 0 : _finalConfig.logErrors) === false) {
      bindErrorLogger(this, this.logger, ['store', 'read']);
    }
  }
  /**
   * Creates a new instance of the `FileStorage` class asynchronously.
   *
   * @param uriOrSigner - A Signer instance or a [substrate URI](https://polkadot.js.org/docs/keyring/start/suri).
   * @param config - Configuration options for the `FileStorage`. Defaults to TESTNET.
   *
   * @returns A promise that resolves to a new `FileStorage` instance.
   *
   * * @example
   *
   * ```typescript
   * import { FileStorage, TESTNET } from '@cere-ddc-sdk/file-storage';
   *
   * const fileStorage = await FileStorage.create('//Alice', TESTNET);
   * ```
   */
  static async create(uriOrSigner, config = DEFAULT_PRESET) {
    const signer = typeof uriOrSigner === 'string' ? new UriSigner(uriOrSigner) : uriOrSigner;
    const blockchain = typeof config.blockchain === 'string' ? await Blockchain.connect({
      wsEndpoint: config.blockchain
    }) : config.blockchain;
    return new FileStorage({
      ...config,
      blockchain,
      signer
    });
  }
  async disconnect() {
    var _this$blockchain;
    await ((_this$blockchain = this.blockchain) == null ? void 0 : _this$blockchain.disconnect());
  }
  async storeLarge(bucketId, file, {
    partSize,
    ...options
  }) {
    const parts = [];
    const partsStream = file.body.pipeThrough(withChunkSize(partSize));
    let offset = 0;
    for await (const part of partsStream) {
      const piece = new Piece(part, {
        multipartOffset: offset
      });
      const cid = await this.ddcNode.storePiece(bucketId, piece, {
        accessToken: options == null ? void 0 : options.accessToken
      });
      offset += part.byteLength;
      parts.push(cid);
    }
    return this.ddcNode.storePiece(bucketId, new MultipartPiece(parts, {
      totalSize: file.size,
      partSize
    }), options);
  }
  async storeSmall(bucketId, file, options) {
    const content = new Uint8Array(await streamConsumers.arrayBuffer(file.body));
    return this.ddcNode.storePiece(bucketId, new Piece(content), options);
  }
  /**
   * Stores a file in the DDC. Large files are stored as a collection of pieces.
   *
   * @param bucketId - The ID of the bucket where the file will be stored.
   * @param file - The file to store.
   * @param options - The options for storing the file.
   *
   * @returns A promise that resolves to the CID of the stored file.
   *
   * @example
   *
   * ```typescript
   * const bucketId = 1n;
   * const fileContent = ...;
   * const file: File = new File(fileContent, { size: 1000 });
   * const fileCid = await fileStorage.store(bucketId, file);
   *
   * console.log(fileCid);
   * ```
   */
  async store(bucketId, file, options = {}) {
    this.logger.info('Storing file into bucket %s', bucketId);
    this.logger.debug({
      bucketId,
      file,
      options
    }, 'Store file');
    const partSize = (options == null ? void 0 : options.maxBufferSize) || DEFAULT_BUFFER_SIZE;
    if (partSize > MAX_PIECE_SIZE || partSize < MIN_PIECE_SIZE) {
      throw new Error(`Max buffer size must be between ${MIN_PIECE_SIZE} and ${MAX_PIECE_SIZE} bytes`);
    }
    const cid = file.size > partSize ? await this.storeLarge(bucketId, file, {
      ...options,
      partSize
    }) : await this.storeSmall(bucketId, file, options);
    this.logger.info('File stored with CID %s', cid);
    return cid;
  }
  /**
   * Reads a file from the file storage.
   *
   * @param bucketId - The ID of the bucket where the file is stored.
   * @param cidOrName - The CID or CNS name of the file to read.
   * @param options - The options for reading the file.
   *
   * @returns A promise that resolves to a `FileResponse` instance.
   *
   * @example
   *
   * ```typescript
   * const bucketId = 1n;
   * const fileCid = 'CID';
   * const file = await fileStorage.read(bucketId, fileCid);
   * const content = await file.text();
   *
   * console.log(content);
   * ```
   */
  async read(bucketId, cidOrName, options) {
    this.logger.info('Reading file from bucket %s by "%s"', bucketId, cidOrName);
    const piece = await this.ddcNode.readPiece(bucketId, cidOrName, options);
    this.logger.info('File response created with CID %s', piece.cid);
    return new FileResponse(piece.cid, piece.body, options);
  }
}

export { DEFAULT_BUFFER_SIZE, File, FileResponse, FileStorage };
//# sourceMappingURL=index.js.map
