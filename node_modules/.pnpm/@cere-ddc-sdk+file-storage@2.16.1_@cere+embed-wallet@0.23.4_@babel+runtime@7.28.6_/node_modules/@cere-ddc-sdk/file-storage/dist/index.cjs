var ddc = require('@cere-ddc-sdk/ddc');
var blockchain = require('@cere-ddc-sdk/blockchain');

/**
 * Represents a file with content and metadata.
 *
 * @group Files
 */
class File {
  constructor(content, meta = {}) {
    /**
     * The content of the file as a stream.
     */
    this.body = void 0;
    /**
     * The size of the file in bytes.
     */
    this.size = void 0;
    /**
     * The metadata for the file.
     */
    this.meta = void 0;
    this.body = ddc.isContentStream(content) ? content : ddc.createContentStream(content);
    this.size = content instanceof Uint8Array ? content.byteLength : meta.size;
    this.meta = meta;
  }
  /**
   * Checks if a given object is an instance of the `File` class.
   *
   * @param object - The object to check.
   *
   * @returns True if the object is a `File` instance, false otherwise.
   */
  static isFile(object) {
    const maybeFile = object;
    if (object instanceof File) {
      return true;
    }
    return typeof maybeFile === 'object' && typeof (maybeFile == null ? void 0 : maybeFile.size) === 'number' && !!maybeFile.body;
  }
}
/**
 * Represents a response from a file read operation.
 *
 * @group Files
 * @extends PieceResponse
 */
class FileResponse extends ddc.PieceResponse {}

const DEFAULT_BUFFER_SIZE = ddc.MAX_PIECE_SIZE;

/**
 * Represents a storage system for files.
 *
 * It provides methods to read and store files in the DDC.
 *
 * @group Files
 */
class FileStorage {
  constructor(configOrRouter, config) {
    var _finalConfig;
    this.ddcNode = void 0;
    this.logger = void 0;
    this.blockchain = void 0;
    let finalConfig;
    if (configOrRouter instanceof ddc.Router) {
      finalConfig = config;
      this.logger = ddc.createLogger('FileStorage', config);
      this.ddcNode = new ddc.BalancedNode({
        ...config,
        router: configOrRouter,
        logger: this.logger
      });
      this.logger.debug(config, 'FileStorage created');
    } else {
      finalConfig = configOrRouter;
      this.logger = ddc.createLogger('FileStorage', configOrRouter);
      this.blockchain = 'blockchain' in configOrRouter ? configOrRouter.blockchain : undefined;
      this.ddcNode = new ddc.BalancedNode({
        logger: this.logger,
        retries: configOrRouter.retries,
        router: new ddc.Router({
          ...configOrRouter,
          logger: this.logger
        })
      });
      this.logger.debug(configOrRouter, 'FileStorage created');
    }
    if (((_finalConfig = finalConfig) == null ? void 0 : _finalConfig.logErrors) === false) {
      ddc.bindErrorLogger(this, this.logger, ['store', 'read']);
    }
  }
  /**
   * Creates a new instance of the `FileStorage` class asynchronously.
   *
   * @param uriOrSigner - A Signer instance or a [substrate URI](https://polkadot.js.org/docs/keyring/start/suri).
   * @param config - Configuration options for the `FileStorage`. Defaults to TESTNET.
   *
   * @returns A promise that resolves to a new `FileStorage` instance.
   *
   * * @example
   *
   * ```typescript
   * import { FileStorage, TESTNET } from '@cere-ddc-sdk/file-storage';
   *
   * const fileStorage = await FileStorage.create('//Alice', TESTNET);
   * ```
   */
  static async create(uriOrSigner, config = ddc.DEFAULT_PRESET) {
    const signer = typeof uriOrSigner === 'string' ? new ddc.UriSigner(uriOrSigner) : uriOrSigner;
    const blockchain$1 = typeof config.blockchain === 'string' ? await blockchain.Blockchain.connect({
      wsEndpoint: config.blockchain
    }) : config.blockchain;
    return new FileStorage({
      ...config,
      blockchain: blockchain$1,
      signer
    });
  }
  async disconnect() {
    var _this$blockchain;
    await ((_this$blockchain = this.blockchain) == null ? void 0 : _this$blockchain.disconnect());
  }
  async storeLarge(bucketId, file, {
    partSize,
    ...options
  }) {
    const parts = [];
    const partsStream = file.body.pipeThrough(ddc.withChunkSize(partSize));
    let offset = 0;
    for await (const part of partsStream) {
      const piece = new ddc.Piece(part, {
        multipartOffset: offset
      });
      const cid = await this.ddcNode.storePiece(bucketId, piece, {
        accessToken: options == null ? void 0 : options.accessToken
      });
      offset += part.byteLength;
      parts.push(cid);
    }
    return this.ddcNode.storePiece(bucketId, new ddc.MultipartPiece(parts, {
      totalSize: file.size,
      partSize
    }), options);
  }
  async storeSmall(bucketId, file, options) {
    const content = new Uint8Array(await ddc.streamConsumers.arrayBuffer(file.body));
    return this.ddcNode.storePiece(bucketId, new ddc.Piece(content), options);
  }
  /**
   * Stores a file in the DDC. Large files are stored as a collection of pieces.
   *
   * @param bucketId - The ID of the bucket where the file will be stored.
   * @param file - The file to store.
   * @param options - The options for storing the file.
   *
   * @returns A promise that resolves to the CID of the stored file.
   *
   * @example
   *
   * ```typescript
   * const bucketId = 1n;
   * const fileContent = ...;
   * const file: File = new File(fileContent, { size: 1000 });
   * const fileCid = await fileStorage.store(bucketId, file);
   *
   * console.log(fileCid);
   * ```
   */
  async store(bucketId, file, options = {}) {
    this.logger.info('Storing file into bucket %s', bucketId);
    this.logger.debug({
      bucketId,
      file,
      options
    }, 'Store file');
    const partSize = (options == null ? void 0 : options.maxBufferSize) || DEFAULT_BUFFER_SIZE;
    if (partSize > ddc.MAX_PIECE_SIZE || partSize < ddc.MIN_PIECE_SIZE) {
      throw new Error(`Max buffer size must be between ${ddc.MIN_PIECE_SIZE} and ${ddc.MAX_PIECE_SIZE} bytes`);
    }
    const cid = file.size > partSize ? await this.storeLarge(bucketId, file, {
      ...options,
      partSize
    }) : await this.storeSmall(bucketId, file, options);
    this.logger.info('File stored with CID %s', cid);
    return cid;
  }
  /**
   * Reads a file from the file storage.
   *
   * @param bucketId - The ID of the bucket where the file is stored.
   * @param cidOrName - The CID or CNS name of the file to read.
   * @param options - The options for reading the file.
   *
   * @returns A promise that resolves to a `FileResponse` instance.
   *
   * @example
   *
   * ```typescript
   * const bucketId = 1n;
   * const fileCid = 'CID';
   * const file = await fileStorage.read(bucketId, fileCid);
   * const content = await file.text();
   *
   * console.log(content);
   * ```
   */
  async read(bucketId, cidOrName, options) {
    this.logger.info('Reading file from bucket %s by "%s"', bucketId, cidOrName);
    const piece = await this.ddcNode.readPiece(bucketId, cidOrName, options);
    this.logger.info('File response created with CID %s', piece.cid);
    return new FileResponse(piece.cid, piece.body, options);
  }
}

Object.defineProperty(exports, 'CereWalletSigner', {
  enumerable: true,
  get: function () { return ddc.CereWalletSigner; }
});
Object.defineProperty(exports, 'DEVNET', {
  enumerable: true,
  get: function () { return ddc.DEVNET; }
});
Object.defineProperty(exports, 'JsonSigner', {
  enumerable: true,
  get: function () { return ddc.JsonSigner; }
});
Object.defineProperty(exports, 'KeyringSigner', {
  enumerable: true,
  get: function () { return ddc.KeyringSigner; }
});
Object.defineProperty(exports, 'MAINNET', {
  enumerable: true,
  get: function () { return ddc.MAINNET; }
});
Object.defineProperty(exports, 'MAX_BUFFER_SIZE', {
  enumerable: true,
  get: function () { return ddc.MAX_PIECE_SIZE; }
});
Object.defineProperty(exports, 'MIN_BUFFER_SIZE', {
  enumerable: true,
  get: function () { return ddc.MIN_PIECE_SIZE; }
});
Object.defineProperty(exports, 'TESTNET', {
  enumerable: true,
  get: function () { return ddc.TESTNET; }
});
Object.defineProperty(exports, 'UriSigner', {
  enumerable: true,
  get: function () { return ddc.UriSigner; }
});
Object.defineProperty(exports, 'createCorrelationId', {
  enumerable: true,
  get: function () { return ddc.createCorrelationId; }
});
exports.DEFAULT_BUFFER_SIZE = DEFAULT_BUFFER_SIZE;
exports.File = File;
exports.FileResponse = FileResponse;
exports.FileStorage = FileStorage;
//# sourceMappingURL=index.cjs.map
