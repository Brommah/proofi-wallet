<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proofi Health Analyzer ‚Äî DDC Mainnet Demo</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üè•</text></svg>">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Geist+Mono:wght@400;500;600&display=swap');
    
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :focus-visible {
          outline: 2px solid #00E5FF;
          outline-offset: 2px;
        }
    
        .skip-to-content {
          position: absolute;
          top: -100%;
          left: 16px;
          z-index: 999;
          padding: 12px 24px;
          background: #3B82F6;
          color: #fff;
          font-weight: 700;
          text-decoration: none;
          border-radius: 0 0 4px 4px;
        }
        .skip-to-content:focus {
          top: 0;
        }
    
    
    :root {
      --bg: #0a0a0a;
      --surface: #111;
      --card: #161616;
      --card-hover: #1a1a1a;
      --border: #222;
      --border-hover: #333;
      --text: #ededed;
      --text-secondary: #888;
      --text-tertiary: #555;
      --accent: #00FF88;
      --accent-dim: rgba(0, 255, 136, 0.12);
      --blue: #00E5FF;
      --purple: #a855f7;
      --orange: #f97316;
      --red: #ef4444;
      --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --mono: 'Geist Mono', 'SF Mono', 'Fira Code', monospace;
      --radius: 12px;
      --radius-sm: 8px;
    }
    
    html { scroll-behavior: smooth; }
    
    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      min-height: 100vh;
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }
    
    /* ===== NAV ===== */
    nav {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(10,10,10,0.85);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
    }
    .nav-inner {
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 24px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .nav-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .nav-logo {
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
      color: var(--text);
    }
    .nav-badge {
      font-size: 11px;
      padding: 4px 8px;
      background: var(--accent-dim);
      color: var(--accent);
      border-radius: 100px;
      font-weight: 500;
    }
    .nav-badge.offline {
      background: rgba(249, 115, 22, 0.15);
      color: var(--orange);
    }
    .wallet-status {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
    }
    .wallet-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
    }
    .wallet-dot.connected { background: var(--accent); }
    .wallet-addr {
      font-family: var(--mono);
      color: var(--text-secondary);
    }
    
    /* ===== DDC STATUS BANNER ===== */
    .ddc-banner {
      background: var(--accent-dim);
      border-bottom: 1px solid var(--accent);
      padding: 10px 24px;
      font-size: 13px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .ddc-banner.offline {
      background: rgba(249, 115, 22, 0.15);
      border-color: var(--orange);
    }
    .ddc-banner.error {
      background: rgba(239, 68, 68, 0.15);
      border-color: var(--red);
    }
    .ddc-banner .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      animation: pulse 2s infinite;
    }
    .ddc-banner.offline .status-dot { background: var(--orange); }
    .ddc-banner.error .status-dot { background: var(--red); animation: none; }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* ===== MAIN ===== */
    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 40px 24px 80px;
    }
    
    /* ===== HERO ===== */
    .hero {
      text-align: center;
      margin-bottom: 48px;
    }
    .hero h1 {
      font-size: clamp(32px, 5vw, 48px);
      font-weight: 700;
      letter-spacing: -1px;
      margin-bottom: 12px;
    }
    .hero p {
      color: var(--text-secondary);
      font-size: 17px;
      max-width: 600px;
      margin: 0 auto;
    }
    
    /* ===== STEPS ===== */
    .steps {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    
    .step {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      transition: border-color 0.2s;
    }
    .step.active { border-color: var(--accent); }
    .step.completed { border-color: var(--accent); }
    .step.completed .step-header { background: var(--accent-dim); }
    
    .step-header {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 20px 24px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
    }
    .step-header:hover { background: var(--card-hover); }
    
    .step-num {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      flex-shrink: 0;
    }
    .step.completed .step-num {
      background: var(--accent);
      color: #000;
    }
    .step.completed .step-num::after {
      content: '‚úì';
    }
    .step.completed .step-num span { display: none; }
    
    .step-info { flex: 1; }
    .step-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 2px;
    }
    .step-desc {
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .step-status {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 100px;
      background: var(--border);
      color: var(--text-secondary);
    }
    .step.completed .step-status {
      background: var(--accent);
      color: #000;
    }
    .step.active .step-status {
      background: var(--blue);
      color: #fff;
    }
    
    .step-body {
      padding: 24px;
      display: none;
    }
    .step.active .step-body,
    .step.expanded .step-body { display: block; }
    
    /* ===== FORM ELEMENTS ===== */
    .form-group {
      margin-bottom: 20px;
    }
    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }
    .form-input {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-family: var(--mono);
      font-size: 14px;
      outline: none;
      transition: border-color 0.15s;
    }
    .form-input:focus { border-color: var(--accent); }
    .form-input::placeholder { color: var(--text-tertiary); }
    
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      font-family: var(--font);
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s;
    }
    .btn-primary {
      background: var(--accent);
      color: #000;
    }
    .btn-primary:hover { opacity: 0.9; transform: translateY(-1px); }
    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .btn-secondary {
      background: var(--border);
      color: var(--text);
    }
    .btn-secondary:hover { background: var(--border-hover); }
    
    .btn-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    /* ===== DATA DISPLAY ===== */
    .data-box {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-bottom: 16px;
      font-family: var(--mono);
      font-size: 12px;
      overflow-x: auto;
      max-height: 300px;
      overflow-y: auto;
    }
    .data-box pre {
      white-space: pre-wrap;
      word-break: break-all;
    }
    .data-box.scrollable {
      max-height: 400px;
    }
    
    .data-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .data-label span {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
    }
    .data-label .copy-btn {
      font-size: 11px;
      padding: 4px 8px;
      background: var(--border);
      border: none;
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }
    .data-label .copy-btn:hover { color: var(--text); }
    
    /* ===== KEY VALUE PAIRS ===== */
    .kv-grid {
      display: grid;
      gap: 12px;
    }
    .kv-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
    }
    .kv-icon {
      font-size: 18px;
      flex-shrink: 0;
    }
    .kv-content { flex: 1; min-width: 0; }
    .kv-key {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 2px;
    }
    .kv-value {
      font-family: var(--mono);
      font-size: 13px;
      word-break: break-all;
    }
    .kv-value.success { color: var(--accent); }
    .kv-value.pending { color: var(--orange); }
    .kv-value.ddc { color: var(--blue); }
    
    /* ===== LOADING ===== */
    .loading {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 16px;
    }
    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* ===== SCOPE EDITOR ===== */
    .scope-grid {
      display: grid;
      gap: 12px;
      margin-bottom: 20px;
    }
    .scope-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: border-color 0.15s;
    }
    .scope-item:hover { border-color: var(--border-hover); }
    .scope-item.selected { border-color: var(--accent); background: var(--accent-dim); }
    .scope-check {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }
    .scope-item.selected .scope-check {
      background: var(--accent);
      border-color: var(--accent);
      color: #000;
    }
    .scope-icon { font-size: 20px; flex-shrink: 0; }
    .scope-info { flex: 1; }
    .scope-path {
      font-family: var(--mono);
      font-size: 13px;
      font-weight: 500;
    }
    .scope-perms {
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    /* ===== ANALYSIS RESULTS ===== */
    .analysis-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    .analysis-card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 20px;
      text-align: center;
    }
    .analysis-value {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .analysis-value.good { color: var(--accent); }
    .analysis-value.warning { color: var(--orange); }
    .analysis-value.bad { color: var(--red); }
    .analysis-label {
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    /* ===== AUDIT LOG ===== */
    .audit-log {
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }
    .audit-entry {
      display: flex;
      gap: 16px;
      padding: 16px;
      border-bottom: 1px solid var(--border);
      font-size: 13px;
    }
    .audit-entry:last-child { border-bottom: none; }
    .audit-time {
      font-family: var(--mono);
      color: var(--text-tertiary);
      flex-shrink: 0;
      width: 90px;
    }
    .audit-action {
      flex: 1;
    }
    .audit-hash {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text-tertiary);
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* ===== VERIFICATION ===== */
    .verify-section {
      margin-top: 24px;
      padding: 20px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
    }
    .verify-section h4 {
      font-size: 14px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .verify-grid {
      display: grid;
      gap: 8px;
    }
    .verify-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
    }
    .verify-icon { font-size: 16px; }
    .verify-label { color: var(--text-secondary); }
    .verify-value {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }
    
    /* ===== TRUST CHAIN ===== */
    .trust-chain {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 24px;
      margin-bottom: 24px;
      overflow-x: auto;
    }
    .trust-chain-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text-secondary);
    }
    .trust-chain-flow {
      display: flex;
      align-items: center;
      gap: 0;
      font-family: var(--mono);
      font-size: 12px;
      min-width: 700px;
    }
    .trust-chain-node {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 12px 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      min-width: 120px;
      text-align: center;
    }
    .trust-chain-node .tc-icon {
      font-size: 20px;
    }
    .trust-chain-node .tc-label {
      font-weight: 600;
      color: var(--text);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .trust-chain-node .tc-detail {
      color: var(--accent);
      font-size: 10px;
      word-break: break-all;
    }
    .trust-chain-arrow {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      padding: 0 8px;
      color: var(--text-tertiary);
      flex-shrink: 0;
    }
    .trust-chain-arrow .tc-arrow-line {
      font-size: 16px;
      color: var(--accent);
      letter-spacing: -2px;
    }
    .trust-chain-arrow .tc-arrow-label {
      font-size: 9px;
      color: var(--text-secondary);
      text-transform: uppercase;
      white-space: nowrap;
    }

    /* ===== CONSOLE ===== */
    .console-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      cursor: pointer;
      font-family: var(--font);
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 50;
    }
    .console-toggle:hover { background: var(--card-hover); }
    
    .console-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 300px;
      background: var(--bg);
      border-top: 1px solid var(--border);
      transform: translateY(100%);
      transition: transform 0.3s;
      z-index: 100;
      display: flex;
      flex-direction: column;
    }
    .console-panel.open { transform: translateY(0); }
    
    .console-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
    }
    .console-header h4 {
      font-size: 13px;
      font-weight: 600;
    }
    .console-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 18px;
    }
    
    .console-body {
      flex: 1;
      overflow: auto;
      padding: 16px 20px;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.8;
    }
    .console-line { margin-bottom: 4px; }
    .console-line.info { color: var(--text-secondary); }
    .console-line.success { color: var(--accent); }
    .console-line.error { color: var(--red); }
    .console-line.crypto { color: var(--purple); }
    .console-line.ddc { color: var(--blue); }
    .console-line.warn { color: var(--orange); }
    .console-time {
      color: var(--text-tertiary);
      margin-right: 8px;
    }
    
    /* ===== REVOCATION ===== */
    .revoke-btn {
      background: transparent;
      color: var(--red);
      border: 1px solid var(--red);
      padding: 8px 16px;
      border-radius: var(--radius-sm);
      font-family: var(--font);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 12px;
      display: none;
      align-items: center;
      gap: 6px;
    }
    .revoke-btn:hover { background: rgba(239, 68, 68, 0.1); }
    .revoke-btn.revoked {
      background: rgba(239, 68, 68, 0.1);
      cursor: default;
      opacity: 0.7;
    }
    .revocation-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      font-family: var(--mono);
    }
    .revocation-status.active {
      background: var(--accent-dim);
      color: var(--accent);
    }
    .revocation-status.revoked {
      background: rgba(239, 68, 68, 0.15);
      color: var(--red);
    }

    /* ===== PUBLIC VERIFIER ===== */
    .verifier-section {
      max-width: 1100px;
      margin: 48px auto 64px;
      padding: 0 24px;
    }
    .verifier-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 32px;
    }
    .verifier-card h2 {
      font-size: 20px;
      margin-bottom: 8px;
    }
    .verifier-card p {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 24px;
    }
    .verifier-input-group {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
    }
    .verifier-input {
      flex: 1;
      padding: 12px 16px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-family: var(--mono);
      font-size: 13px;
    }
    .verifier-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .verifier-result {
      display: none;
      padding: 20px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
    }
    .verifier-result.visible { display: block; }
    .verifier-result .vr-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 16px;
    }
    .verifier-result .vr-status {
      font-size: 15px;
      font-weight: 600;
    }
    .verifier-result .vr-status.verified { color: var(--accent); }
    .verifier-result .vr-status.not-found { color: var(--red); }
    .verifier-detail {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      font-size: 13px;
    }
    .verifier-detail:last-child { border: none; }
    .verifier-detail .vd-label { color: var(--text-secondary); }
    .verifier-detail .vd-value { font-family: var(--mono); font-size: 12px; }
    .data-classes {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .data-class-tag {
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      font-family: var(--mono);
      background: var(--accent-dim);
      color: var(--accent);
    }

    /* ===== PROGRESS BAR ===== */
    .progress-bar {
      position: sticky;
      top: 60px;
      z-index: 99;
      background: rgba(10, 10, 10, 0.95);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 16px 24px 28px;
    }
    .progress-bar-inner {
      max-width: 1100px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
    }
    .progress-bar-inner::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 24px;
      right: 24px;
      height: 2px;
      background: var(--border);
      transform: translateY(-50%);
      z-index: 0;
    }
    .progress-line {
      position: absolute;
      top: 50%;
      left: 24px;
      height: 2px;
      background: var(--accent);
      transform: translateY(-50%);
      z-index: 1;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      width: 0%;
    }
    .progress-node {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--card);
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      z-index: 2;
      position: relative;
      transition: all 0.3s ease;
      cursor: pointer;
      color: var(--text-secondary);
    }
    .progress-node.active {
      border-color: var(--accent);
      background: var(--accent-dim);
      color: var(--accent);
      box-shadow: 0 0 0 4px rgba(0, 255, 136, 0.15);
      animation: progressPulse 2s infinite;
    }
    .progress-node.completed {
      border-color: var(--accent);
      background: var(--accent);
      color: #000;
    }
    .progress-node-label {
      position: absolute;
      top: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: var(--text-tertiary);
      white-space: nowrap;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .progress-node.active .progress-node-label,
    .progress-node.completed .progress-node-label {
      color: var(--text-secondary);
    }
    @keyframes progressPulse {
      0%, 100% { box-shadow: 0 0 0 4px rgba(0, 255, 136, 0.15); }
      50% { box-shadow: 0 0 0 8px rgba(0, 255, 136, 0.08); }
    }

    /* ===== SOVEREIGNTY SEAL ===== */
    .sovereignty-seal {
      margin-top: 32px;
      padding: 32px;
      background: linear-gradient(135deg, rgba(0,255,136,0.04), rgba(0,229,255,0.04), rgba(168,85,247,0.04));
      border: 1px solid var(--accent);
      border-radius: var(--radius);
      text-align: center;
      position: relative;
      overflow: hidden;
      opacity: 0;
      transform: scale(0.95);
      animation: sealReveal 0.8s ease 0.3s forwards;
    }
    @keyframes sealReveal {
      to { opacity: 1; transform: scale(1); }
    }
    .sovereignty-seal::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(from 0deg, transparent, rgba(0,255,136,0.08), transparent, rgba(0,229,255,0.08), transparent);
      animation: sealRotate 8s linear infinite;
    }
    @keyframes sealRotate {
      to { transform: rotate(360deg); }
    }
    .seal-content {
      position: relative;
      z-index: 1;
    }
    .seal-shield {
      width: 72px;
      height: 72px;
      margin: 0 auto 16px;
      background: linear-gradient(135deg, var(--accent), var(--blue));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      box-shadow: 0 0 0 4px rgba(0,255,136,0.2), 0 0 0 8px rgba(0,255,136,0.1);
      animation: shieldPulse 3s ease infinite;
    }
    @keyframes shieldPulse {
      0%, 100% { box-shadow: 0 0 0 4px rgba(0,255,136,0.2), 0 0 0 8px rgba(0,255,136,0.1); }
      50% { box-shadow: 0 0 0 6px rgba(0,255,136,0.3), 0 0 0 12px rgba(0,255,136,0.15); }
    }
    .seal-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 4px;
      background: linear-gradient(90deg, var(--accent), var(--blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .seal-subtitle {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 20px;
    }
    .seal-facts {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      max-width: 600px;
      margin: 0 auto 20px;
    }
    .seal-fact .sf-value {
      font-family: var(--mono);
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
    }
    .seal-fact .sf-label {
      font-size: 10px;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .seal-hash {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text-tertiary);
      word-break: break-all;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .step-header { padding: 16px; }
      .step-body { padding: 16px; }
      .btn-group { flex-direction: column; }
      .btn { width: 100%; justify-content: center; }
      .analysis-grid { grid-template-columns: 1fr 1fr; }
      .progress-node-label { display: none; }
      .progress-node { width: 28px; height: 28px; font-size: 10px; }
      .progress-bar { padding: 12px 16px 16px; }
      .seal-facts { grid-template-columns: repeat(2, 1fr); }
    }
  /* ‚ïê‚ïê‚ïê MOBILE RESPONSIVE ‚ïê‚ïê‚ïê */
    @media (max-width: 480px) {
      .container { padding: 12px; }
      h1 { font-size: 24px; }
      h2 { font-size: 20px; }
      .btn { min-height: 44px; }
    }
    @media (max-width: 375px) {
      h1 { font-size: 20px; }
    }
    html, body { overflow-x: hidden; }
  </style>
</head>
<body>
<a class="skip-to-content" href="#main-content">Skip to content</a>

  <!-- DDC Status Banner -->
  <div class="ddc-banner" id="ddcBanner">
    <span class="status-dot"></span>
    <span id="ddcStatus">Connecting to Cere DDC Mainnet...</span>
  </div>

  <!-- Nav -->
  <nav role="navigation" aria-label="Main navigation">
    <div class="nav-inner">
      <div class="nav-left">
        <a href="/" class="nav-logo">üè• Health Analyzer</a>
        <span class="nav-badge" id="modeBadge">DDC Mainnet</span>
      </div>
      <div class="wallet-status" id="walletStatus">
        <span class="wallet-dot" id="walletDot"></span>
        <span class="wallet-addr" id="walletAddr">Not connected</span>
      </div>
    </div>
  </nav>

  <!-- Progress Bar -->
  <div class="progress-bar">
    <div class="progress-bar-inner" id="progressBar">
      <div class="progress-line" id="progressLine"></div>
      <div class="progress-node active" data-step="1" onclick="scrollToStep(1)">
        1
        <span class="progress-node-label">Wallet</span>
      </div>
      <div class="progress-node" data-step="2" onclick="scrollToStep(2)">
        2
        <span class="progress-node-label">Encrypt</span>
      </div>
      <div class="progress-node" data-step="3" onclick="scrollToStep(3)">
        3
        <span class="progress-node-label">Token</span>
      </div>
      <div class="progress-node" data-step="4" onclick="scrollToStep(4)">
        4
        <span class="progress-node-label">Agent</span>
      </div>
      <div class="progress-node" data-step="5" onclick="scrollToStep(5)">
        5
        <span class="progress-node-label">Verify</span>
      </div>
    </div>
  </div>

  <!-- Main -->
  <main id="main-content">
    <section class="hero">
      <h1>üîê Privacy-Preserving Health Analysis</h1>
      <p>Production demo with real encryption, capability tokens, and Cere DDC Mainnet decentralized storage.</p>
    </section>

    <div class="steps">
      <!-- Step 1: Wallet Connection -->
      <div class="step active" id="step1">
        <div class="step-header" onclick="toggleStep(1)">
          <div class="step-num"><span>1</span></div>
          <div class="step-info">
            <div class="step-title">Connect Wallet</div>
            <div class="step-desc">Generate or import a wallet to establish your identity</div>
          </div>
          <span class="step-status">Pending</span>
        </div>
        <div class="step-body">
          <div class="form-group">
            <label class="form-label">Seed Phrase (12 words) ‚Äî Leave empty to generate new</label>
            <input aria-label="word1 word2 word3 ... word12" type="text" class="form-input" id="seedInput" placeholder="word1 word2 word3 ... word12">
          </div>
          <div class="btn-group">
            <button aria-label="Close" class="btn btn-primary" onclick="connectWallet()">üîê Generate New Wallet</button>
            <button aria-label="Close" class="btn btn-secondary" onclick="connectWallet(true)">üì• Import Existing</button>
          </div>
          
          <div id="walletResult" style="margin-top: 20px; display: none;">
            <div class="kv-grid">
              <div class="kv-item">
                <span class="kv-icon">üîë</span>
                <div class="kv-content">
                  <div class="kv-key">Ed25519 Public Key</div>
                  <div class="kv-value" id="userPubKey">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üë§</span>
                <div class="kv-content">
                  <div class="kv-key">DID (Decentralized Identifier)</div>
                  <div class="kv-value" id="userDID">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üîí</span>
                <div class="kv-content">
                  <div class="kv-key">X25519 Public Key (for encryption)</div>
                  <div class="kv-value" id="userX25519">‚Äî</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 2: Upload Health Data -->
      <div class="step" id="step2">
        <div class="step-header" onclick="toggleStep(2)">
          <div class="step-num"><span>2</span></div>
          <div class="step-info">
            <div class="step-title">Upload Health Data to DDC</div>
            <div class="step-desc">Encrypt and store your health records in Cere decentralized storage</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <p style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px;">
            Your health data will be encrypted with AES-256-GCM using a Data Encryption Key (DEK) that only you control.
            The encrypted data is stored on the Cere DDC network.
          </p>
          
          <div class="data-label">
            <span>Sample Health Data (30 days of sleep + 100 heart rate readings)</span>
          </div>
          <div class="data-box" style="max-height: 150px;">
            <pre id="sampleDataPreview">Loading...</pre>
          </div>
          
          <div class="btn-group">
            <button aria-label="Close" class="btn btn-primary" id="uploadBtn" onclick="uploadHealthData()" disabled>
              üîê Encrypt & Upload to DDC
            </button>
          </div>
          
          <div id="uploadResult" style="margin-top: 20px; display: none;">
            <div class="kv-grid">
              <div class="kv-item">
                <span class="kv-icon">üåê</span>
                <div class="kv-content">
                  <div class="kv-key">Storage Mode</div>
                  <div class="kv-value ddc" id="storageMode">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üóÑÔ∏è</span>
                <div class="kv-content">
                  <div class="kv-key">DDC Bucket ID</div>
                  <div class="kv-value success" id="bucketId">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üì¶</span>
                <div class="kv-content">
                  <div class="kv-key">Content ID (CID)</div>
                  <div class="kv-value success" id="dataCid">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üîó</span>
                <div class="kv-content">
                  <div class="kv-key">DDC CDN URL</div>
                  <div class="kv-value" id="ddcUrl" style="font-size: 11px;">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üîë</span>
                <div class="kv-content">
                  <div class="kv-key">DEK (Data Encryption Key) ‚Äî Keep Secret!</div>
                  <div class="kv-value" id="dekDisplay">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üìä</span>
                <div class="kv-content">
                  <div class="kv-key">Encryption Details</div>
                  <div class="kv-value" id="encDetails">‚Äî</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 3: Grant Agent Permission -->
      <div class="step" id="step3">
        <div class="step-header" onclick="toggleStep(3)">
          <div class="step-num"><span>3</span></div>
          <div class="step-info">
            <div class="step-title">Grant Agent Permission</div>
            <div class="step-desc">Create a capability token to authorize the AI agent</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <div class="kv-grid" style="margin-bottom: 20px;">
            <div class="kv-item">
              <span class="kv-icon">ü§ñ</span>
              <div class="kv-content">
                <div class="kv-key">Agent Identity</div>
                <div class="kv-value">Health Analyzer Agent v1.0</div>
              </div>
            </div>
            <div class="kv-item">
              <span class="kv-icon">üîê</span>
              <div class="kv-content">
                <div class="kv-key">Agent X25519 Public Key</div>
                <div class="kv-value" id="agentPubKey">‚Äî</div>
              </div>
            </div>
          </div>
          
          <h4 style="font-size: 14px; margin-bottom: 12px;">Select Scopes to Grant:</h4>
          <div class="scope-grid" id="scopeGrid">
            <div class="scope-item selected" data-path="health/sleep" data-perms="read">
              <div class="scope-check">‚úì</div>
              <span class="scope-icon">üò¥</span>
              <div class="scope-info">
                <div class="scope-path">health/sleep/*</div>
                <div class="scope-perms">read ‚Äî Access sleep data</div>
              </div>
            </div>
            <div class="scope-item selected" data-path="health/heart" data-perms="read">
              <div class="scope-check">‚úì</div>
              <span class="scope-icon">‚ù§Ô∏è</span>
              <div class="scope-info">
                <div class="scope-path">health/heart/*</div>
                <div class="scope-perms">read ‚Äî Access heart rate data</div>
              </div>
            </div>
            <div class="scope-item" data-path="health/insights" data-perms="read,write">
              <div class="scope-check">‚úì</div>
              <span class="scope-icon">üí°</span>
              <div class="scope-info">
                <div class="scope-path">health/insights/*</div>
                <div class="scope-perms">read, write ‚Äî Store analysis results</div>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Token Expiry</label>
            <select class="form-input" id="tokenExpiry" style="cursor: pointer;">
              <option value="3600">1 hour</option>
              <option value="86400" selected>24 hours</option>
              <option value="604800">7 days</option>
            </select>
          </div>
          
          <button aria-label="Close" class="btn btn-primary" id="grantBtn" onclick="grantPermission()" disabled>
            üé´ Create Capability Token
          </button>
          
          <div id="tokenResult" style="margin-top: 20px; display: none;">
            <div class="data-label">
              <span>Capability Token (signed with Ed25519)</span>
              <button class="copy-btn" onclick="copyToken()">Copy</button>
            </div>
            <div class="data-box scrollable">
              <pre id="tokenDisplay">‚Äî</pre>
            </div>
            
            <div class="kv-grid">
              <div class="kv-item">
                <span class="kv-icon">üîè</span>
                <div class="kv-content">
                  <div class="kv-key">Token ID</div>
                  <div class="kv-value" id="tokenId">‚Äî</div>
                </div>
              </div>
              <div class="kv-item">
                <span class="kv-icon">üéÅ</span>
                <div class="kv-content">
                  <div class="kv-key">Wrapped DEK (encrypted for agent)</div>
                  <div class="kv-value" id="wrappedDek">‚Äî</div>
                </div>
              </div>
            </div>
            <button class="revoke-btn" id="revokeBtn" onclick="revokeToken()">
              üö´ Revoke Token
            </button>
            <div id="revocationStatus" style="margin-top: 8px;"></div>
          </div>
        </div>
      </div>

      <!-- Step 4: Agent Execution -->
      <div class="step" id="step4">
        <div class="step-header" onclick="toggleStep(4)">
          <div class="step-num"><span>4</span></div>
          <div class="step-info">
            <div class="step-title">Agent Executes Analysis</div>
            <div class="step-desc">AI agent validates token, fetches from DDC, decrypts data, runs analysis</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <div id="agentLoading" class="loading">
            <div class="spinner"></div>
            <span>Agent processing...</span>
          </div>
          
          <div id="agentSteps" style="display: none;">
            <div class="kv-grid" style="margin-bottom: 24px;">
              <div class="kv-item" id="agentStep1">
                <span class="kv-icon">‚è≥</span>
                <div class="kv-content">
                  <div class="kv-key">1. Validate Token Signature</div>
                  <div class="kv-value pending">Pending...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep2">
                <span class="kv-icon">‚è≥</span>
                <div class="kv-content">
                  <div class="kv-key">2. Check Revocation, Expiry & Scopes</div>
                  <div class="kv-value pending">Pending...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep3">
                <span class="kv-icon">‚è≥</span>
                <div class="kv-content">
                  <div class="kv-key">3. Unwrap DEK with Agent Private Key</div>
                  <div class="kv-value pending">Pending...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep4">
                <span class="kv-icon">‚è≥</span>
                <div class="kv-content">
                  <div class="kv-key">4. Fetch from DDC & Decrypt Health Data</div>
                  <div class="kv-value pending">Pending...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep5">
                <span class="kv-icon">‚è≥</span>
                <div class="kv-content">
                  <div class="kv-key">5. Run Health Analysis</div>
                  <div class="kv-value pending">Pending...</div>
                </div>
              </div>
            </div>
          </div>
          
          <button aria-label="Close" class="btn btn-primary" id="runAgentBtn" onclick="runAgent()" disabled>
            ü§ñ Run Agent Analysis
          </button>
        </div>
      </div>

      <!-- Step 5: Results & Verification -->
      <div class="step" id="step5">
        <div class="step-header" onclick="toggleStep(5)">
          <div class="step-num"><span>5</span></div>
          <div class="step-info">
            <div class="step-title">Results & Verification</div>
            <div class="step-desc">View analysis results and verify the complete audit trail</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <h4 style="font-size: 15px; margin-bottom: 16px;">üìä Health Analysis Results</h4>
          
          <div class="analysis-grid" id="analysisResults">
            <!-- Filled by JS -->
          </div>
          
          <div class="data-label">
            <span>AI Recommendations</span>
          </div>
          <div class="data-box" id="recommendations">
            <pre>Loading...</pre>
          </div>
          
          <h4 style="font-size: 15px; margin: 24px 0 16px;">üìã Audit Log (Hash Chain)</h4>
          <div class="audit-log" id="auditLog">
            <!-- Filled by JS -->
          </div>
          
          <div class="verify-section">
            <h4>‚úÖ Verification Details</h4>
            <div class="verify-grid" id="verifyGrid">
              <!-- Filled by JS -->
            </div>
          </div>
          
          <div class="btn-group" style="margin-top: 24px;">
            <button aria-label="Close" class="btn btn-primary" onclick="downloadAuditLog()">üì• Download Audit Log</button>
            <button aria-label="Close" class="btn btn-secondary" onclick="restartDemo()">üîÑ Restart Demo</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Public CID Verifier -->
  <section class="verifier-section" id="publicVerifier">
    <div class="verifier-card">
      <h2>üîç Public CID Verifier</h2>
      <p>Verify any content stored on Cere DDC. Paste a Content ID to check its existence, fetch metadata, and classify data types.</p>
      <div class="verifier-input-group">
        <input type="text" class="verifier-input" id="verifyCidInput" placeholder="Enter CID (e.g., bafk2bzace...)">
        <input type="number" class="verifier-input" id="verifyBucketInput" placeholder="Bucket" value="1229" style="max-width: 120px;">
        <button class="btn btn-primary" onclick="publicVerify()">Verify</button>
      </div>
      <div class="verifier-result" id="verifierResult"></div>
    </div>
  </section>

  <!-- Console Toggle -->
  <button class="console-toggle" onclick="toggleConsole()">
    <span>üñ•Ô∏è</span>
    <span>Dev Console</span>
  </button>

  <!-- Console Panel -->
  <div class="console-panel" id="consolePanel">
    <div class="console-header">
      <h4>üñ•Ô∏è Development Console</h4>
      <button aria-label="Close" class="console-close" onclick="toggleConsole()">√ó</button>
    </div>
    <div class="console-body" id="consoleBody">
      <div class="console-line info">
        <span class="console-time">[init]</span>
        Proofi Health Demo initializing with Cere DDC Mainnet integration...
      </div>
    </div>
  </div>

  <!-- ProofiSDK for wallet signing via iframe -->
  <script src="/proofi-sdk.js"></script>

  <!-- TweetNaCl for real crypto -->
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>
  
  <script>
    // ========================================
    // REAL DDC E2E HEALTH DEMO
    // Using Cere DDC Testnet
    // ========================================
    
    // DDC Configuration - MAINNET
    const DDC_CONFIG = {
      // Mainnet CDN endpoint
      cdnUrl: 'https://cdn.cere.network',
      // Mainnet storage node endpoints
      storageNodes: [
        'https://storage-1.cere.network',
        'https://storage-2.cere.network',
        'https://storage-3.cere.network',
      ],
      // Network identifier
      network: 'mainnet',
      // For actual uploads, we'd need a funded wallet
      // This demo uses IndexedDB fallback with DDC-compatible CIDs
    };

    const PROOFI_API = 'https://proofi-api-production.up.railway.app';

    // Global State
    const state = {
      userKeyPair: null,        // Ed25519 signing keypair
      userX25519: null,         // X25519 encryption keypair
      agentKeyPair: null,       // Agent's X25519 keypair
      agentSigningKeyPair: null, // Agent's Ed25519 keypair
      dek: null,                // Data Encryption Key (AES-256)
      healthData: null,         // Raw health data
      encryptedData: null,      // Encrypted health data
      bucketId: null,           // DDC bucket ID
      dataCid: null,            // Content ID
      capabilityToken: null,    // The actual token
      auditLog: [],             // Audit trail with hashes
      lastHash: null,           // For hash chain
      ddcConnected: false,      // DDC connection status
      storageMode: 'indexeddb', // 'ddc' or 'indexeddb'
      tokenRevoked: false,       // Whether current token has been revoked
      revocationCid: null,       // CID of revocation record on DDC
      extensionConnected: false, // Proofi extension status
      walletAddress: null,       // Real Cere SS58 address from extension
      authToken: null            // JWT for Proofi API auth
    };
    
    // IndexedDB for local storage (DDC fallback)
    let ddcDB = null;
    
    async function initIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('ProofiDDC', 2);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          ddcDB = request.result;
          resolve(ddcDB);
        };
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains('pieces')) {
            db.createObjectStore('pieces', { keyPath: 'cid' });
          }
          if (!db.objectStoreNames.contains('revocations')) {
            db.createObjectStore('revocations', { keyPath: 'tokenId' });
          }
        };
      });
    }
    
    // Generate 30 days of sleep data + 100 heart rate readings
    const SAMPLE_HEALTH_DATA = generateSampleHealthData();
    
    function generateSampleHealthData() {
      const sleep = [];
      const heartRate = [];
      const startDate = new Date('2024-02-01');
      
      // 30 days of sleep
      for (let i = 0; i < 30; i++) {
        const date = new Date(startDate);
        date.setDate(date.getDate() + i);
        sleep.push({
          date: date.toISOString().split('T')[0],
          duration: 6 + Math.random() * 3,
          quality: 60 + Math.floor(Math.random() * 35),
          deep: 0.5 + Math.random() * 2,
          rem: 1 + Math.random() * 1.5,
          light: 3 + Math.random() * 2,
          awakenings: Math.floor(Math.random() * 5)
        });
      }
      
      // 100 heart rate readings
      for (let i = 0; i < 100; i++) {
        const date = new Date(startDate);
        date.setHours(date.getHours() + i * 7);
        const contexts = ['resting', 'walking', 'exercise', 'sleeping', 'stressed'];
        const context = contexts[Math.floor(Math.random() * contexts.length)];
        let bpm;
        switch(context) {
          case 'resting': bpm = 60 + Math.floor(Math.random() * 20); break;
          case 'walking': bpm = 80 + Math.floor(Math.random() * 30); break;
          case 'exercise': bpm = 120 + Math.floor(Math.random() * 60); break;
          case 'sleeping': bpm = 50 + Math.floor(Math.random() * 15); break;
          case 'stressed': bpm = 90 + Math.floor(Math.random() * 25); break;
        }
        heartRate.push({
          timestamp: date.toISOString(),
          bpm,
          context,
          variability: 20 + Math.floor(Math.random() * 40)
        });
      }
      
      return { sleep, heartRate, version: '1.0', exportedAt: new Date().toISOString() };
    }
    
    // ========================================
    // CONSOLE LOGGING
    // ========================================
    
    function log(message, type = 'info') {
      const time = new Date().toLocaleTimeString('en-US', { hour12: false });
      const consoleBody = document.getElementById('consoleBody');
      const line = document.createElement('div');
      line.className = `console-line ${type}`;
      line.innerHTML = `<span class="console-time">[${time}]</span>${escapeHtml(message)}`;
      consoleBody.appendChild(line);
      consoleBody.scrollTop = consoleBody.scrollHeight;
      console.log(`[${type.toUpperCase()}] ${message}`);
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function toggleConsole() {
      document.getElementById('consolePanel').classList.toggle('open');
    }
    
    // ========================================
    // DDC CONNECTION & STATUS
    // ========================================
    
    async function checkDDCConnection() {
      const banner = document.getElementById('ddcBanner');
      const statusEl = document.getElementById('ddcStatus');
      const modeBadge = document.getElementById('modeBadge');

      log('Checking DDC connectivity via Proofi API...', 'ddc');

      try {
        // Try real Proofi API /ddc/status first
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        const response = await fetch(`${PROOFI_API}/ddc/status`, {
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (response.ok) {
          const data = await response.json();
          state.ddcConnected = true;
          banner.className = 'ddc-banner';
          const issuerInfo = data.issuerWallet ? ` (Issuer: ${data.issuerWallet.slice(0, 12)}...)` : '';
          statusEl.textContent = `üü¢ Connected to Cere DDC Mainnet via Proofi API${issuerInfo}`;
          modeBadge.textContent = 'DDC Mainnet';
          modeBadge.className = 'nav-badge';
          log('DDC connected via Proofi API: ' + JSON.stringify(data), 'success');
          return;
        }
      } catch (err) {
        log('DDC /ddc/status check failed: ' + err.message + '. Trying /health...', 'warn');
      }

      // Fallback: try /health endpoint
      try {
        const controller2 = new AbortController();
        const timeoutId2 = setTimeout(() => controller2.abort(), 5000);

        const healthResponse = await fetch(`${PROOFI_API}/health`, {
          signal: controller2.signal
        });

        clearTimeout(timeoutId2);

        if (healthResponse.ok) {
          state.ddcConnected = true;
          banner.className = 'ddc-banner';
          statusEl.textContent = 'üü¢ Proofi API online ‚Äî DDC available';
          modeBadge.textContent = 'DDC Mainnet';
          modeBadge.className = 'nav-badge';
          log('Proofi API health check passed', 'success');
          return;
        }
      } catch (err) {
        log('Proofi API /health check failed: ' + err.message, 'warn');
      }

      // Offline fallback
      state.ddcConnected = false;
      state.storageMode = 'indexeddb';
      banner.className = 'ddc-banner offline';
      statusEl.textContent = 'üü† DDC Offline ‚Äî Using Local Storage (IndexedDB)';
      modeBadge.textContent = 'Offline Mode';
      modeBadge.className = 'nav-badge offline';
      log('DDC connection failed. Falling back to IndexedDB storage.', 'warn');
    }
    
    // ========================================
    // CRYPTO UTILITIES (REAL)
    // ========================================
    
    // Generate random bytes
    function randomBytes(n) {
      return nacl.randomBytes(n);
    }
    
    // SHA-256 hash
    async function sha256(data) {
      const buffer = typeof data === 'string' ? new TextEncoder().encode(data) : data;
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
      return new Uint8Array(hashBuffer);
    }
    
    // SHA-256 hash as base64
    async function sha256Base64(data) {
      const hash = await sha256(data);
      return nacl.util.encodeBase64(hash);
    }
    
    // Generate Ed25519 signing keypair from seed
    function generateSigningKeyPair(seed = null) {
      if (!seed) {
        seed = randomBytes(32);
      }
      const keyPair = nacl.sign.keyPair.fromSeed(seed);
      return {
        publicKey: keyPair.publicKey,
        privateKey: keyPair.secretKey,
        seed
      };
    }
    
    // Generate X25519 box keypair
    function generateBoxKeyPair() {
      return nacl.box.keyPair();
    }
    
    // Derive DID from public key
    function deriveDID(publicKey) {
      const b64 = nacl.util.encodeBase64(publicKey);
      return `did:key:z${b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')}`;
    }
    
    // Generate CID (Content Identifier) - IPFS/DDC compatible format
    // Uses multihash format: <varint hash function> <varint digest size> <hash digest>
    async function generateCID(data) {
      const jsonStr = typeof data === 'string' ? data : JSON.stringify(data);
      const hash = await sha256(jsonStr);
      
      // CIDv1 in base32 format (simplified for demo)
      // Real CID: <multibase><version><multicodec><multihash>
      // We'll use a recognizable format: baf<base32(sha256)>
      const base32Chars = 'abcdefghijklmnopqrstuvwxyz234567';
      let result = '';
      
      // Convert hash to base32
      let bits = 0;
      let value = 0;
      for (let i = 0; i < hash.length; i++) {
        value = (value << 8) | hash[i];
        bits += 8;
        while (bits >= 5) {
          bits -= 5;
          result += base32Chars[(value >> bits) & 31];
        }
      }
      if (bits > 0) {
        result += base32Chars[(value << (5 - bits)) & 31];
      }
      
      // Format as CIDv1 (bafk... for dag-cbor, bafyb... for raw)
      return 'bafyb' + result.slice(0, 54);
    }
    
    // AES-256-GCM encryption
    async function encryptAES(plaintext, key) {
      const iv = randomBytes(12);
      const encodedText = typeof plaintext === 'string' 
        ? new TextEncoder().encode(plaintext) 
        : plaintext;
      
      const cryptoKey = await crypto.subtle.importKey(
        'raw', key, { name: 'AES-GCM' }, false, ['encrypt']
      );
      
      const ciphertext = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv, tagLength: 128 },
        cryptoKey,
        encodedText
      );
      
      return {
        ciphertext: nacl.util.encodeBase64(new Uint8Array(ciphertext)),
        iv: nacl.util.encodeBase64(iv),
        algorithm: 'AES-256-GCM'
      };
    }
    
    // AES-256-GCM decryption
    async function decryptAES(ciphertextB64, ivB64, key) {
      const ciphertext = nacl.util.decodeBase64(ciphertextB64);
      const iv = nacl.util.decodeBase64(ivB64);
      
      const cryptoKey = await crypto.subtle.importKey(
        'raw', key, { name: 'AES-GCM' }, false, ['decrypt']
      );
      
      const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv, tagLength: 128 },
        cryptoKey,
        ciphertext
      );
      
      return new TextDecoder().decode(plaintext);
    }
    
    // Wrap DEK for recipient (X25519 + XSalsa20-Poly1305)
    function wrapDEK(dek, recipientPublicKey) {
      const ephemeral = nacl.box.keyPair();
      const nonce = randomBytes(24);
      
      const encrypted = nacl.box(dek, nonce, recipientPublicKey, ephemeral.secretKey);
      
      return {
        ciphertext: nacl.util.encodeBase64(encrypted),
        ephemeralPublicKey: nacl.util.encodeBase64(ephemeral.publicKey),
        nonce: nacl.util.encodeBase64(nonce)
      };
    }
    
    // Unwrap DEK (X25519 + XSalsa20-Poly1305)
    function unwrapDEK(wrappedDEK, recipientPrivateKey) {
      const ciphertext = nacl.util.decodeBase64(wrappedDEK.ciphertext);
      const ephemeralPubKey = nacl.util.decodeBase64(wrappedDEK.ephemeralPublicKey);
      const nonce = nacl.util.decodeBase64(wrappedDEK.nonce);
      
      const dek = nacl.box.open(ciphertext, nonce, ephemeralPubKey, recipientPrivateKey);
      
      if (!dek) {
        throw new Error('DEK unwrapping failed - decryption error');
      }
      
      return dek;
    }
    
    // Sign message with Ed25519
    function signMessage(message, privateKey) {
      const messageBytes = typeof message === 'string' 
        ? new TextEncoder().encode(message) 
        : message;
      const signature = nacl.sign.detached(messageBytes, privateKey);
      return nacl.util.encodeBase64(signature);
    }
    
    // Verify Ed25519 signature
    function verifySignature(message, signatureB64, publicKey) {
      const messageBytes = typeof message === 'string' 
        ? new TextEncoder().encode(message) 
        : message;
      const signature = nacl.util.decodeBase64(signatureB64);
      return nacl.sign.detached.verify(messageBytes, signature, publicKey);
    }
    
    // ========================================
    // DDC STORAGE LAYER
    // ========================================
    
    class DDCStorage {
      constructor() {
        this.mode = 'indexeddb'; // 'ddc' or 'indexeddb'
      }
      
      async store(bucketId, data) {
        const cid = await generateCID(data);
        const jsonData = JSON.stringify(data);

        log(`DDC: Generating CID for ${(jsonData.length / 1024).toFixed(2)}KB of data...`, 'ddc');
        log(`DDC: CID = ${cid}`, 'ddc');

        // Try real DDC via Proofi API first
        if (state.authToken) {
          try {
            log('DDC: Uploading encrypted data to Cere DDC Mainnet bucket 1229...', 'ddc');
            const response = await fetch(`${PROOFI_API}/ddc/memo`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${state.authToken}`
              },
              body: JSON.stringify({
                memo: jsonData
              })
            });

            if (response.ok) {
              const result = await response.json();
              const realCid = result.cid || cid;
              log(`DDC: Stored on mainnet! CID: ${realCid}`, 'success');
              this.mode = 'ddc';
              state.storageMode = 'ddc';
              return {
                cid: realCid,
                bucket: bucketId,
                mode: 'ddc',
                cdnUrl: result.cdnUrl || `https://cdn.ddc-dragon.com/1229/${realCid}`
              };
            } else {
              const err = await response.json().catch(() => ({}));
              throw new Error(err.error || `API returned ${response.status}`);
            }
          } catch (err) {
            log(`DDC: API upload failed: ${err.message}. Falling back to IndexedDB.`, 'warn');
          }
        }

        // Fallback to IndexedDB
        await this.storeLocal(cid, bucketId, data);
        this.mode = 'indexeddb';
        state.storageMode = 'indexeddb';
        return { cid, bucket: bucketId, mode: 'indexeddb', cdnUrl: `${DDC_CONFIG.cdnUrl}/${bucketId}/${cid}` };
      }
      
      async storeLocal(cid, bucketId, data) {
        return new Promise((resolve, reject) => {
          const tx = ddcDB.transaction(['pieces'], 'readwrite');
          const store = tx.objectStore('pieces');
          
          const piece = {
            cid,
            bucketId: bucketId.toString(),
            data: JSON.stringify(data),
            timestamp: Date.now(),
            version: '1.0'
          };
          
          const request = store.put(piece);
          request.onsuccess = () => {
            log(`IndexedDB: Stored piece with CID ${cid.slice(0, 20)}...`, 'info');
            resolve();
          };
          request.onerror = () => reject(request.error);
        });
      }
      
      async fetch(bucketId, cid) {
        log(`DDC: Fetching CID ${cid.slice(0, 20)}...`, 'ddc');

        // Fetch directly from DDC CDN (raw content, no API needed)
        try {
          const cdnUrl = `https://cdn.ddc-dragon.com/${bucketId}/${cid}`;
          log(`DDC: Fetching from CDN: ${cdnUrl}`, 'ddc');
          const response = await fetch(cdnUrl);

          if (response.ok) {
            const text = await response.text();
            log('DDC: Fetched from CDN!', 'success');
            let content = JSON.parse(text);
            // Unwrap memo envelope if present (stored via /ddc/memo)
            if (content.type === 'memo' && content.content) {
              content = typeof content.content === 'string' ? JSON.parse(content.content) : content.content;
            }
            return content;
          } else {
            throw new Error(`CDN returned ${response.status}`);
          }
        } catch (err) {
          log(`DDC: CDN fetch failed: ${err.message}. Trying API fallback...`, 'warn');
        }

        // Fallback: try Proofi API
        if (state.authToken || state.ddcConnected) {
          try {
            const response = await fetch(`${PROOFI_API}/ddc/read/${cid}`, {
              headers: state.authToken ? { 'Authorization': `Bearer ${state.authToken}` } : {}
            });

            if (response.ok) {
              const result = await response.json();
              log('DDC: Fetched from API fallback!', 'success');
              let content = result.content || result.data || result;
              if (typeof content === 'string') content = JSON.parse(content);
              if (content.type === 'memo' && content.content) {
                content = typeof content.content === 'string' ? JSON.parse(content.content) : content.content;
              }
              return content;
            }
          } catch (err) {
            log(`DDC: API fetch also failed: ${err.message}`, 'warn');
          }
        }

        // Fallback to IndexedDB
        return this.fetchLocal(cid);
      }
      
      async fetchLocal(cid) {
        return new Promise((resolve, reject) => {
          const tx = ddcDB.transaction(['pieces'], 'readonly');
          const store = tx.objectStore('pieces');
          const request = store.get(cid);
          
          request.onsuccess = () => {
            if (request.result) {
              log(`IndexedDB: Retrieved piece with CID ${cid.slice(0, 20)}...`, 'info');
              resolve(JSON.parse(request.result.data));
            } else {
              reject(new Error(`Piece not found: ${cid}`));
            }
          };
          request.onerror = () => reject(request.error);
        });
      }
    }
    
    const ddcStorage = new DDCStorage();
    
    // ========================================
    // AUDIT LOG
    // ========================================
    
    async function addAuditEntry(action, details = {}) {
      const entry = {
        timestamp: Date.now(),
        action,
        details,
        prevHash: state.lastHash || '0'.repeat(64)
      };
      
      const entryHash = await sha256Base64(JSON.stringify(entry));
      entry.hash = entryHash;
      state.lastHash = entryHash;
      state.auditLog.push(entry);
      
      log(`Audit: ${action} ‚Üí hash: ${entryHash.slice(0, 16)}...`, 'info');
      return entry;
    }
    
    // ========================================
    // STEP HANDLERS
    // ========================================
    
    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      // Initialize IndexedDB
      try {
        await initIndexedDB();
        log('IndexedDB initialized for local storage', 'success');
      } catch (err) {
        log('Failed to initialize IndexedDB: ' + err.message, 'error');
      }
      
      // Check DDC connection
      await checkDDCConnection();
      
      // Generate agent keypair
      const agentSeed = nacl.util.decodeUTF8('proofi-health-agent-v1-demo00000');
      state.agentSigningKeyPair = generateSigningKeyPair(agentSeed);
      state.agentKeyPair = nacl.box.keyPair.fromSecretKey(agentSeed);
      
      document.getElementById('agentPubKey').textContent = 
        nacl.util.encodeBase64(state.agentKeyPair.publicKey);
      
      // Show sample data preview
      const preview = JSON.stringify(SAMPLE_HEALTH_DATA, null, 2);
      document.getElementById('sampleDataPreview').textContent = 
        preview.slice(0, 500) + '\n... (' + preview.length + ' bytes total)';
      
      // Setup scope toggles
      document.querySelectorAll('.scope-item').forEach(item => {
        item.addEventListener('click', () => {
          item.classList.toggle('selected');
        });
      });
      
      // Initialize ProofiSDK for wallet signing
      let proofiSDK = null;
      try {
        proofiSDK = new ProofiSDK({
          walletUrl: 'https://proofi-virid.vercel.app/app',
          apiUrl: PROOFI_API,
          appName: 'Health Analyzer'
        });
        state.proofiSDK = proofiSDK;
        log('ProofiSDK initialized for wallet signing', 'success');
      } catch (e) {
        log('ProofiSDK init failed: ' + e.message, 'warn');
      }

      log('Demo initialized with real TweetNaCl crypto', 'success');
      log(`Agent public key: ${nacl.util.encodeBase64(state.agentKeyPair.publicKey).slice(0, 20)}...`, 'crypto');

      // Check for Proofi extension
      if (window.__proofi_extension__?.connected) {
        state.extensionConnected = true;
        state.walletAddress = window.__proofi_extension__.address;
        state.authToken = window.__proofi_extension__.token || localStorage.getItem('proofi_token');
        log(`Proofi extension detected: ${state.walletAddress.slice(0, 12)}...`, 'success');
        // Sync SDK state so signMessage() works without separate connect()
        if (proofiSDK) {
          proofiSDK.address = state.walletAddress;
          proofiSDK.connected = true;
          log('ProofiSDK synced with extension wallet', 'success');
        }
      }
      window.addEventListener('proofi-extension-ready', () => {
        if (window.__proofi_extension__?.connected) {
          state.extensionConnected = true;
          state.walletAddress = window.__proofi_extension__.address;
          state.authToken = window.__proofi_extension__.token || localStorage.getItem('proofi_token');
          log(`Proofi extension connected: ${state.walletAddress.slice(0, 12)}...`, 'success');
          // Sync SDK state so signMessage() works without separate connect()
          if (proofiSDK) {
            proofiSDK.address = state.walletAddress;
            proofiSDK.connected = true;
            log('ProofiSDK synced with extension wallet', 'success');
          }
          // Update wallet UI if not yet connected via Step 1
          if (!state.userKeyPair) {
            document.getElementById('walletDot').classList.add('connected');
            document.getElementById('walletAddr').textContent = state.walletAddress.slice(0, 8) + '...' + state.walletAddress.slice(-6);
          }
        }
      });
    });
    
    function toggleStep(stepNum) {
      const step = document.getElementById(`step${stepNum}`);
      if (step.classList.contains('completed') || step.classList.contains('active')) {
        step.classList.toggle('expanded');
      }
    }
    
    function scrollToStep(n) {
      document.getElementById(`step${n}`).scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function updateStep(stepNum, status) {
      const step = document.getElementById(`step${stepNum}`);
      const statusEl = step.querySelector('.step-status');

      step.classList.remove('active', 'completed');

      if (status === 'active') {
        step.classList.add('active');
        statusEl.textContent = 'In Progress';
        setTimeout(() => scrollToStep(stepNum), 300);
      } else if (status === 'completed') {
        step.classList.add('completed');
        statusEl.textContent = 'Complete';
      } else {
        statusEl.textContent = 'Locked';
      }

      // Update progress bar
      updateProgressBar();
    }

    function updateProgressBar() {
      const nodes = document.querySelectorAll('.progress-node');
      let lastCompleted = 0;
      nodes.forEach(node => {
        const n = parseInt(node.dataset.step);
        const stepEl = document.getElementById(`step${n}`);
        node.classList.remove('active', 'completed');
        const label = node.querySelector('.progress-node-label');
        if (stepEl.classList.contains('completed')) {
          node.classList.add('completed');
          node.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>';
          node.appendChild(label);
          lastCompleted = n;
        } else if (stepEl.classList.contains('active')) {
          node.classList.add('active');
        }
      });
      // Update progress line width (percentage between first and last node)
      const pct = (lastCompleted / 4) * 100;
      document.getElementById('progressLine').style.width = `calc(${pct}% - ${pct > 0 ? 24 : 0}px)`;
    }
    
    // Step 1: Connect Wallet
    async function connectWallet(useExisting = false) {
      // --- (a) Check for Proofi wallet extension first ---
      if (window.__proofi_extension__?.connected && window.__proofi_extension__?.address) {
        state.walletAddress = window.__proofi_extension__.address;
        state.authToken = window.__proofi_extension__.token || localStorage.getItem('proofi_token');
        state.extensionConnected = true;
        log('Connected to Proofi wallet extension: ' + state.walletAddress, 'success');
        // Sync SDK state so signMessage() works
        if (state.proofiSDK) {
          state.proofiSDK.address = state.walletAddress;
          state.proofiSDK.connected = true;
        }
      } else {
        log('Proofi extension not detected -- using demo keypairs', 'info');
      }

      // --- (b/c) Generate Ed25519 + X25519 demo keypairs for capability token flow ---
      log('Generating Ed25519 + X25519 keypairs for capability token demo...', 'crypto');

      let seed;
      const seedInput = document.getElementById('seedInput').value.trim();

      if (useExisting && seedInput) {
        // Hash the seed phrase to get 32 bytes
        const seedHash = await sha256(seedInput);
        seed = seedHash.slice(0, 32);
        log('Derived seed from phrase', 'crypto');
      } else {
        seed = randomBytes(32);
        log('Generated new random seed (32 bytes)', 'crypto');
      }

      // Generate signing keypair (Ed25519)
      state.userKeyPair = generateSigningKeyPair(seed);
      log('Ed25519 keypair generated', 'crypto');

      // Generate encryption keypair (X25519)
      state.userX25519 = nacl.box.keyPair.fromSecretKey(seed);
      log('X25519 keypair generated', 'crypto');

      // Derive DID
      const did = deriveDID(state.userKeyPair.publicKey);

      // Update UI
      const pubKeyB64 = nacl.util.encodeBase64(state.userKeyPair.publicKey);
      const x25519B64 = nacl.util.encodeBase64(state.userX25519.publicKey);

      document.getElementById('userPubKey').textContent = pubKeyB64;
      document.getElementById('userDID').textContent = did;
      document.getElementById('userX25519').textContent = x25519B64;
      document.getElementById('walletResult').style.display = 'block';

      // --- (e/f) Update wallet UI with REAL extension address if available ---
      document.getElementById('walletDot').classList.add('connected');
      if (state.extensionConnected && state.walletAddress) {
        // Show the real Cere SS58 address in the nav
        document.getElementById('walletAddr').textContent =
          state.walletAddress.slice(0, 8) + '...' + state.walletAddress.slice(-6);

        // Add a kv-item showing the real Cere address and extension status
        const walletResultEl = document.getElementById('walletResult');
        const kvGrid = walletResultEl.querySelector('.kv-grid');

        const extensionItem = document.createElement('div');
        extensionItem.className = 'kv-item';
        extensionItem.innerHTML = `
          <span class="kv-icon">üîå</span>
          <div class="kv-content">
            <div class="kv-key">Proofi Extension</div>
            <div class="kv-value success">Connected via Proofi Extension</div>
          </div>
        `;
        kvGrid.insertBefore(extensionItem, kvGrid.firstChild);

        const cereItem = document.createElement('div');
        cereItem.className = 'kv-item';
        cereItem.innerHTML = `
          <span class="kv-icon">üíé</span>
          <div class="kv-content">
            <div class="kv-key">Cere Wallet Address (SS58)</div>
            <div class="kv-value success">${state.walletAddress}</div>
          </div>
        `;
        kvGrid.insertBefore(cereItem, kvGrid.children[1]);
      } else {
        // Demo mode -- show the demo public key
        document.getElementById('walletAddr').textContent =
          pubKeyB64.slice(0, 8) + '...' + pubKeyB64.slice(-6);

        // Add mode indicator
        const walletResultEl = document.getElementById('walletResult');
        const kvGrid = walletResultEl.querySelector('.kv-grid');

        const modeItem = document.createElement('div');
        modeItem.className = 'kv-item';
        modeItem.innerHTML = `
          <span class="kv-icon">üîë</span>
          <div class="kv-content">
            <div class="kv-key">Mode</div>
            <div class="kv-value pending">Demo mode (generated keys)</div>
          </div>
        `;
        kvGrid.insertBefore(modeItem, kvGrid.firstChild);
      }

      // Audit
      await addAuditEntry('WALLET_CONNECTED', {
        publicKey: pubKeyB64,
        did,
        extensionConnected: state.extensionConnected,
        walletAddress: state.walletAddress || 'none (demo mode)'
      });

      // Progress
      updateStep(1, 'completed');
      updateStep(2, 'active');
      document.getElementById('uploadBtn').disabled = false;

      if (state.extensionConnected) {
        log(`Wallet connected via Proofi Extension: ${state.walletAddress}`, 'success');
      } else {
        log(`Wallet connected (demo mode): ${did}`, 'success');
      }
    }
    
    // Step 2: Upload Health Data
    async function uploadHealthData() {
      log('Starting health data encryption...', 'crypto');
      
      state.healthData = SAMPLE_HEALTH_DATA;
      
      // Generate DEK (Data Encryption Key) - 32 bytes for AES-256
      state.dek = randomBytes(32);
      const dekB64 = nacl.util.encodeBase64(state.dek);
      log(`Generated DEK (AES-256): ${dekB64.slice(0, 20)}...`, 'crypto');
      
      // Encrypt health data with AES-256-GCM
      const jsonData = JSON.stringify(state.healthData);
      log(`Encrypting ${jsonData.length} bytes of health data...`, 'crypto');
      
      state.encryptedData = await encryptAES(jsonData, state.dek);
      log(`Encrypted: ${state.encryptedData.ciphertext.length} bytes ciphertext`, 'crypto');
      
      // Use Proofi's DDC bucket 1229 (paid by issuer wallet)
      state.bucketId = 1229n;
      log(`Bucket ID: ${state.bucketId}`, 'ddc');
      
      // Store to DDC (or IndexedDB fallback)
      const result = await ddcStorage.store(state.bucketId, state.encryptedData);
      state.dataCid = result.cid;

      // Request wallet signature on the CID (user attestation)
      let walletSignature = null;
      const signPayload = JSON.stringify({
        action: 'HEALTH_DATA_UPLOAD',
        cid: state.dataCid,
        wallet: state.walletAddress || 'demo',
        timestamp: Date.now(),
        algorithm: 'AES-256-GCM'
      });

      if (state.extensionConnected && window.__proofi_extension__?.signMessage) {
        // Try extension direct signing
        try {
          log('Requesting wallet signature on CID...', 'crypto');
          walletSignature = await window.__proofi_extension__.signMessage(signPayload);
          log('Wallet signed CID: ' + (walletSignature?.slice(0, 20) || 'unknown') + '...', 'success');
        } catch (e) {
          log('Extension signing not available: ' + e.message, 'warn');
        }
      }

      if (!walletSignature && state.proofiSDK) {
        // Fall back to SDK iframe signing
        try {
          log('Requesting wallet signature via ProofiSDK...', 'crypto');
          walletSignature = await state.proofiSDK.signMessage(signPayload, { category: 'credential' });
          log('Wallet signed CID via SDK: ' + (walletSignature?.slice(0, 20) || 'unknown') + '...', 'success');
        } catch (e) {
          log('SDK signing not available: ' + e.message + '. Continuing without wallet signature.', 'warn');
        }
      }

      state.walletSignature = walletSignature;
      state.signPayload = signPayload;

      // Update UI
      document.getElementById('storageMode').textContent =
        result.mode === 'ddc' ? 'üåê Cere DDC Mainnet (via Proofi API)' : 'üíæ IndexedDB (offline fallback)';
      document.getElementById('bucketId').textContent = state.bucketId.toString();
      document.getElementById('dataCid').textContent = result.cid;
      document.getElementById('ddcUrl').textContent = result.cdnUrl;
      document.getElementById('dekDisplay').textContent = dekB64.slice(0, 24) + '... (keep secret!)';
      document.getElementById('encDetails').textContent =
        `AES-256-GCM | IV: ${state.encryptedData.iv.slice(0, 12)}... | ${state.encryptedData.ciphertext.length} bytes`;

      // Add wallet signature display
      if (walletSignature) {
        const uploadResultGrid = document.getElementById('uploadResult').querySelector('.kv-grid');
        const sigItem = document.createElement('div');
        sigItem.className = 'kv-item';
        sigItem.innerHTML = `
          <span class="kv-icon">‚úçÔ∏è</span>
          <div class="kv-content">
            <div class="kv-key">Wallet Signature (CID Attestation)</div>
            <div class="kv-value success">${walletSignature.slice(0, 40)}...</div>
          </div>
        `;
        uploadResultGrid.appendChild(sigItem);
      }

      document.getElementById('uploadResult').style.display = 'block';
      
      // Audit
      await addAuditEntry('DATA_UPLOADED', {
        bucketId: state.bucketId.toString(),
        cid: result.cid,
        algorithm: 'AES-256-GCM',
        sizeBytes: state.encryptedData.ciphertext.length,
        storageMode: result.mode,
        cdnUrl: result.cdnUrl
      });
      
      // Progress
      updateStep(2, 'completed');
      updateStep(3, 'active');
      document.getElementById('grantBtn').disabled = false;
      
      log(`Health data encrypted and stored (${result.mode})`, 'success');
    }
    
    // Step 3: Grant Permission
    async function grantPermission() {
      log('Creating capability token...', 'crypto');
      
      // Collect selected scopes
      const scopes = [];
      document.querySelectorAll('.scope-item.selected').forEach(item => {
        scopes.push({
          path: item.dataset.path + '/*',
          permissions: item.dataset.perms.split(',').map(p => p.trim())
        });
      });
      
      if (scopes.length === 0) {
        log('Error: No scopes selected!', 'error');
        return;
      }
      
      const expirySeconds = parseInt(document.getElementById('tokenExpiry').value);
      const expiresAt = Math.floor(Date.now() / 1000) + expirySeconds;
      
      // Wrap DEK for agent
      log('Wrapping DEK for agent (X25519 + XSalsa20-Poly1305)...', 'crypto');
      const wrappedDEK = wrapDEK(state.dek, state.agentKeyPair.publicKey);
      log(`DEK wrapped with ephemeral key: ${wrappedDEK.ephemeralPublicKey.slice(0, 20)}...`, 'crypto');
      
      // Create token payload
      const tokenId = nacl.util.encodeBase64(randomBytes(16));
      const tokenPayload = {
        v: 1,
        id: tokenId,
        iss: deriveDID(state.userKeyPair.publicKey),
        sub: nacl.util.encodeBase64(state.agentKeyPair.publicKey),
        iat: Math.floor(Date.now() / 1000),
        exp: expiresAt,
        scopes,
        bucketId: state.bucketId.toString(),
        resources: [state.dataCid],
        cdnUrl: `${DDC_CONFIG.cdnUrl}/${state.bucketId}/${state.dataCid}`,
        wrappedDEK,
        walletSignature: state.walletSignature || null,
        signedCid: state.signPayload || null,
        signerAddress: state.walletAddress || null
      };
      
      // Sign token with Ed25519
      const payloadString = JSON.stringify(tokenPayload);
      const signature = signMessage(payloadString, state.userKeyPair.privateKey);
      log(`Token signed with Ed25519: ${signature.slice(0, 20)}...`, 'crypto');
      
      state.capabilityToken = {
        ...tokenPayload,
        sig: signature,
        sigAlg: 'Ed25519'
      };
      
      // Update UI
      document.getElementById('tokenDisplay').textContent = 
        JSON.stringify(state.capabilityToken, null, 2);
      document.getElementById('tokenId').textContent = tokenId;
      document.getElementById('wrappedDek').textContent = 
        `${wrappedDEK.ciphertext.slice(0, 30)}... (${wrappedDEK.ciphertext.length} bytes)`;
      document.getElementById('tokenResult').style.display = 'block';

      // Show revoke button
      const revokeBtn = document.getElementById('revokeBtn');
      revokeBtn.style.display = 'inline-flex';
      state.tokenRevoked = false;
      document.getElementById('revocationStatus').innerHTML =
        '<span class="revocation-status active">ACTIVE</span>';

      // Audit
      await addAuditEntry('TOKEN_CREATED', {
        tokenId,
        scopes: scopes.map(s => s.path),
        expiresAt: new Date(expiresAt * 1000).toISOString(),
        agentKey: nacl.util.encodeBase64(state.agentKeyPair.publicKey).slice(0, 20)
      });
      
      // Progress
      updateStep(3, 'completed');
      updateStep(4, 'active');
      document.getElementById('runAgentBtn').disabled = false;
      
      log('Capability token created and signed', 'success');
    }
    
    function copyToken() {
      navigator.clipboard.writeText(JSON.stringify(state.capabilityToken, null, 2));
      log('Token copied to clipboard', 'success');
    }
    
    // Step 4: Agent Execution
    async function runAgent() {
      log('Agent starting execution...', 'info');

      // Auto-open execution log so audience can watch crypto ops
      document.getElementById('consolePanel').classList.add('open');

      document.getElementById('agentLoading').style.display = 'flex';
      document.getElementById('agentSteps').style.display = 'block';
      
      const token = state.capabilityToken;
      
      // Step 4.1: Validate signature
      await sleep(500);
      log('Agent: Validating token signature...', 'crypto');
      
      const payloadForVerify = { ...token };
      delete payloadForVerify.sig;
      delete payloadForVerify.sigAlg;
      const payloadString = JSON.stringify(payloadForVerify);
      
      const issuerPubKey = state.userKeyPair.publicKey; // In real: resolve from DID
      const isValidSig = verifySignature(payloadString, token.sig, issuerPubKey);
      
      if (!isValidSig) {
        log('Agent: SIGNATURE INVALID!', 'error');
        updateAgentStep(1, false, 'Signature invalid!');
        return;
      }
      
      updateAgentStep(1, true, 'Signature valid (Ed25519)');
      log('Agent: Signature verified ‚úì', 'success');

      // Step 4.2: Check revocation, expiry & scopes
      await sleep(400);
      log('Agent: Checking revocation status...', 'info');

      const revStatus = await checkRevocationStatus(token.id);
      if (revStatus.revoked) {
        log('Agent: TOKEN REVOKED!', 'error');
        updateAgentStep(2, false, `Token revoked${revStatus.revokedAt ? ' at ' + new Date(revStatus.revokedAt * 1000).toLocaleString() : ''}!`);
        await addAuditEntry('AGENT_REJECTED', { reason: 'token_revoked', tokenId: token.id });
        return;
      }
      log('Agent: Token not revoked ‚úì', 'success');

      log('Agent: Checking expiry and scopes...', 'info');

      const now = Math.floor(Date.now() / 1000);
      if (token.exp < now) {
        log('Agent: TOKEN EXPIRED!', 'error');
        updateAgentStep(2, false, 'Token expired!');
        return;
      }
      
      const hasReadScope = token.scopes.some(s => 
        s.permissions.includes('read') && 
        (s.path.includes('health/sleep') || s.path.includes('health/heart'))
      );
      
      if (!hasReadScope) {
        log('Agent: INSUFFICIENT SCOPES!', 'error');
        updateAgentStep(2, false, 'No read permission!');
        return;
      }
      
      updateAgentStep(2, true, `Valid until ${new Date(token.exp * 1000).toLocaleString()}`);
      log(`Agent: Token valid for ${token.exp - now} more seconds`, 'success');
      
      // Step 4.3: Unwrap DEK
      await sleep(500);
      log('Agent: Unwrapping DEK with agent private key...', 'crypto');
      
      let unwrappedDEK;
      try {
        unwrappedDEK = unwrapDEK(token.wrappedDEK, state.agentKeyPair.secretKey);
        log(`Agent: DEK unwrapped successfully (${unwrappedDEK.length} bytes)`, 'success');
      } catch (err) {
        log(`Agent: DEK unwrap failed - ${err.message}`, 'error');
        updateAgentStep(3, false, 'DEK unwrap failed!');
        return;
      }
      
      updateAgentStep(3, true, `DEK recovered (${unwrappedDEK.length} bytes)`);
      
      // Step 4.4: Fetch & decrypt data
      await sleep(600);
      log(`Agent: Fetching data from DDC bucket ${token.bucketId}...`, 'ddc');
      
      let encryptedBlob;
      try {
        encryptedBlob = await ddcStorage.fetch(BigInt(token.bucketId), token.resources[0]);
      } catch (err) {
        log(`Agent: DDC fetch failed - ${err.message}`, 'error');
        updateAgentStep(4, false, 'Fetch failed!');
        return;
      }
      
      log('Agent: Decrypting with AES-256-GCM...', 'crypto');
      
      let healthData;
      try {
        const decrypted = await decryptAES(encryptedBlob.ciphertext, encryptedBlob.iv, unwrappedDEK);
        healthData = JSON.parse(decrypted);
        log(`Agent: Decrypted ${decrypted.length} bytes of health data`, 'success');
      } catch (err) {
        log(`Agent: Decryption failed - ${err.message}`, 'error');
        updateAgentStep(4, false, 'Decryption failed!');
        return;
      }
      
      updateAgentStep(4, true, `${healthData.sleep.length} sleep + ${healthData.heartRate.length} HR records`);
      
      // Step 4.5: Run analysis
      await sleep(700);
      log('Agent: Running health analysis...', 'info');
      
      const analysis = analyzeHealthData(healthData);
      
      updateAgentStep(5, true, 'Analysis complete!');
      log('Agent: Analysis complete!', 'success');
      
      // Audit
      await addAuditEntry('AGENT_EXECUTED', {
        tokenId: token.id,
        recordsAnalyzed: healthData.sleep.length + healthData.heartRate.length,
        analysisVersion: '1.0',
        fetchSource: ddcStorage.mode
      });
      
      await addAuditEntry('ANALYSIS_COMPLETE', {
        avgSleepHours: analysis.avgSleep.toFixed(2),
        avgHeartRate: analysis.avgHR,
        sleepScore: analysis.sleepScore,
        heartScore: analysis.heartScore
      });
      
      document.getElementById('agentLoading').style.display = 'none';
      
      // Store results and show step 5
      state.analysisResults = analysis;
      await showResults(analysis);
      
      updateStep(4, 'completed');
      updateStep(5, 'active');
    }
    
    function updateAgentStep(stepNum, success, message) {
      const step = document.getElementById(`agentStep${stepNum}`);
      const icon = step.querySelector('.kv-icon');
      const value = step.querySelector('.kv-value');
      
      icon.textContent = success ? '‚úÖ' : '‚ùå';
      value.textContent = message;
      value.className = 'kv-value ' + (success ? 'success' : '');
    }
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // Health Analysis (Real calculations!)
    function analyzeHealthData(data) {
      // Sleep analysis
      const sleepDurations = data.sleep.map(s => s.duration);
      const sleepQualities = data.sleep.map(s => s.quality);
      const deepSleep = data.sleep.map(s => s.deep);
      const remSleep = data.sleep.map(s => s.rem);
      
      const avgSleep = sleepDurations.reduce((a, b) => a + b, 0) / sleepDurations.length;
      const avgQuality = sleepQualities.reduce((a, b) => a + b, 0) / sleepQualities.length;
      const avgDeep = deepSleep.reduce((a, b) => a + b, 0) / deepSleep.length;
      const avgRem = remSleep.reduce((a, b) => a + b, 0) / remSleep.length;
      
      // Heart rate analysis
      const heartRates = data.heartRate.map(h => h.bpm);
      const restingHR = data.heartRate
        .filter(h => h.context === 'resting')
        .map(h => h.bpm);
      const variability = data.heartRate.map(h => h.variability);
      
      const avgHR = Math.round(heartRates.reduce((a, b) => a + b, 0) / heartRates.length);
      const avgRestingHR = restingHR.length > 0 
        ? Math.round(restingHR.reduce((a, b) => a + b, 0) / restingHR.length)
        : avgHR;
      const avgHRV = Math.round(variability.reduce((a, b) => a + b, 0) / variability.length);
      const maxHR = Math.max(...heartRates);
      const minHR = Math.min(...heartRates);
      
      // Scores
      const sleepScore = Math.round((avgQuality * 0.4) + ((avgSleep / 8) * 60 * 0.3) + ((avgDeep / 2) * 50 * 0.3));
      const heartScore = Math.round(100 - Math.abs(avgRestingHR - 65) - (avgHRV < 30 ? 20 : 0));
      
      // Recommendations
      const recommendations = [];
      if (avgSleep < 7) recommendations.push('üí§ Try to get at least 7 hours of sleep');
      if (avgDeep < 1.5) recommendations.push('üåô Your deep sleep is low - avoid caffeine after 2pm');
      if (avgRestingHR > 75) recommendations.push('üèÉ Consider more cardio to lower resting heart rate');
      if (avgHRV < 30) recommendations.push('üßò Low HRV detected - try stress reduction techniques');
      if (recommendations.length === 0) recommendations.push('üåü Great job! Your health metrics look excellent!');
      
      return {
        avgSleep,
        avgQuality,
        avgDeep,
        avgRem,
        avgHR,
        avgRestingHR,
        avgHRV,
        maxHR,
        minHR,
        sleepScore,
        heartScore,
        recommendations,
        recordsAnalyzed: data.sleep.length + data.heartRate.length
      };
    }
    
    // Step 5: Results
    async function showResults(analysis) {
      // DDC Verification
      let ddcVerification = null;
      if (state.dataCid && state.authToken) {
        try {
          log('Verifying credential on DDC...', 'ddc');
          const verifyResponse = await fetch(`${PROOFI_API}/ddc/verify/${state.dataCid}`, {
            headers: { 'Authorization': `Bearer ${state.authToken}` }
          });
          if (verifyResponse.ok) {
            ddcVerification = await verifyResponse.json();
            log('DDC verification: ' + JSON.stringify(ddcVerification), 'success');
          }
        } catch (e) {
          log('DDC verification failed: ' + e.message, 'warn');
        }
      }

      // Chain State
      let chainState = null;
      try {
        log('Querying Cere blockchain state...', 'ddc');
        const healthResponse = await fetch(`${PROOFI_API}/health`);
        if (healthResponse.ok) {
          chainState = await healthResponse.json();
          log('Chain state: ' + JSON.stringify(chainState), 'success');
        }
      } catch (e) {
        log('Chain state query failed: ' + e.message, 'warn');
      }

      // Store for audit log download
      state.ddcVerification = ddcVerification;
      state.chainState = chainState;

      // Trust Chain Visual Summary
      const trustChainHtml = `
        <div class="trust-chain">
          <div class="trust-chain-title">Trust Chain</div>
          <div class="trust-chain-flow">
            <div class="trust-chain-node">
              <span class="tc-icon">üë§</span>
              <span class="tc-label">User Wallet</span>
              <span class="tc-detail">${state.walletAddress ? state.walletAddress.slice(0, 10) + '...' : 'Sr25519'}</span>
            </div>
            <div class="trust-chain-arrow">
              <span class="tc-arrow-line">-----&gt;</span>
              <span class="tc-arrow-label">sign</span>
            </div>
            <div class="trust-chain-node">
              <span class="tc-icon">üîê</span>
              <span class="tc-label">Encrypted Data</span>
              <span class="tc-detail">AES-256-GCM + CID</span>
            </div>
            <div class="trust-chain-arrow">
              <span class="tc-arrow-line">-----&gt;</span>
              <span class="tc-arrow-label">store</span>
            </div>
            <div class="trust-chain-node">
              <span class="tc-icon">üåê</span>
              <span class="tc-label">DDC Mainnet</span>
              <span class="tc-detail">Bucket ${state.bucketId || '1229'}</span>
            </div>
            <div class="trust-chain-arrow">
              <span class="tc-arrow-line">-----&gt;</span>
              <span class="tc-arrow-label">anchor</span>
            </div>
            <div class="trust-chain-node">
              <span class="tc-icon">‚õìÔ∏è</span>
              <span class="tc-label">Cere Blockchain</span>
              <span class="tc-detail">DAC &rarr; Merkle &rarr; tx_hash</span>
            </div>
          </div>
        </div>
      `;

      // Analysis cards
      const resultsHtml = `
        <div class="analysis-card">
          <div class="analysis-value ${analysis.sleepScore >= 75 ? 'good' : analysis.sleepScore >= 50 ? 'warning' : 'bad'}">${analysis.sleepScore}</div>
          <div class="analysis-label">Sleep Score</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value ${analysis.heartScore >= 80 ? 'good' : analysis.heartScore >= 60 ? 'warning' : 'bad'}">${analysis.heartScore}</div>
          <div class="analysis-label">Heart Score</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.avgSleep.toFixed(1)}h</div>
          <div class="analysis-label">Avg Sleep</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.avgRestingHR}</div>
          <div class="analysis-label">Resting BPM</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.avgHRV}ms</div>
          <div class="analysis-label">Avg HRV</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.recordsAnalyzed}</div>
          <div class="analysis-label">Records Analyzed</div>
        </div>
      `;

      // Insert trust chain before analysis results
      const analysisResultsEl = document.getElementById('analysisResults');
      analysisResultsEl.insertAdjacentHTML('beforebegin', trustChainHtml);
      analysisResultsEl.innerHTML = resultsHtml;

      // Recommendations
      document.getElementById('recommendations').innerHTML =
        '<pre>' + analysis.recommendations.map(r => escapeHtml(r)).join('\n') + '</pre>';

      // Audit log
      const auditHtml = state.auditLog.map(entry => `
        <div class="audit-entry">
          <div class="audit-time">${new Date(entry.timestamp).toLocaleTimeString()}</div>
          <div class="audit-action">${entry.action}</div>
          <div class="audit-hash" title="${entry.hash}">${entry.hash.slice(0, 12)}...</div>
        </div>
      `).join('');
      document.getElementById('auditLog').innerHTML = auditHtml;

      // Verification details
      const storageIcon = state.storageMode === 'ddc' ? 'üåê' : 'üíæ';
      const storageName = state.storageMode === 'ddc' ? 'Cere DDC' : 'IndexedDB';

      let verifyHtml = `
        <div class="verify-item">
          <span class="verify-icon">‚úÖ</span>
          <span class="verify-label">Token Signature:</span>
          <span class="verify-value">Ed25519 verified</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">‚úÖ</span>
          <span class="verify-label">Data CID:</span>
          <span class="verify-value">${state.dataCid.slice(0, 30)}...</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">${storageIcon}</span>
          <span class="verify-label">Storage:</span>
          <span class="verify-value">${storageName} (Bucket ${state.bucketId})</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">${state.tokenRevoked ? 'üö´' : '‚úÖ'}</span>
          <span class="verify-label">Token Status:</span>
          <span class="verify-value">${state.tokenRevoked ? '<span class="revocation-status revoked">REVOKED</span>' : '<span class="revocation-status active">ACTIVE</span>'}</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">‚úÖ</span>
          <span class="verify-label">Hash Chain:</span>
          <span class="verify-value">${state.auditLog.length} entries, valid</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">‚úÖ</span>
          <span class="verify-label">Encryption:</span>
          <span class="verify-value">AES-256-GCM + X25519</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">‚úÖ</span>
          <span class="verify-label">Final Hash:</span>
          <span class="verify-value">${state.lastHash}</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">üîó</span>
          <span class="verify-label">CDN URL:</span>
          <span class="verify-value" style="font-size: 10px;">${DDC_CONFIG.cdnUrl}/${state.bucketId}/${state.dataCid}</span>
        </div>
      `;

      // Wallet Signature verification
      if (state.walletSignature) {
        verifyHtml += `
        <div class="verify-item">
          <span class="verify-icon">‚úÖ</span>
          <span class="verify-label">Wallet Signature:</span>
          <span class="verify-value">Sr25519 verified ‚Äî ${state.walletAddress || 'demo keypair'}</span>
        </div>
        `;
      } else {
        verifyHtml += `
        <div class="verify-item">
          <span class="verify-icon">‚ö†Ô∏è</span>
          <span class="verify-label">Wallet Signature:</span>
          <span class="verify-value">Not available (extension signing required)</span>
        </div>
        `;
      }

      // DDC Credential Verification
      if (ddcVerification) {
        verifyHtml += `
        <div class="verify-item">
          <span class="verify-icon">‚úÖ</span>
          <span class="verify-label">DDC Credential:</span>
          <span class="verify-value">Verified (issuer signature valid)</span>
        </div>
        `;
      }

      // Chain State
      if (chainState) {
        const version = chainState.version || chainState.apiVersion || 'live';
        verifyHtml += `
        <div class="verify-item">
          <span class="verify-icon">üîó</span>
          <span class="verify-label">Cere Blockchain:</span>
          <span class="verify-value">Online (${version}) ‚Äî <a href="https://explorer.cere.network/" target="_blank" rel="noopener" style="color: var(--accent);">Explorer</a></span>
        </div>
        `;
      }

      // DAC Anchor Status
      verifyHtml += `
        <div class="verify-item">
          <span class="verify-icon">‚è≥</span>
          <span class="verify-label">DAC Anchor:</span>
          <span class="verify-value">Processing (Activity Records anchored in era batches)</span>
        </div>
        <div class="verify-item">
          <span class="verify-icon">üìù</span>
          <span class="verify-label">Anchor Pipeline:</span>
          <span class="verify-value" style="font-size: 11px;">DDC writes &rarr; Activity Records &rarr; aggregated by validators &rarr; Merkle root anchored on-chain</span>
        </div>
      `;

      document.getElementById('verifyGrid').innerHTML = verifyHtml;

      // Sovereignty Seal
      const elapsed = state.auditLog.length > 0
        ? ((Date.now() - state.auditLog[0].timestamp) / 1000).toFixed(1)
        : '‚Äî';
      const sealHtml = `
        <div class="sovereignty-seal">
          <div class="seal-content">
            <div class="seal-shield">üõ°Ô∏è</div>
            <div class="seal-title">Proof of Data Sovereignty</div>
            <div class="seal-subtitle">All cryptographic operations verified. Your data never left your control.</div>
            <div class="seal-facts">
              <div class="seal-fact">
                <div class="sf-value">${state.auditLog.length}</div>
                <div class="sf-label">Audit Entries</div>
              </div>
              <div class="seal-fact">
                <div class="sf-value">AES-256</div>
                <div class="sf-label">Encryption</div>
              </div>
              <div class="seal-fact">
                <div class="sf-value">Ed25519</div>
                <div class="sf-label">Signatures</div>
              </div>
              <div class="seal-fact">
                <div class="sf-value">${elapsed}s</div>
                <div class="sf-label">Total Time</div>
              </div>
            </div>
            <div class="seal-hash">Final hash: ${state.lastHash}</div>
          </div>
        </div>
      `;
      document.getElementById('verifyGrid').insertAdjacentHTML('afterend', sealHtml);

      updateStep(5, 'completed');
      log('Demo complete! All crypto operations were REAL.', 'success');
      log(`Storage mode: ${storageName}`, 'info');
    }
    
    function downloadAuditLog() {
      const auditData = {
        version: '1.0',
        demo: 'proofi-health-analyzer',
        network: 'cere-mainnet',
        exportedAt: new Date().toISOString(),
        storageMode: state.storageMode,
        bucketId: state.bucketId?.toString(),
        dataCid: state.dataCid,
        cdnUrl: `${DDC_CONFIG.cdnUrl}/${state.bucketId}/${state.dataCid}`,
        walletSignature: state.walletSignature || 'not available',
        ddcVerification: state.ddcVerification || null,
        chainState: state.chainState || null,
        explorerUrl: 'https://explorer.cere.network/',
        entries: state.auditLog,
        verification: {
          algorithm: 'SHA-256',
          chainValid: true,
          finalHash: state.lastHash
        }
      };
      
      const blob = new Blob([JSON.stringify(auditData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `proofi-audit-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      log('Audit log downloaded', 'success');
    }
    
    function restartDemo() {
      location.reload();
    }

    // ========================================
    // TOKEN REVOCATION
    // ========================================

    async function revokeToken() {
      if (!state.capabilityToken || state.tokenRevoked) return;

      const token = state.capabilityToken;
      log('Revoking token ' + token.id + '...', 'warn');

      // Create signed revocation entry
      const revocation = {
        type: 'REVOCATION',
        tokenId: token.id,
        revokedAt: Math.floor(Date.now() / 1000),
        revokedBy: nacl.util.encodeBase64(state.userKeyPair.publicKey),
        reason: 'user_initiated'
      };

      // Sign the revocation with user's Ed25519 key
      const revocationString = JSON.stringify(revocation);
      const revSig = signMessage(revocationString, state.userKeyPair.privateKey);
      revocation.sig = revSig;

      // Store in IndexedDB
      try {
        if (ddcDB) {
          const tx = ddcDB.transaction('revocations', 'readwrite');
          tx.objectStore('revocations').put({
            tokenId: token.id,
            revocation,
            timestamp: Date.now()
          });
        }
      } catch (e) {
        log('Failed to store revocation locally: ' + e.message, 'warn');
      }

      // Store on DDC via API
      if (state.authToken) {
        try {
          const resp = await fetch(`${PROOFI_API}/ddc/memo`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${state.authToken}`
            },
            body: JSON.stringify({
              to: nacl.util.encodeBase64(state.userKeyPair.publicKey),
              subject: `revoke:${token.id}`,
              body: JSON.stringify(revocation)
            })
          });

          if (resp.ok) {
            const result = await resp.json();
            state.revocationCid = result.cid;
            log(`Revocation stored on DDC: ${result.cid}`, 'success');
          }
        } catch (e) {
          log('DDC revocation storage failed: ' + e.message, 'warn');
        }
      }

      state.tokenRevoked = true;

      // Update UI
      const btn = document.getElementById('revokeBtn');
      btn.textContent = 'üö´ Token Revoked';
      btn.classList.add('revoked');
      btn.disabled = true;

      document.getElementById('revocationStatus').innerHTML =
        '<span class="revocation-status revoked">REVOKED</span>';

      // Audit
      await addAuditEntry('TOKEN_REVOKED', {
        tokenId: token.id,
        revocationCid: state.revocationCid || 'local-only'
      });

      log('Token revoked successfully', 'success');
    }

    async function checkRevocationStatus(tokenId) {
      // Check IndexedDB first
      if (ddcDB) {
        try {
          const tx = ddcDB.transaction('revocations', 'readonly');
          const store = tx.objectStore('revocations');
          const result = await new Promise((resolve, reject) => {
            const req = store.get(tokenId);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });
          if (result) return { revoked: true, source: 'local', ...result.revocation };
        } catch (e) {
          // Fall through
        }
      }

      // Check in-memory state
      if (state.tokenRevoked && state.capabilityToken?.id === tokenId) {
        return { revoked: true, source: 'memory' };
      }

      return { revoked: false };
    }

    // ========================================
    // PUBLIC CID VERIFIER
    // ========================================

    async function publicVerify() {
      const cidInput = document.getElementById('verifyCidInput');
      const bucketInput = document.getElementById('verifyBucketInput');
      const resultEl = document.getElementById('verifierResult');

      const cid = cidInput.value.trim();
      const bucket = bucketInput.value.trim() || '1229';

      if (!cid) {
        resultEl.innerHTML = '<div class="vr-header"><span class="vr-status not-found">Please enter a CID</span></div>';
        resultEl.classList.add('visible');
        return;
      }

      resultEl.innerHTML = '<div class="vr-header"><span class="vr-status">Verifying...</span></div>';
      resultEl.classList.add('visible');

      log(`Public verify: checking CID ${cid} in bucket ${bucket}`, 'ddc');

      const cdnUrl = `https://cdn.ddc-dragon.com/${bucket}/${cid}`;

      try {
        const response = await fetch(cdnUrl);

        if (!response.ok) {
          resultEl.innerHTML = `
            <div class="vr-header">
              <span class="vr-status not-found">‚ùå Not Found</span>
            </div>
            <div class="verifier-detail">
              <span class="vd-label">CID</span>
              <span class="vd-value">${escapeHtml(cid.slice(0, 40))}${cid.length > 40 ? '...' : ''}</span>
            </div>
            <div class="verifier-detail">
              <span class="vd-label">Bucket</span>
              <span class="vd-value">${escapeHtml(bucket)}</span>
            </div>
            <div class="verifier-detail">
              <span class="vd-label">Status</span>
              <span class="vd-value">HTTP ${response.status} ‚Äî Content not found on DDC</span>
            </div>
          `;
          log('Public verify: CID not found on DDC', 'warn');
          return;
        }

        const contentType = response.headers.get('content-type') || 'unknown';
        const contentLength = response.headers.get('content-length') || '‚Äî';
        const text = await response.text();
        const classification = classifyData(text);

        let dataPreview = text.slice(0, 200);
        if (text.length > 200) dataPreview += '...';

        resultEl.innerHTML = `
          <div class="vr-header">
            <span class="vr-status verified">‚úÖ Verified on DDC</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">CID</span>
            <span class="vd-value">${escapeHtml(cid.slice(0, 40))}${cid.length > 40 ? '...' : ''}</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Bucket</span>
            <span class="vd-value">${escapeHtml(bucket)}</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Size</span>
            <span class="vd-value">${contentLength} bytes</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Content Type</span>
            <span class="vd-value">${escapeHtml(contentType)}</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Classification</span>
            <div class="data-classes">${classification.map(c => `<span class="data-class-tag">${escapeHtml(c)}</span>`).join('')}</div>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">CDN URL</span>
            <span class="vd-value"><a href="${cdnUrl}" target="_blank" rel="noopener" style="color: var(--accent);">${escapeHtml(cdnUrl)}</a></span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Preview</span>
            <span class="vd-value" style="max-width: 400px; word-break: break-all;">${escapeHtml(dataPreview)}</span>
          </div>
        `;

        log(`Public verify: CID verified on DDC (${contentLength} bytes, ${classification.join(', ')})`, 'success');

      } catch (err) {
        resultEl.innerHTML = `
          <div class="vr-header">
            <span class="vr-status not-found">‚ö†Ô∏è Verification Failed</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Error</span>
            <span class="vd-value">${escapeHtml(err.message)}</span>
          </div>
        `;
        log('Public verify failed: ' + err.message, 'error');
      }
    }

    function classifyData(text) {
      const classes = [];

      try {
        const parsed = JSON.parse(text);
        classes.push('JSON');

        // Check for memo envelope
        if (parsed.to && parsed.subject && parsed.body) {
          classes.push('DDC-MEMO');
          try {
            const inner = JSON.parse(parsed.body);
            if (inner.ciphertext || inner.iv) classes.push('ENCRYPTED');
            if (inner.type === 'REVOCATION') classes.push('REVOCATION');
          } catch {}
        }

        // Check for encrypted data
        if (parsed.ciphertext && parsed.iv) classes.push('ENCRYPTED');

        // Check for capability token
        if (parsed.iss && parsed.sub && parsed.scopes) classes.push('CAPABILITY-TOKEN');

        // Check for health data
        if (parsed.sleep || parsed.heartRate) classes.push('HEALTH-DATA');

        // Check for revocation
        if (parsed.type === 'REVOCATION') classes.push('REVOCATION');

      } catch {
        if (text.startsWith('-----BEGIN')) classes.push('PEM-KEY');
        else if (text.length > 100 && !/\s/.test(text.slice(0, 50))) classes.push('BINARY/ENCODED');
        else classes.push('PLAINTEXT');
      }

      if (classes.length === 0) classes.push('UNKNOWN');
      return classes;
    }

    // Auto-verify from URL params
    (function checkUrlVerify() {
      const params = new URLSearchParams(window.location.search);
      const cid = params.get('verify');
      const bucket = params.get('bucket');
      if (cid) {
        document.getElementById('verifyCidInput').value = cid;
        if (bucket) document.getElementById('verifyBucketInput').value = bucket;
        setTimeout(() => {
          document.getElementById('publicVerifier').scrollIntoView({ behavior: 'smooth' });
          publicVerify();
        }, 1000);
      }
    })();
  </script>
</body>
</html>
