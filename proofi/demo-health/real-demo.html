<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proofi — Health Data Analysis</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='8' fill='%231d1d1f'/%3E%3Ccircle cx='16' cy='16' r='8' fill='none' stroke='%23fff' stroke-width='2'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #f5f5f7;
      --bg-alt: #ffffff;
      --surface: #ffffff;
      --text: #1d1d1f;
      --text-secondary: #86868b;
      --text-tertiary: #aeaeb2;
      --border: rgba(0,0,0,0.06);
      --border-subtle: rgba(0,0,0,0.04);
      --accent: #1d1d1f;
      --accent-light: #424245;
      --success: #34c759;
      --warning: #ff9500;
      --error: #ff3b30;
      --blue: #007aff;
      --font: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', sans-serif;
      --mono: 'SF Mono', SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      --radius: 16px;
      --radius-sm: 12px;
      --shadow: 0 2px 8px rgba(0,0,0,0.04);
      --shadow-md: 0 4px 16px rgba(0,0,0,0.06);
    }

    :focus-visible {
      outline: 2px solid var(--blue);
      outline-offset: 2px;
    }

    .skip-to-content {
      position: absolute;
      top: -100%;
      left: 16px;
      z-index: 999;
      padding: 12px 24px;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      text-decoration: none;
      border-radius: 980px;
    }
    .skip-to-content:focus { top: 16px; }
    
    html { scroll-behavior: smooth; }
    
    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      min-height: 100vh;
      line-height: 1.5;
      font-size: 17px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    /* ===== NAV ===== */
    nav {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(255,255,255,0.72);
      backdrop-filter: saturate(180%) blur(20px);
      -webkit-backdrop-filter: saturate(180%) blur(20px);
      border-bottom: 1px solid var(--border);
    }
    .nav-inner {
      max-width: 980px;
      margin: 0 auto;
      padding: 0 22px;
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .nav-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .nav-logo {
      font-size: 21px;
      font-weight: 600;
      text-decoration: none;
      color: var(--text);
      letter-spacing: -0.02em;
    }
    .nav-badge {
      font-size: 12px;
      padding: 5px 12px;
      background: var(--bg);
      color: var(--text-secondary);
      border-radius: 980px;
      font-weight: 500;
      letter-spacing: 0.01em;
    }
    .nav-badge.offline {
      background: rgba(255,149,0,0.12);
      color: var(--warning);
    }
    .wallet-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .wallet-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
    }
    .wallet-dot.connected { background: var(--success); }
    .wallet-addr {
      font-family: var(--mono);
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    /* ===== DDC STATUS BANNER ===== */
    .ddc-banner {
      background: rgba(52,199,89,0.08);
      padding: 12px 22px;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      color: var(--text-secondary);
    }
    .ddc-banner.offline {
      background: rgba(255,149,0,0.08);
    }
    .ddc-banner.error {
      background: rgba(255,59,48,0.08);
    }
    .ddc-banner .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }
    .ddc-banner.offline .status-dot { background: var(--warning); }
    .ddc-banner.error .status-dot { background: var(--error); }
    
    /* ===== MAIN ===== */
    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 60px 22px 120px;
    }
    
    /* ===== HERO ===== */
    .hero {
      text-align: center;
      margin-bottom: 80px;
      padding: 20px 0 0;
    }
    .hero h1 {
      font-size: clamp(40px, 6vw, 56px);
      font-weight: 700;
      letter-spacing: -0.025em;
      margin-bottom: 16px;
      line-height: 1.1;
      color: var(--text);
    }
    .hero p {
      color: var(--text-secondary);
      font-size: 19px;
      max-width: 600px;
      margin: 0 auto;
      line-height: 1.5;
      font-weight: 400;
    }
    
    /* ===== PROGRESS BAR ===== */
    .progress-bar {
      position: sticky;
      top: 52px;
      z-index: 99;
      background: rgba(255,255,255,0.88);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 20px 22px 36px;
    }
    .progress-bar-inner {
      max-width: 700px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
    }
    .progress-bar-inner::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 24px;
      right: 24px;
      height: 1px;
      background: var(--border);
      transform: translateY(-50%);
      z-index: 0;
    }
    .progress-line {
      position: absolute;
      top: 50%;
      left: 24px;
      height: 1px;
      background: var(--accent);
      transform: translateY(-50%);
      z-index: 1;
      transition: width 0.6s ease-out;
      width: 0%;
    }
    .progress-node {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--surface);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      font-weight: 600;
      z-index: 2;
      position: relative;
      transition: all 0.3s ease-out;
      cursor: pointer;
      color: var(--text-secondary);
    }
    .progress-node.active {
      border-color: var(--accent);
      background: var(--surface);
      color: var(--text);
    }
    .progress-node.completed {
      border-color: var(--accent);
      background: var(--accent);
      color: #fff;
    }
    .progress-node-label {
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: var(--text-tertiary);
      white-space: nowrap;
      font-weight: 500;
      letter-spacing: 0.02em;
    }
    .progress-node.active .progress-node-label,
    .progress-node.completed .progress-node-label {
      color: var(--text-secondary);
    }

    /* ===== STEPS ===== */
    .steps {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .step {
      background: var(--surface);
      border-radius: var(--radius);
      overflow: hidden;
      transition: box-shadow 0.3s ease-out;
      box-shadow: var(--shadow);
    }
    .step.active {
      box-shadow: var(--shadow-md);
    }
    .step.completed {
      opacity: 0.92;
    }
    
    .step-header {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 24px 28px;
      cursor: pointer;
      transition: background 0.2s ease-out;
    }
    .step-header:hover {
      background: rgba(0,0,0,0.015);
    }
    
    .step-num {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      font-weight: 600;
      flex-shrink: 0;
      color: var(--text-secondary);
      transition: all 0.2s ease-out;
    }
    .step.completed .step-num {
      background: var(--accent);
      color: #fff;
    }
    .step.completed .step-num::after {
      content: '✓';
      font-size: 14px;
    }
    .step.completed .step-num span { display: none; }
    
    .step-info { flex: 1; }
    .step-title {
      font-size: 17px;
      font-weight: 600;
      margin-bottom: 3px;
      color: var(--text);
      letter-spacing: -0.01em;
    }
    .step-desc {
      font-size: 14px;
      color: var(--text-secondary);
    }
    
    .step-status {
      font-size: 12px;
      padding: 6px 14px;
      border-radius: 980px;
      background: var(--bg);
      color: var(--text-secondary);
      font-weight: 500;
    }
    .step.completed .step-status {
      background: var(--accent);
      color: #fff;
    }
    .step.active .step-status {
      background: var(--blue);
      color: #fff;
    }
    
    .step-body {
      padding: 0 28px 28px;
      display: none;
    }
    .step.active .step-body,
    .step.expanded .step-body { display: block; }
    
    /* ===== FORM ELEMENTS ===== */
    .form-group {
      margin-bottom: 24px;
    }
    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-secondary);
      letter-spacing: 0.01em;
    }
    .form-input {
      width: 100%;
      padding: 14px 18px;
      background: var(--bg);
      border: none;
      border-radius: var(--radius-sm);
      color: var(--text);
      font-family: var(--mono);
      font-size: 14px;
      outline: none;
      transition: box-shadow 0.2s ease-out;
    }
    .form-input:focus {
      box-shadow: 0 0 0 4px rgba(0,122,255,0.15);
    }
    .form-input::placeholder { color: var(--text-tertiary); }
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 14px 28px;
      font-family: var(--font);
      font-size: 15px;
      font-weight: 500;
      border: none;
      border-radius: 980px;
      cursor: pointer;
      transition: all 0.2s ease-out;
      text-decoration: none;
    }
    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-primary:hover {
      background: var(--accent-light);
    }
    .btn-primary:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .btn-secondary {
      background: transparent;
      color: var(--blue);
      border: 1px solid rgba(0,0,0,0.12);
    }
    .btn-secondary:hover {
      background: rgba(0,0,0,0.03);
    }
    
    .btn-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    /* ===== DATA DISPLAY ===== */
    .data-box {
      background: var(--bg);
      border-radius: var(--radius-sm);
      padding: 18px;
      margin-bottom: 20px;
      font-family: var(--mono);
      font-size: 12px;
      overflow-x: auto;
      max-height: 280px;
      overflow-y: auto;
      color: var(--text-secondary);
    }
    .data-box pre {
      white-space: pre-wrap;
      word-break: break-all;
    }
    .data-box.scrollable {
      max-height: 360px;
    }
    
    .data-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .data-label span {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
    }
    .data-label .copy-btn {
      font-size: 12px;
      padding: 6px 12px;
      background: var(--bg);
      border: none;
      border-radius: 980px;
      color: var(--text-secondary);
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease-out;
    }
    .data-label .copy-btn:hover {
      background: var(--accent);
      color: #fff;
    }
    
    /* ===== KEY VALUE PAIRS ===== */
    .kv-grid {
      display: grid;
      gap: 1px;
      background: var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }
    .kv-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 16px 20px;
      background: var(--bg);
    }
    .kv-icon { display: none; }
    .kv-content { flex: 1; min-width: 0; }
    .kv-key {
      font-size: 12px;
      color: var(--text-tertiary);
      margin-bottom: 4px;
      letter-spacing: 0.01em;
    }
    .kv-value {
      font-family: var(--mono);
      font-size: 13px;
      word-break: break-all;
      color: var(--text);
    }
    .kv-value.success { color: var(--success); }
    .kv-value.pending { color: var(--warning); }
    .kv-value.ddc { color: var(--blue); }
    
    /* ===== LOADING ===== */
    .loading {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 20px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 20px;
      font-size: 15px;
      color: var(--text-secondary);
    }
    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* ===== SCOPE EDITOR ===== */
    .scope-grid {
      display: grid;
      gap: 10px;
      margin-bottom: 24px;
    }
    .scope-item {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 18px 20px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s ease-out;
    }
    .scope-item:hover {
      background: rgba(0,0,0,0.04);
    }
    .scope-item.selected {
      background: rgba(0,122,255,0.08);
    }
    .scope-check {
      width: 22px;
      height: 22px;
      border: 2px solid var(--border);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
      transition: all 0.2s ease-out;
      color: transparent;
    }
    .scope-item.selected .scope-check {
      background: var(--blue);
      border-color: var(--blue);
      color: #fff;
    }
    .scope-icon { display: none; }
    .scope-info { flex: 1; }
    .scope-path {
      font-family: var(--mono);
      font-size: 14px;
      font-weight: 500;
      color: var(--text);
    }
    .scope-perms {
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    
    /* ===== ANALYSIS RESULTS ===== */
    .analysis-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 32px;
    }
    .analysis-card {
      background: var(--bg);
      border-radius: var(--radius-sm);
      padding: 24px 20px;
      text-align: center;
    }
    .analysis-value {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 4px;
      letter-spacing: -0.02em;
      color: var(--text);
    }
    .analysis-value.good { color: var(--success); }
    .analysis-value.warning { color: var(--warning); }
    .analysis-value.bad { color: var(--error); }
    .analysis-label {
      font-size: 12px;
      color: var(--text-secondary);
      letter-spacing: 0.01em;
    }
    
    /* ===== AUDIT LOG ===== */
    .audit-log {
      border-radius: var(--radius-sm);
      overflow: hidden;
      background: var(--bg);
    }
    .audit-entry {
      display: flex;
      gap: 16px;
      padding: 16px 20px;
      font-size: 14px;
      border-bottom: 1px solid var(--border-subtle);
    }
    .audit-entry:last-child { border-bottom: none; }
    .audit-time {
      font-family: var(--mono);
      color: var(--text-tertiary);
      flex-shrink: 0;
      width: 80px;
      font-size: 12px;
    }
    .audit-action {
      flex: 1;
      color: var(--text);
    }
    .audit-hash {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text-tertiary);
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* ===== VERIFICATION ===== */
    .verify-section {
      margin-top: 32px;
      padding: 28px;
      background: var(--bg);
      border-radius: var(--radius-sm);
    }
    .verify-section h4 {
      font-size: 15px;
      margin-bottom: 20px;
      font-weight: 600;
      color: var(--text);
    }
    .verify-grid {
      display: grid;
      gap: 12px;
    }
    .verify-item {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
    }
    .verify-icon { display: none; }
    .verify-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .verify-dot.pass { background: var(--success); }
    .verify-dot.fail { background: var(--error); }
    .verify-dot.warn { background: var(--warning); }
    .verify-dot.pending { background: var(--text-tertiary); }
    .verify-label { color: var(--text-secondary); }
    .verify-value {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text);
    }
    
    /* ===== TRUST CHAIN ===== */
    .trust-chain {
      background: var(--bg);
      border-radius: var(--radius-sm);
      padding: 28px;
      margin-bottom: 32px;
      overflow-x: auto;
    }
    .trust-chain-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 20px;
      color: var(--text-secondary);
      letter-spacing: 0.02em;
    }
    .trust-chain-flow {
      display: flex;
      align-items: center;
      gap: 0;
      font-family: var(--mono);
      font-size: 11px;
      min-width: 680px;
    }
    .trust-chain-node {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 16px 18px;
      background: var(--surface);
      border-radius: var(--radius-sm);
      min-width: 110px;
      text-align: center;
      box-shadow: var(--shadow);
    }
    .trust-chain-node .tc-icon { display: none; }
    .trust-chain-node .tc-label {
      font-weight: 600;
      color: var(--text);
      font-size: 11px;
      letter-spacing: 0.02em;
    }
    .trust-chain-node .tc-detail {
      color: var(--text-secondary);
      font-size: 10px;
      word-break: break-all;
    }
    .trust-chain-arrow {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      padding: 0 12px;
      color: var(--text-tertiary);
      flex-shrink: 0;
    }
    .trust-chain-arrow .tc-arrow-line {
      font-size: 16px;
      color: var(--text-tertiary);
    }
    .trust-chain-arrow .tc-arrow-label {
      font-size: 9px;
      color: var(--text-tertiary);
      letter-spacing: 0.02em;
    }

    /* ===== CONSOLE ===== */
    .console-toggle {
      position: fixed;
      bottom: 24px;
      right: 24px;
      padding: 14px 22px;
      background: var(--surface);
      border: none;
      border-radius: 980px;
      color: var(--text);
      cursor: pointer;
      font-family: var(--font);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 50;
      box-shadow: var(--shadow-md);
      transition: all 0.2s ease-out;
    }
    .console-toggle:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.1);
    }
    
    .console-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 320px;
      background: var(--surface);
      border-top: 1px solid var(--border);
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
      z-index: 100;
      display: flex;
      flex-direction: column;
    }
    .console-panel.open { transform: translateY(0); }
    
    .console-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
    }
    .console-header h4 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
    }
    .console-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 20px;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .console-close:hover { color: var(--text); }
    
    .console-body {
      flex: 1;
      overflow: auto;
      padding: 20px 24px;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.9;
      background: var(--bg);
    }
    .console-line { margin-bottom: 4px; }
    .console-line.info { color: var(--text-secondary); }
    .console-line.success { color: var(--success); }
    .console-line.error { color: var(--error); }
    .console-line.crypto { color: #af52de; }
    .console-line.ddc { color: var(--blue); }
    .console-line.warn { color: var(--warning); }
    .console-time {
      color: var(--text-tertiary);
      margin-right: 10px;
    }
    
    /* ===== REVOCATION ===== */
    .revoke-btn {
      background: transparent;
      color: var(--error);
      border: 1px solid var(--error);
      padding: 10px 20px;
      border-radius: 980px;
      font-family: var(--font);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      margin-top: 16px;
      display: none;
      align-items: center;
      gap: 6px;
      transition: all 0.2s ease-out;
    }
    .revoke-btn:hover {
      background: rgba(255,59,48,0.08);
    }
    .revoke-btn.revoked {
      background: rgba(255,59,48,0.08);
      cursor: default;
      opacity: 0.6;
    }
    .revocation-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 12px;
      border-radius: 980px;
      font-size: 12px;
      font-weight: 600;
      font-family: var(--mono);
    }
    .revocation-status.active {
      background: rgba(52,199,89,0.12);
      color: var(--success);
    }
    .revocation-status.revoked {
      background: rgba(255,59,48,0.12);
      color: var(--error);
    }

    /* ===== PUBLIC VERIFIER ===== */
    .verifier-section {
      max-width: 980px;
      margin: 60px auto 80px;
      padding: 0 22px;
    }
    .verifier-card {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 40px;
      box-shadow: var(--shadow);
    }
    .verifier-card h2 {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }
    .verifier-card p {
      color: var(--text-secondary);
      font-size: 15px;
      margin-bottom: 28px;
    }
    .verifier-input-group {
      display: flex;
      gap: 12px;
      margin-bottom: 28px;
    }
    .verifier-input {
      flex: 1;
      padding: 14px 18px;
      background: var(--bg);
      border: none;
      border-radius: var(--radius-sm);
      color: var(--text);
      font-family: var(--mono);
      font-size: 14px;
    }
    .verifier-input:focus {
      outline: none;
      box-shadow: 0 0 0 4px rgba(0,122,255,0.15);
    }
    .verifier-result {
      display: none;
      padding: 24px;
      background: var(--bg);
      border-radius: var(--radius-sm);
    }
    .verifier-result.visible { display: block; }
    .verifier-result .vr-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .verifier-result .vr-status {
      font-size: 16px;
      font-weight: 600;
    }
    .verifier-result .vr-status.verified { color: var(--success); }
    .verifier-result .vr-status.not-found { color: var(--error); }
    .verifier-detail {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-subtle);
      font-size: 14px;
    }
    .verifier-detail:last-child { border: none; }
    .verifier-detail .vd-label { color: var(--text-secondary); }
    .verifier-detail .vd-value { font-family: var(--mono); font-size: 12px; }
    .data-classes {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .data-class-tag {
      padding: 5px 12px;
      border-radius: 980px;
      font-size: 11px;
      font-weight: 600;
      font-family: var(--mono);
      background: rgba(0,122,255,0.1);
      color: var(--blue);
    }

    /* ===== SOVEREIGNTY SEAL ===== */
    .sovereignty-seal {
      margin-top: 40px;
      padding: 40px;
      background: var(--surface);
      border-radius: var(--radius);
      text-align: center;
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow);
      opacity: 0;
      transform: translateY(10px);
      animation: sealReveal 0.6s ease-out 0.2s forwards;
    }
    @keyframes sealReveal {
      to { opacity: 1; transform: translateY(0); }
    }
    .seal-content {
      position: relative;
      z-index: 1;
    }
    .seal-shield {
      width: 64px;
      height: 64px;
      margin: 0 auto 20px;
      background: var(--accent);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
    }
    .seal-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 6px;
      letter-spacing: -0.02em;
      color: var(--text);
    }
    .seal-subtitle {
      font-size: 15px;
      color: var(--text-secondary);
      margin-bottom: 28px;
    }
    .seal-facts {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      max-width: 500px;
      margin: 0 auto 24px;
    }
    .seal-fact .sf-value {
      font-family: var(--mono);
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
    }
    .seal-fact .sf-label {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-top: 4px;
      letter-spacing: 0.02em;
    }
    .seal-hash {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text-tertiary);
      word-break: break-all;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      main { padding: 40px 16px 80px; }
      .hero { margin-bottom: 60px; }
      .hero h1 { font-size: 36px; }
      .hero p { font-size: 17px; }
      .step-header { padding: 20px; }
      .step-body { padding: 0 20px 20px; }
      .btn-group { flex-direction: column; }
      .btn { width: 100%; }
      .analysis-grid { grid-template-columns: repeat(2, 1fr); }
      .progress-node-label { display: none; }
      .progress-node { width: 28px; height: 28px; font-size: 12px; }
      .progress-bar { padding: 16px 16px 24px; }
      .seal-facts { grid-template-columns: repeat(2, 1fr); }
      .verifier-input-group { flex-direction: column; }
      .verifier-card { padding: 28px; }
    }
    @media (max-width: 480px) {
      .hero h1 { font-size: 32px; }
      .btn { min-height: 50px; }
    }
    html, body { overflow-x: hidden; }
  </style>
</head>
<body>
<a class="skip-to-content" href="#main-content">Skip to content</a>

  <!-- DDC Status Banner -->
  <div class="ddc-banner" id="ddcBanner">
    <span class="status-dot"></span>
    <span id="ddcStatus">Connecting to Cere DDC Mainnet...</span>
  </div>

  <!-- Nav -->
  <nav role="navigation" aria-label="Main navigation">
    <div class="nav-inner">
      <div class="nav-left">
        <a href="/" class="nav-logo">Proofi</a>
        <span class="nav-badge" id="modeBadge">DDC Mainnet</span>
      </div>
      <div class="wallet-status" id="walletStatus">
        <span class="wallet-dot" id="walletDot"></span>
        <span class="wallet-addr" id="walletAddr">Not connected</span>
      </div>
    </div>
  </nav>

  <!-- Progress Bar -->
  <div class="progress-bar">
    <div class="progress-bar-inner" id="progressBar">
      <div class="progress-line" id="progressLine"></div>
      <div class="progress-node active" data-step="1" onclick="scrollToStep(1)">
        1
        <span class="progress-node-label">Identity</span>
      </div>
      <div class="progress-node" data-step="2" onclick="scrollToStep(2)">
        2
        <span class="progress-node-label">Encrypt</span>
      </div>
      <div class="progress-node" data-step="3" onclick="scrollToStep(3)">
        3
        <span class="progress-node-label">Permission</span>
      </div>
      <div class="progress-node" data-step="4" onclick="scrollToStep(4)">
        4
        <span class="progress-node-label">Analysis</span>
      </div>
      <div class="progress-node" data-step="5" onclick="scrollToStep(5)">
        5
        <span class="progress-node-label">Results</span>
      </div>
    </div>
  </div>

  <!-- Main -->
  <main id="main-content">
    <section class="hero">
      <h1>Analyze your health data privately.</h1>
      <p>See how an AI agent can read your data without anyone else seeing it. Everything is encrypted, stored decentrally, and verifiable.</p>
    </section>

    <div class="steps">
      <!-- Step 1: Wallet Connection -->
      <div class="step active" id="step1">
        <div class="step-header" onclick="toggleStep(1)">
          <div class="step-num"><span>1</span></div>
          <div class="step-info">
            <div class="step-title">Create Your Identity</div>
            <div class="step-desc">Generate a cryptographic wallet — this is your digital signature</div>
          </div>
          <span class="step-status">Pending</span>
        </div>
        <div class="step-body">
          <div class="form-group">
            <label class="form-label">Seed phrase (leave empty to create a new wallet)</label>
            <input aria-label="word1 word2 word3 ... word12" type="text" class="form-input" id="seedInput" placeholder="word1 word2 word3 ... word12">
          </div>
          <div class="btn-group">
            <button aria-label="Generate wallet" class="btn btn-primary" onclick="connectWallet()">Create New Wallet</button>
            <button aria-label="Import wallet" class="btn btn-secondary" onclick="connectWallet(true)">Import Existing</button>
          </div>
          
          <div id="walletResult" style="margin-top: 24px; display: none;">
            <div class="kv-grid">
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Public Key (Ed25519)</div>
                  <div class="kv-value" id="userPubKey">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Decentralized Identifier (DID)</div>
                  <div class="kv-value" id="userDID">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Encryption Key (X25519)</div>
                  <div class="kv-value" id="userX25519">—</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 2: Upload Health Data -->
      <div class="step" id="step2">
        <div class="step-header" onclick="toggleStep(2)">
          <div class="step-num"><span>2</span></div>
          <div class="step-info">
            <div class="step-title">Encrypt and Store Your Data</div>
            <div class="step-desc">Your health data gets encrypted on your device, then stored securely</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <p style="font-size: 15px; color: var(--text-secondary); margin-bottom: 24px; line-height: 1.6;">
            Your health data will be encrypted with AES-256-GCM using a Data Encryption Key (DEK) that only you control.
            The encrypted data is stored on the Cere DDC network.
          </p>
          
          <div class="data-label">
            <span>Sample Health Data (30 days of sleep + 100 heart rate readings)</span>
          </div>
          <div class="data-box" style="max-height: 140px;">
            <pre id="sampleDataPreview">Loading...</pre>
          </div>
          
          <div class="btn-group">
            <button aria-label="Encrypt and upload data" class="btn btn-primary" id="uploadBtn" onclick="uploadHealthData()" disabled>
              Encrypt and Upload to DDC
            </button>
          </div>
          
          <div id="uploadResult" style="margin-top: 24px; display: none;">
            <div class="kv-grid">
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Storage Mode</div>
                  <div class="kv-value ddc" id="storageMode">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">DDC Bucket ID</div>
                  <div class="kv-value success" id="bucketId">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Content ID (CID)</div>
                  <div class="kv-value success" id="dataCid">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">DDC CDN URL</div>
                  <div class="kv-value" id="ddcUrl" style="font-size: 11px;">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Data Encryption Key (DEK)</div>
                  <div class="kv-value" id="dekDisplay">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Encryption Details</div>
                  <div class="kv-value" id="encDetails">—</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 3: Grant Agent Permission -->
      <div class="step" id="step3">
        <div class="step-header" onclick="toggleStep(3)">
          <div class="step-num"><span>3</span></div>
          <div class="step-info">
            <div class="step-title">Choose What to Share</div>
            <div class="step-desc">Grant the AI agent read-only access to specific data — revoke anytime</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <div class="kv-grid" style="margin-bottom: 24px;">
            <div class="kv-item">
              <div class="kv-content">
                <div class="kv-key">Agent Identity</div>
                <div class="kv-value">Health Analyzer Agent v1.0</div>
              </div>
            </div>
            <div class="kv-item">
              <div class="kv-content">
                <div class="kv-key">Agent Encryption Key (X25519)</div>
                <div class="kv-value" id="agentPubKey">—</div>
              </div>
            </div>
          </div>
          
          <h4 style="font-size: 14px; margin-bottom: 14px; font-weight: 600; color: var(--text);">Select Scopes to Grant</h4>
          <div class="scope-grid" id="scopeGrid">
            <div class="scope-item selected" data-path="health/sleep" data-perms="read">
              <div class="scope-check">✓</div>
              <div class="scope-info">
                <div class="scope-path">health/sleep/*</div>
                <div class="scope-perms">read — Sleep duration, quality, REM cycles</div>
              </div>
            </div>
            <div class="scope-item selected" data-path="health/heart" data-perms="read">
              <div class="scope-check">✓</div>
              <div class="scope-info">
                <div class="scope-path">health/heart/*</div>
                <div class="scope-perms">read — Heart rate, HRV, activity context</div>
              </div>
            </div>
            <div class="scope-item" data-path="health/insights" data-perms="read,write">
              <div class="scope-check">✓</div>
              <div class="scope-info">
                <div class="scope-path">health/insights/*</div>
                <div class="scope-perms">read, write — Store analysis results</div>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">Token Expiry</label>
            <select class="form-input" id="tokenExpiry" style="cursor: pointer;">
              <option value="3600">1 hour</option>
              <option value="86400" selected>24 hours</option>
              <option value="604800">7 days</option>
            </select>
          </div>
          
          <button aria-label="Grant access" class="btn btn-primary" id="grantBtn" onclick="grantPermission()" disabled>
            Grant Access
          </button>
          
          <div id="tokenResult" style="margin-top: 24px; display: none;">
            <div class="data-label">
              <span>Capability Token (signed with Ed25519)</span>
              <div style="display: flex; gap: 8px;">
                <button class="copy-btn" onclick="copyToken()">Copy</button>
                <button class="copy-btn" onclick="exportForCLI()">Export for CLI</button>
              </div>
            </div>
            <div class="data-box scrollable">
              <pre id="tokenDisplay">—</pre>
            </div>
            
            <div class="kv-grid">
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Token ID</div>
                  <div class="kv-value" id="tokenId">—</div>
                </div>
              </div>
              <div class="kv-item">
                <div class="kv-content">
                  <div class="kv-key">Wrapped DEK (encrypted for agent)</div>
                  <div class="kv-value" id="wrappedDek">—</div>
                </div>
              </div>
            </div>
            <button class="revoke-btn" id="revokeBtn" onclick="revokeToken()">
              Revoke Token
            </button>
            <div id="revocationStatus" style="margin-top: 10px;"></div>
          </div>
        </div>
      </div>

      <!-- Step 4: Agent Execution -->
      <div class="step" id="step4">
        <div class="step-header" onclick="toggleStep(4)">
          <div class="step-num"><span>4</span></div>
          <div class="step-info">
            <div class="step-title">AI Analyzes Privately</div>
            <div class="step-desc">The agent reads your encrypted data, analyzes it, and returns results</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <div id="agentLoading" class="loading">
            <div class="spinner"></div>
            <span>Agent processing...</span>
          </div>
          
          <div id="agentSteps" style="display: none;">
            <div class="kv-grid" style="margin-bottom: 28px;">
              <div class="kv-item" id="agentStep1">
                <div class="kv-content">
                  <div class="kv-key">1. Verify your permission is authentic</div>
                  <div class="kv-value pending">Waiting...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep2">
                <div class="kv-content">
                  <div class="kv-key">2. Check permission is still valid</div>
                  <div class="kv-value pending">Waiting...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep3">
                <div class="kv-content">
                  <div class="kv-key">3. Unlock the encryption key</div>
                  <div class="kv-value pending">Waiting...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep4">
                <div class="kv-content">
                  <div class="kv-key">4. Download and decrypt your data</div>
                  <div class="kv-value pending">Waiting...</div>
                </div>
              </div>
              <div class="kv-item" id="agentStep5">
                <div class="kv-content">
                  <div class="kv-key">5. Analyze and generate insights</div>
                  <div class="kv-value pending">Waiting...</div>
                </div>
              </div>
            </div>
          </div>
          
          <button aria-label="Run analysis" class="btn btn-primary" id="runAgentBtn" onclick="runAgent()" disabled>
            Run Analysis
          </button>
        </div>
      </div>

      <!-- Step 5: Results & Verification -->
      <div class="step" id="step5">
        <div class="step-header" onclick="toggleStep(5)">
          <div class="step-num"><span>5</span></div>
          <div class="step-info">
            <div class="step-title">Your Results</div>
            <div class="step-desc">Health insights plus a complete audit trail proving everything was done right</div>
          </div>
          <span class="step-status">Locked</span>
        </div>
        <div class="step-body">
          <h4 style="font-size: 16px; margin-bottom: 20px; font-weight: 600;">Health Analysis Results</h4>
          
          <div class="analysis-grid" id="analysisResults">
            <!-- Filled by JS -->
          </div>
          
          <div class="data-label">
            <span>AI Recommendations</span>
          </div>
          <div class="data-box" id="recommendations">
            <pre>Loading...</pre>
          </div>
          
          <h4 style="font-size: 16px; margin: 32px 0 20px; font-weight: 600;">Audit Trail</h4>
          <div class="audit-log" id="auditLog">
            <!-- Filled by JS -->
          </div>
          
          <div class="verify-section">
            <h4>Verification Details</h4>
            <div class="verify-grid" id="verifyGrid">
              <!-- Filled by JS -->
            </div>
          </div>
          
          <div class="btn-group" style="margin-top: 32px;">
            <button aria-label="Download audit log" class="btn btn-primary" onclick="downloadAuditLog()">Download Audit Log</button>
            <button aria-label="Restart" class="btn btn-secondary" onclick="restartDemo()">Start Over</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Public CID Verifier -->
  <section class="verifier-section" id="publicVerifier">
    <div class="verifier-card">
      <h2>Public CID Verifier</h2>
      <p>Verify any content stored on Cere DDC. Paste a Content ID to check its existence, fetch metadata, and classify data types.</p>
      <div class="verifier-input-group">
        <input type="text" class="verifier-input" id="verifyCidInput" placeholder="Enter CID (e.g., bafk2bzace...)">
        <input type="number" class="verifier-input" id="verifyBucketInput" placeholder="Bucket" value="1229" style="max-width: 120px;">
        <button class="btn btn-primary" onclick="publicVerify()">Verify</button>
      </div>
      <div class="verifier-result" id="verifierResult"></div>
    </div>
  </section>

  <!-- Console Toggle -->
  <button class="console-toggle" onclick="toggleConsole()">
    <span>Execution Log</span>
  </button>

  <!-- Console Panel -->
  <div class="console-panel" id="consolePanel">
    <div class="console-header">
      <h4>Execution Log</h4>
      <button aria-label="Close" class="console-close" onclick="toggleConsole()">×</button>
    </div>
    <div class="console-body" id="consoleBody">
      <div class="console-line info">
        <span class="console-time">[init]</span>
        Proofi Health Demo initializing with DIRECT DDC SDK integration...
      </div>
    </div>
  </div>

  <!-- ProofiSDK for wallet signing via iframe -->
  <script src="/proofi-sdk.js"></script>

  <!-- TweetNaCl for real crypto -->
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>
  
  <!-- Cere DDC SDK for direct uploads -->
  <script type="module">
    import { DdcClient, File as DdcFile, UriSigner, MAINNET } from 'https://unpkg.com/@cere-ddc-sdk/ddc-client@2.16.1/dist/browser.js';
    window.DdcClient = DdcClient;
    window.DdcFile = DdcFile;
    window.UriSigner = UriSigner;
    window.MAINNET = MAINNET;
  </script>
  
  <!-- Polkadot.js extension for wallet integration -->
  <script src="https://cdn.jsdelivr.net/npm/@polkadot/extension-dapp@0.46.5/bundle-polkadot-extension-dapp.min.js"></script>
  
  <script>
    // ========================================
    // DIRECT DDC E2E HEALTH DEMO
    // Using Cere DDC SDK - NO API PROXY
    // Uploads directly to DDC Mainnet
    // ========================================
    
    // DDC Configuration - MAINNET (Direct SDK)
    const DDC_CONFIG = {
      // Mainnet CDN endpoint for reading
      cdnUrl: 'https://cdn.cere.network',
      // Alternative CDN
      cdnUrlAlt: 'https://cdn.ddc-dragon.com',
      // Network identifier
      network: 'mainnet',
      // Default bucket (Proofi's public bucket)
      defaultBucket: 1229n
    };

    // Global State
    const state = {
      userKeyPair: null,        // Ed25519 signing keypair
      userX25519: null,         // X25519 encryption keypair
      agentKeyPair: null,       // Agent's X25519 keypair
      agentSigningKeyPair: null, // Agent's Ed25519 keypair
      dek: null,                // Data Encryption Key (AES-256)
      healthData: null,         // Raw health data
      encryptedData: null,      // Encrypted health data
      bucketId: null,           // DDC bucket ID
      dataCid: null,            // Content ID
      capabilityToken: null,    // The actual token
      auditLog: [],             // Audit trail with hashes
      lastHash: null,           // For hash chain
      ddcConnected: false,      // DDC connection status
      ddcClient: null,          // DDC SDK client instance
      tokenRevoked: false,      // Whether current token has been revoked
      revocationCid: null,      // CID of revocation record on DDC
      extensionConnected: false, // Polkadot.js extension status
      walletAddress: null,      // Real Cere SS58 address from extension
      walletSigner: null,       // Signer from extension
      walletMnemonic: null      // Mnemonic for DDC SDK (if using demo mode)
    };
    
    // Generate 30 days of sleep data + 100 heart rate readings
    const SAMPLE_HEALTH_DATA = generateSampleHealthData();
    
    function generateSampleHealthData() {
      const sleep = [];
      const heartRate = [];
      const startDate = new Date('2024-02-01');
      
      // 30 days of sleep
      for (let i = 0; i < 30; i++) {
        const date = new Date(startDate);
        date.setDate(date.getDate() + i);
        sleep.push({
          date: date.toISOString().split('T')[0],
          duration: 6 + Math.random() * 3,
          quality: 60 + Math.floor(Math.random() * 35),
          deep: 0.5 + Math.random() * 2,
          rem: 1 + Math.random() * 1.5,
          light: 3 + Math.random() * 2,
          awakenings: Math.floor(Math.random() * 5)
        });
      }
      
      // 100 heart rate readings
      for (let i = 0; i < 100; i++) {
        const date = new Date(startDate);
        date.setHours(date.getHours() + i * 7);
        const contexts = ['resting', 'walking', 'exercise', 'sleeping', 'stressed'];
        const context = contexts[Math.floor(Math.random() * contexts.length)];
        let bpm;
        switch(context) {
          case 'resting': bpm = 60 + Math.floor(Math.random() * 20); break;
          case 'walking': bpm = 80 + Math.floor(Math.random() * 30); break;
          case 'exercise': bpm = 120 + Math.floor(Math.random() * 60); break;
          case 'sleeping': bpm = 50 + Math.floor(Math.random() * 15); break;
          case 'stressed': bpm = 90 + Math.floor(Math.random() * 25); break;
        }
        heartRate.push({
          timestamp: date.toISOString(),
          bpm,
          context,
          variability: 20 + Math.floor(Math.random() * 40)
        });
      }
      
      return { sleep, heartRate, version: '1.0', exportedAt: new Date().toISOString() };
    }
    
    // ========================================
    // CONSOLE LOGGING
    // ========================================
    
    function log(message, type = 'info') {
      const time = new Date().toLocaleTimeString('en-US', { hour12: false });
      const consoleBody = document.getElementById('consoleBody');
      const line = document.createElement('div');
      line.className = `console-line ${type}`;
      line.innerHTML = `<span class="console-time">[${time}]</span>${escapeHtml(message)}`;
      consoleBody.appendChild(line);
      consoleBody.scrollTop = consoleBody.scrollHeight;
      console.log(`[${type.toUpperCase()}] ${message}`);
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function toggleConsole() {
      document.getElementById('consolePanel').classList.toggle('open');
    }
    
    // ========================================
    // DDC SDK INITIALIZATION
    // ========================================
    
    async function initDDCClient(mnemonic) {
      if (!window.CereDdcSdk) {
        throw new Error('DDC SDK not loaded');
      }
      
      const { DdcClient, UriSigner, MAINNET } = window.CereDdcSdk;
      
      log('Creating DDC client with wallet signer...', 'ddc');
      
      // Create signer from mnemonic
      const signer = new UriSigner(mnemonic);
      
      // Create DDC client connected to mainnet
      const client = await DdcClient.create(signer, MAINNET);
      
      log('DDC client created successfully', 'success');
      return client;
    }
    
    async function checkDDCConnection() {
      const banner = document.getElementById('ddcBanner');
      const statusEl = document.getElementById('ddcStatus');
      const modeBadge = document.getElementById('modeBadge');

      log('Checking DDC SDK availability...', 'ddc');

      try {
        // Check if DDC SDK is loaded
        if (window.CereDdcSdk) {
          state.ddcConnected = true;
          banner.className = 'ddc-banner';
          statusEl.textContent = 'DDC SDK loaded — Ready for direct uploads to Mainnet';
          modeBadge.textContent = 'DDC Direct';
          modeBadge.className = 'nav-badge';
          log('DDC SDK loaded: ' + Object.keys(window.CereDdcSdk).join(', '), 'success');
          return;
        }

        // SDK not loaded yet, wait a bit
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        if (window.CereDdcSdk) {
          state.ddcConnected = true;
          banner.className = 'ddc-banner';
          statusEl.textContent = 'DDC SDK loaded — Ready for direct uploads to Mainnet';
          modeBadge.textContent = 'DDC Direct';
          modeBadge.className = 'nav-badge';
          log('DDC SDK loaded after wait', 'success');
          return;
        }

        throw new Error('DDC SDK not available');

      } catch (err) {
        log('DDC SDK check failed: ' + err.message, 'warn');
        
        // Try CDN connectivity as fallback indicator
        try {
          const cdnResponse = await fetch(`${DDC_CONFIG.cdnUrlAlt}/1229/`, { method: 'HEAD' });
          if (cdnResponse.ok || cdnResponse.status === 404) {
            state.ddcConnected = true;
            banner.className = 'ddc-banner offline';
            statusEl.textContent = 'DDC CDN reachable — SDK loading...';
            modeBadge.textContent = 'DDC Connecting';
            modeBadge.className = 'nav-badge offline';
            log('DDC CDN reachable, SDK may still load', 'warn');
            return;
          }
        } catch (cdnErr) {
          log('DDC CDN unreachable: ' + cdnErr.message, 'error');
        }
      }

      // DDC not available
      state.ddcConnected = false;
      banner.className = 'ddc-banner error';
      statusEl.textContent = 'DDC SDK not loaded — Check your connection';
      modeBadge.textContent = 'DDC Offline';
      modeBadge.className = 'nav-badge offline';
      log('DDC SDK not available. Direct uploads will fail.', 'error');
    }
    
    // ========================================
    // CRYPTO UTILITIES (REAL)
    // ========================================
    
    // Generate random bytes
    function randomBytes(n) {
      return nacl.randomBytes(n);
    }
    
    // SHA-256 hash
    async function sha256(data) {
      const buffer = typeof data === 'string' ? new TextEncoder().encode(data) : data;
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
      return new Uint8Array(hashBuffer);
    }
    
    // SHA-256 hash as base64
    async function sha256Base64(data) {
      const hash = await sha256(data);
      return nacl.util.encodeBase64(hash);
    }
    
    // Generate Ed25519 signing keypair from seed
    function generateSigningKeyPair(seed = null) {
      if (!seed) {
        seed = randomBytes(32);
      }
      const keyPair = nacl.sign.keyPair.fromSeed(seed);
      return {
        publicKey: keyPair.publicKey,
        privateKey: keyPair.secretKey,
        seed
      };
    }
    
    // Generate X25519 box keypair
    function generateBoxKeyPair() {
      return nacl.box.keyPair();
    }
    
    // Derive DID from public key
    function deriveDID(publicKey) {
      const b64 = nacl.util.encodeBase64(publicKey);
      return `did:key:z${b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')}`;
    }
    
    // Generate CID (Content Identifier) - IPFS/DDC compatible format
    async function generateCID(data) {
      const jsonStr = typeof data === 'string' ? data : JSON.stringify(data);
      const hash = await sha256(jsonStr);
      
      const base32Chars = 'abcdefghijklmnopqrstuvwxyz234567';
      let result = '';
      
      let bits = 0;
      let value = 0;
      for (let i = 0; i < hash.length; i++) {
        value = (value << 8) | hash[i];
        bits += 8;
        while (bits >= 5) {
          bits -= 5;
          result += base32Chars[(value >> bits) & 31];
        }
      }
      if (bits > 0) {
        result += base32Chars[(value << (5 - bits)) & 31];
      }
      
      return 'bafyb' + result.slice(0, 54);
    }
    
    // AES-256-GCM encryption
    async function encryptAES(plaintext, key) {
      const iv = randomBytes(12);
      const encodedText = typeof plaintext === 'string' 
        ? new TextEncoder().encode(plaintext) 
        : plaintext;
      
      const cryptoKey = await crypto.subtle.importKey(
        'raw', key, { name: 'AES-GCM' }, false, ['encrypt']
      );
      
      const ciphertext = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv, tagLength: 128 },
        cryptoKey,
        encodedText
      );
      
      return {
        ciphertext: nacl.util.encodeBase64(new Uint8Array(ciphertext)),
        iv: nacl.util.encodeBase64(iv),
        algorithm: 'AES-256-GCM'
      };
    }
    
    // AES-256-GCM decryption
    async function decryptAES(ciphertextB64, ivB64, key) {
      const ciphertext = nacl.util.decodeBase64(ciphertextB64);
      const iv = nacl.util.decodeBase64(ivB64);
      
      const cryptoKey = await crypto.subtle.importKey(
        'raw', key, { name: 'AES-GCM' }, false, ['decrypt']
      );
      
      const plaintext = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv, tagLength: 128 },
        cryptoKey,
        ciphertext
      );
      
      return new TextDecoder().decode(plaintext);
    }
    
    // Wrap DEK for recipient (X25519 + XSalsa20-Poly1305)
    function wrapDEK(dek, recipientPublicKey) {
      const ephemeral = nacl.box.keyPair();
      const nonce = randomBytes(24);
      
      const encrypted = nacl.box(dek, nonce, recipientPublicKey, ephemeral.secretKey);
      
      return {
        ciphertext: nacl.util.encodeBase64(encrypted),
        ephemeralPublicKey: nacl.util.encodeBase64(ephemeral.publicKey),
        nonce: nacl.util.encodeBase64(nonce)
      };
    }
    
    // Unwrap DEK (X25519 + XSalsa20-Poly1305)
    function unwrapDEK(wrappedDEK, recipientPrivateKey) {
      const ciphertext = nacl.util.decodeBase64(wrappedDEK.ciphertext);
      const ephemeralPubKey = nacl.util.decodeBase64(wrappedDEK.ephemeralPublicKey);
      const nonce = nacl.util.decodeBase64(wrappedDEK.nonce);
      
      const dek = nacl.box.open(ciphertext, nonce, ephemeralPubKey, recipientPrivateKey);
      
      if (!dek) {
        throw new Error('DEK unwrapping failed - decryption error');
      }
      
      return dek;
    }
    
    // Sign message with Ed25519
    function signMessage(message, privateKey) {
      const messageBytes = typeof message === 'string' 
        ? new TextEncoder().encode(message) 
        : message;
      const signature = nacl.sign.detached(messageBytes, privateKey);
      return nacl.util.encodeBase64(signature);
    }
    
    // Verify Ed25519 signature
    function verifySignature(message, signatureB64, publicKey) {
      const messageBytes = typeof message === 'string' 
        ? new TextEncoder().encode(message) 
        : message;
      const signature = nacl.util.decodeBase64(signatureB64);
      return nacl.sign.detached.verify(messageBytes, signature, publicKey);
    }
    
    // ========================================
    // DIRECT DDC STORAGE LAYER (NO API PROXY)
    // ========================================
    
    class DirectDDCStorage {
      constructor() {
        this.mode = 'ddc-direct';
      }
      
      async store(bucketId, data) {
        const cid = await generateCID(data);
        const jsonData = JSON.stringify(data);

        log(`DDC Direct: Preparing ${(jsonData.length / 1024).toFixed(2)}KB for upload...`, 'ddc');
        log(`DDC Direct: Predicted CID = ${cid}`, 'ddc');

        // Check if DDC SDK is available
        if (!window.CereDdcSdk) {
          throw new Error('DDC SDK not loaded. Cannot upload directly.');
        }

        // Check if we have a wallet mnemonic for signing
        if (!state.walletMnemonic) {
          throw new Error('Wallet not connected. Generate or import a wallet first.');
        }

        try {
          // Initialize DDC client if not already done
          if (!state.ddcClient) {
            state.ddcClient = await initDDCClient(state.walletMnemonic);
          }

          const { File: DdcFile } = window.CereDdcSdk;

          log('DDC Direct: Uploading to Cere DDC Mainnet bucket ' + bucketId + '...', 'ddc');
          
          // Create DDC file from JSON data
          const dataBuffer = new TextEncoder().encode(jsonData);
          const file = new DdcFile(dataBuffer, { contentType: 'application/json' });

          // Store to DDC - wallet will sign the transaction
          const uri = await state.ddcClient.store(bucketId, file);
          
          const realCid = uri.cid;
          const cdnUrl = `${DDC_CONFIG.cdnUrlAlt}/${bucketId}/${realCid}`;
          
          log(`DDC Direct: Upload successful! CID: ${realCid}`, 'success');
          log(`DDC Direct: CDN URL: ${cdnUrl}`, 'ddc');
          
          return {
            cid: realCid,
            bucket: bucketId.toString(),
            mode: 'ddc-direct',
            cdnUrl: cdnUrl,
            uri: uri.toString()
          };
          
        } catch (err) {
          log(`DDC Direct: Upload failed - ${err.message}`, 'error');
          
          // If the error is about bucket access, provide helpful message
          if (err.message.includes('bucket') || err.message.includes('permission')) {
            throw new Error(`DDC bucket ${bucketId} access denied. You may need to use your own bucket or fund the wallet.`);
          }
          
          throw err;
        }
      }
      
      async fetch(bucketId, cid) {
        log(`DDC Direct: Fetching CID ${cid.slice(0, 20)}... from bucket ${bucketId}`, 'ddc');

        // Try CDN first (no auth needed for public buckets)
        const cdnUrls = [
          `${DDC_CONFIG.cdnUrlAlt}/${bucketId}/${cid}`,
          `${DDC_CONFIG.cdnUrl}/${bucketId}/${cid}`
        ];

        for (const cdnUrl of cdnUrls) {
          try {
            log(`DDC Direct: Trying CDN: ${cdnUrl}`, 'ddc');
            const response = await fetch(cdnUrl);

            if (response.ok) {
              const text = await response.text();
              log('DDC Direct: Fetched from CDN!', 'success');
              let content = JSON.parse(text);
              // Unwrap memo envelope if present
              if (content.type === 'memo' && content.content) {
                content = typeof content.content === 'string' ? JSON.parse(content.content) : content.content;
              }
              return content;
            }
          } catch (err) {
            log(`DDC Direct: CDN fetch failed: ${err.message}`, 'warn');
          }
        }

        // Try DDC SDK client if available
        if (state.ddcClient) {
          try {
            log('DDC Direct: Trying SDK client...', 'ddc');
            const uri = `ddc://${bucketId}/${cid}`;
            const fileResponse = await state.ddcClient.read(uri);
            
            const chunks = [];
            for await (const chunk of fileResponse.body) {
              chunks.push(chunk);
            }
            const data = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));
            let offset = 0;
            for (const chunk of chunks) {
              data.set(chunk, offset);
              offset += chunk.length;
            }
            
            const text = new TextDecoder().decode(data);
            log('DDC Direct: Fetched via SDK!', 'success');
            let content = JSON.parse(text);
            if (content.type === 'memo' && content.content) {
              content = typeof content.content === 'string' ? JSON.parse(content.content) : content.content;
            }
            return content;
          } catch (err) {
            log(`DDC Direct: SDK fetch failed: ${err.message}`, 'warn');
          }
        }

        throw new Error(`DDC fetch failed for CID ${cid.slice(0, 20)}. Content not found.`);
      }
    }
    
    const ddcStorage = new DirectDDCStorage();
    
    // ========================================
    // AUDIT LOG
    // ========================================
    
    async function addAuditEntry(action, details = {}) {
      const entry = {
        timestamp: Date.now(),
        action,
        details,
        prevHash: state.lastHash || '0'.repeat(64)
      };
      
      const entryHash = await sha256Base64(JSON.stringify(entry));
      entry.hash = entryHash;
      state.lastHash = entryHash;
      state.auditLog.push(entry);
      
      log(`Audit: ${action} → hash: ${entryHash.slice(0, 16)}...`, 'info');
      return entry;
    }
    
    // ========================================
    // STEP HANDLERS
    // ========================================
    
    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      // Check DDC SDK availability
      await checkDDCConnection();
      
      // Generate agent keypair
      const agentSeed = nacl.util.decodeUTF8('proofi-health-agent-v1-demo00000');
      state.agentSigningKeyPair = generateSigningKeyPair(agentSeed);
      state.agentKeyPair = nacl.box.keyPair.fromSecretKey(agentSeed);
      
      document.getElementById('agentPubKey').textContent = 
        nacl.util.encodeBase64(state.agentKeyPair.publicKey);
      
      // Show sample data preview
      const preview = JSON.stringify(SAMPLE_HEALTH_DATA, null, 2);
      document.getElementById('sampleDataPreview').textContent = 
        preview.slice(0, 500) + '\n... (' + preview.length + ' bytes total)';
      
      // Setup scope toggles
      document.querySelectorAll('.scope-item').forEach(item => {
        item.addEventListener('click', () => {
          item.classList.toggle('selected');
        });
      });
      
      // Initialize ProofiSDK for wallet signing (optional, for extension integration)
      try {
        if (typeof ProofiSDK !== 'undefined') {
          state.proofiSDK = new ProofiSDK({
            walletUrl: 'https://proofi-virid.vercel.app/app',
            appName: 'Health Analyzer'
          });
          log('ProofiSDK initialized for wallet signing', 'success');
        }
      } catch (e) {
        log('ProofiSDK not available: ' + e.message, 'warn');
      }

      log('Demo initialized with DIRECT DDC SDK integration', 'success');
      log(`Agent public key: ${nacl.util.encodeBase64(state.agentKeyPair.publicKey).slice(0, 20)}...`, 'crypto');

      // Check for Polkadot.js extension
      if (window.injectedWeb3 && Object.keys(window.injectedWeb3).length > 0) {
        log('Polkadot.js extension detected', 'success');
      }
    });
    
    function toggleStep(stepNum) {
      const step = document.getElementById(`step${stepNum}`);
      if (step.classList.contains('completed') || step.classList.contains('active')) {
        step.classList.toggle('expanded');
      }
    }
    
    function scrollToStep(n) {
      document.getElementById(`step${n}`).scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function updateStep(stepNum, status) {
      const step = document.getElementById(`step${stepNum}`);
      const statusEl = step.querySelector('.step-status');

      step.classList.remove('active', 'completed');

      if (status === 'active') {
        step.classList.add('active');
        statusEl.textContent = 'In Progress';
        setTimeout(() => scrollToStep(stepNum), 300);
      } else if (status === 'completed') {
        step.classList.add('completed');
        statusEl.textContent = 'Complete';
      } else {
        statusEl.textContent = 'Locked';
      }

      updateProgressBar();
    }

    function updateProgressBar() {
      const nodes = document.querySelectorAll('.progress-node');
      let lastCompleted = 0;
      nodes.forEach(node => {
        const n = parseInt(node.dataset.step);
        const stepEl = document.getElementById(`step${n}`);
        node.classList.remove('active', 'completed');
        const label = node.querySelector('.progress-node-label');
        if (stepEl.classList.contains('completed')) {
          node.classList.add('completed');
          node.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>';
          node.appendChild(label);
          lastCompleted = n;
        } else if (stepEl.classList.contains('active')) {
          node.classList.add('active');
        }
      });
      const pct = (lastCompleted / 4) * 100;
      document.getElementById('progressLine').style.width = `calc(${pct}% - ${pct > 0 ? 24 : 0}px)`;
    }
    
    // Generate a simple mnemonic from seed (for demo purposes)
    function generateMnemonic(seed) {
      // Simple word list (BIP39 subset for demo)
      const words = [
        'abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract',
        'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid',
        'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual',
        'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance',
        'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent',
        'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album'
      ];
      
      const mnemonic = [];
      for (let i = 0; i < 12; i++) {
        const index = seed[i % seed.length] % words.length;
        mnemonic.push(words[index]);
      }
      return mnemonic.join(' ');
    }
    
    // Step 1: Connect Wallet
    async function connectWallet(useExisting = false) {
      log('Setting up wallet for DDC access...', 'crypto');

      let seed;
      const seedInput = document.getElementById('seedInput').value.trim();

      if (useExisting && seedInput) {
        // Use provided seed phrase as mnemonic
        state.walletMnemonic = seedInput;
        seed = await sha256(seedInput);
        seed = seed.slice(0, 32);
        log('Using imported seed phrase for DDC signing', 'crypto');
      } else {
        // Generate new seed and mnemonic
        seed = randomBytes(32);
        state.walletMnemonic = generateMnemonic(seed);
        log('Generated new mnemonic for DDC signing', 'crypto');
      }

      // Generate signing keypair (Ed25519)
      state.userKeyPair = generateSigningKeyPair(seed);
      log('Ed25519 keypair generated', 'crypto');

      // Generate encryption keypair (X25519)
      state.userX25519 = nacl.box.keyPair.fromSecretKey(seed);
      log('X25519 keypair generated', 'crypto');

      // Derive DID
      const did = deriveDID(state.userKeyPair.publicKey);

      // Update UI
      const pubKeyB64 = nacl.util.encodeBase64(state.userKeyPair.publicKey);
      const x25519B64 = nacl.util.encodeBase64(state.userX25519.publicKey);

      document.getElementById('userPubKey').textContent = pubKeyB64;
      document.getElementById('userDID').textContent = did;
      document.getElementById('userX25519').textContent = x25519B64;
      document.getElementById('walletResult').style.display = 'block';

      // Update wallet UI
      document.getElementById('walletDot').classList.add('connected');
      document.getElementById('walletAddr').textContent =
        pubKeyB64.slice(0, 8) + '...' + pubKeyB64.slice(-6);

      // Add mnemonic display for demo purposes
      const walletResultEl = document.getElementById('walletResult');
      const kvGrid = walletResultEl.querySelector('.kv-grid');

      const mnemonicItem = document.createElement('div');
      mnemonicItem.className = 'kv-item';
      mnemonicItem.innerHTML = `
        <div class="kv-content">
          <div class="kv-key">DDC Signer Mnemonic (for demo - keep secret!)</div>
          <div class="kv-value pending" style="font-size: 11px;">${state.walletMnemonic.split(' ').slice(0, 4).join(' ')}... (12 words)</div>
        </div>
      `;
      kvGrid.appendChild(mnemonicItem);

      const modeItem = document.createElement('div');
      modeItem.className = 'kv-item';
      modeItem.innerHTML = `
        <div class="kv-content">
          <div class="kv-key">Storage Mode</div>
          <div class="kv-value success">Direct DDC SDK (no API proxy)</div>
        </div>
      `;
      kvGrid.insertBefore(modeItem, kvGrid.firstChild);

      // Audit
      await addAuditEntry('WALLET_CONNECTED', {
        publicKey: pubKeyB64,
        did,
        mode: 'ddc-direct'
      });

      // Progress
      updateStep(1, 'completed');
      updateStep(2, 'active');
      document.getElementById('uploadBtn').disabled = false;

      log(`Wallet ready for direct DDC uploads: ${did}`, 'success');
    }
    
    // Step 2: Upload Health Data
    async function uploadHealthData() {
      log('Starting health data encryption...', 'crypto');
      
      state.healthData = SAMPLE_HEALTH_DATA;
      
      // Generate DEK (Data Encryption Key) - 32 bytes for AES-256
      state.dek = randomBytes(32);
      const dekB64 = nacl.util.encodeBase64(state.dek);
      log(`Generated DEK (AES-256): ${dekB64.slice(0, 20)}...`, 'crypto');
      
      // Encrypt health data with AES-256-GCM
      const jsonData = JSON.stringify(state.healthData);
      log(`Encrypting ${jsonData.length} bytes of health data...`, 'crypto');
      
      state.encryptedData = await encryptAES(jsonData, state.dek);
      log(`Encrypted: ${state.encryptedData.ciphertext.length} bytes ciphertext`, 'crypto');
      
      // Use default bucket
      state.bucketId = DDC_CONFIG.defaultBucket;
      log(`Target Bucket ID: ${state.bucketId}`, 'ddc');
      
      // Store to DDC directly via SDK
      let result;
      try {
        result = await ddcStorage.store(state.bucketId, state.encryptedData);
        state.dataCid = result.cid;
      } catch (err) {
        log(`Upload failed: ${err.message}`, 'error');
        // Show error in UI
        const uploadResultEl = document.getElementById('uploadResult');
        uploadResultEl.innerHTML = `
          <div class="kv-grid">
            <div class="kv-item">
              <div class="kv-content">
                <div class="kv-key" style="color: var(--error);">DDC Direct Upload Failed</div>
                <div class="kv-value" style="color: var(--error);">${escapeHtml(err.message)}</div>
              </div>
            </div>
            <div class="kv-item">
              <div class="kv-content">
                <div class="kv-key">Troubleshooting</div>
                <div class="kv-value">1. Make sure DDC SDK is loaded<br>2. Wallet needs CERE tokens for gas<br>3. Check browser console for details</div>
              </div>
            </div>
          </div>
          <button class="btn btn-secondary" onclick="uploadHealthData()" style="margin-top: 16px;">Retry Upload</button>
        `;
        uploadResultEl.style.display = 'block';
        return;
      }

      // Update UI
      document.getElementById('storageMode').textContent = 'Direct DDC SDK → Cere Mainnet';
      document.getElementById('bucketId').textContent = state.bucketId.toString();
      document.getElementById('dataCid').textContent = result.cid;
      document.getElementById('ddcUrl').textContent = result.cdnUrl;
      document.getElementById('dekDisplay').textContent = dekB64.slice(0, 24) + '... (keep secret!)';
      document.getElementById('encDetails').textContent =
        `AES-256-GCM | IV: ${state.encryptedData.iv.slice(0, 12)}... | ${state.encryptedData.ciphertext.length} bytes`;

      document.getElementById('uploadResult').style.display = 'block';
      
      // Audit
      await addAuditEntry('DATA_UPLOADED', {
        bucketId: state.bucketId.toString(),
        cid: result.cid,
        algorithm: 'AES-256-GCM',
        sizeBytes: state.encryptedData.ciphertext.length,
        storageMode: 'ddc-direct',
        cdnUrl: result.cdnUrl
      });
      
      // Progress
      updateStep(2, 'completed');
      updateStep(3, 'active');
      document.getElementById('grantBtn').disabled = false;
      
      log(`Health data encrypted and stored directly to DDC`, 'success');
    }
    
    // Step 3: Grant Permission
    async function grantPermission() {
      log('Creating capability token...', 'crypto');
      
      // Collect selected scopes
      const scopes = [];
      document.querySelectorAll('.scope-item.selected').forEach(item => {
        scopes.push({
          path: item.dataset.path + '/*',
          permissions: item.dataset.perms.split(',').map(p => p.trim())
        });
      });
      
      if (scopes.length === 0) {
        log('Error: No scopes selected!', 'error');
        return;
      }
      
      const expirySeconds = parseInt(document.getElementById('tokenExpiry').value);
      const expiresAt = Math.floor(Date.now() / 1000) + expirySeconds;
      
      // Wrap DEK for agent
      log('Wrapping DEK for agent (X25519 + XSalsa20-Poly1305)...', 'crypto');
      const wrappedDEK = wrapDEK(state.dek, state.agentKeyPair.publicKey);
      log(`DEK wrapped with ephemeral key: ${wrappedDEK.ephemeralPublicKey.slice(0, 20)}...`, 'crypto');
      
      // Create token payload
      const tokenId = nacl.util.encodeBase64(randomBytes(16));
      const tokenPayload = {
        v: 1,
        id: tokenId,
        iss: deriveDID(state.userKeyPair.publicKey),
        sub: nacl.util.encodeBase64(state.agentKeyPair.publicKey),
        iat: Math.floor(Date.now() / 1000),
        exp: expiresAt,
        scopes,
        bucketId: state.bucketId.toString(),
        resources: [state.dataCid],
        cdnUrl: `${DDC_CONFIG.cdnUrlAlt}/${state.bucketId}/${state.dataCid}`,
        wrappedDEK
      };
      
      // Sign token with Ed25519
      const payloadString = JSON.stringify(tokenPayload);
      const signature = signMessage(payloadString, state.userKeyPair.privateKey);
      log(`Token signed with Ed25519: ${signature.slice(0, 20)}...`, 'crypto');
      
      state.capabilityToken = {
        ...tokenPayload,
        sig: signature,
        sigAlg: 'Ed25519'
      };
      
      // Update UI
      document.getElementById('tokenDisplay').textContent = 
        JSON.stringify(state.capabilityToken, null, 2);
      document.getElementById('tokenId').textContent = tokenId;
      document.getElementById('wrappedDek').textContent = 
        `${wrappedDEK.ciphertext.slice(0, 30)}... (${wrappedDEK.ciphertext.length} bytes)`;
      document.getElementById('tokenResult').style.display = 'block';

      // Show revoke button
      const revokeBtn = document.getElementById('revokeBtn');
      revokeBtn.style.display = 'inline-flex';
      state.tokenRevoked = false;
      document.getElementById('revocationStatus').innerHTML =
        '<span class="revocation-status active">ACTIVE</span>';

      // Audit
      await addAuditEntry('TOKEN_CREATED', {
        tokenId,
        scopes: scopes.map(s => s.path),
        expiresAt: new Date(expiresAt * 1000).toISOString(),
        agentKey: nacl.util.encodeBase64(state.agentKeyPair.publicKey).slice(0, 20)
      });
      
      // Progress
      updateStep(3, 'completed');
      updateStep(4, 'active');
      document.getElementById('runAgentBtn').disabled = false;
      
      log('Capability token created and signed', 'success');
    }
    
    function copyToken() {
      navigator.clipboard.writeText(JSON.stringify(state.capabilityToken, null, 2));
      log('Token copied to clipboard', 'success');
    }
    
    // Export token + agent key for CLI usage
    function exportForCLI() {
      if (!state.capabilityToken || !state.agentKeyPair) {
        log('No token or agent key to export!', 'error');
        return;
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      
      // 1. Export capability token
      const tokenBlob = new Blob([JSON.stringify(state.capabilityToken, null, 2)], { type: 'application/json' });
      const tokenUrl = URL.createObjectURL(tokenBlob);
      const tokenLink = document.createElement('a');
      tokenLink.href = tokenUrl;
      tokenLink.download = `proofi-token-${timestamp}.json`;
      tokenLink.click();
      URL.revokeObjectURL(tokenUrl);
      
      // 2. Export agent private key
      const agentKeyExport = {
        type: 'proofi-agent-key-v1',
        algorithm: 'X25519',
        secretKey: nacl.util.encodeBase64(state.agentKeyPair.secretKey),
        publicKey: nacl.util.encodeBase64(state.agentKeyPair.publicKey),
        exportedAt: new Date().toISOString(),
        warning: 'Keep this file secure!'
      };
      
      const keyBlob = new Blob([JSON.stringify(agentKeyExport, null, 2)], { type: 'application/json' });
      const keyUrl = URL.createObjectURL(keyBlob);
      const keyLink = document.createElement('a');
      keyLink.href = keyUrl;
      keyLink.download = `proofi-agent-key-${timestamp}.json`;
      setTimeout(() => {
        keyLink.click();
        URL.revokeObjectURL(keyUrl);
      }, 500);
      
      log('Exported token + agent key for CLI usage', 'success');
    }
    
    // Step 4: Agent Execution
    async function runAgent() {
      log('Agent starting execution...', 'info');

      // Auto-open execution log
      document.getElementById('consolePanel').classList.add('open');

      document.getElementById('agentLoading').style.display = 'flex';
      document.getElementById('agentSteps').style.display = 'block';
      
      const token = state.capabilityToken;
      
      // Step 4.1: Validate signature
      await sleep(500);
      log('Agent: Validating token signature...', 'crypto');
      
      const payloadForVerify = { ...token };
      delete payloadForVerify.sig;
      delete payloadForVerify.sigAlg;
      const payloadString = JSON.stringify(payloadForVerify);
      
      const issuerPubKey = state.userKeyPair.publicKey;
      const isValidSig = verifySignature(payloadString, token.sig, issuerPubKey);
      
      if (!isValidSig) {
        log('Agent: SIGNATURE INVALID!', 'error');
        updateAgentStep(1, false, 'Signature invalid!');
        return;
      }
      
      updateAgentStep(1, true, 'Signature valid (Ed25519)');
      log('Agent: Signature verified', 'success');

      // Step 4.2: Check revocation, expiry & scopes
      await sleep(400);
      log('Agent: Checking revocation status...', 'info');

      const revStatus = await checkRevocationStatus(token.id);
      if (revStatus.revoked) {
        log('Agent: TOKEN REVOKED!', 'error');
        updateAgentStep(2, false, 'Token revoked!');
        await addAuditEntry('AGENT_REJECTED', { reason: 'token_revoked', tokenId: token.id });
        return;
      }
      log('Agent: Token not revoked', 'success');

      log('Agent: Checking expiry and scopes...', 'info');

      const now = Math.floor(Date.now() / 1000);
      if (token.exp < now) {
        log('Agent: TOKEN EXPIRED!', 'error');
        updateAgentStep(2, false, 'Token expired!');
        return;
      }
      
      const hasReadScope = token.scopes.some(s => 
        s.permissions.includes('read') && 
        (s.path.includes('health/sleep') || s.path.includes('health/heart'))
      );
      
      if (!hasReadScope) {
        log('Agent: INSUFFICIENT SCOPES!', 'error');
        updateAgentStep(2, false, 'No read permission!');
        return;
      }
      
      updateAgentStep(2, true, `Valid until ${new Date(token.exp * 1000).toLocaleString()}`);
      log(`Agent: Token valid for ${token.exp - now} more seconds`, 'success');
      
      // Step 4.3: Unwrap DEK
      await sleep(500);
      log('Agent: Unwrapping DEK with agent private key...', 'crypto');
      
      let unwrappedDEK;
      try {
        unwrappedDEK = unwrapDEK(token.wrappedDEK, state.agentKeyPair.secretKey);
        log(`Agent: DEK unwrapped successfully (${unwrappedDEK.length} bytes)`, 'success');
      } catch (err) {
        log(`Agent: DEK unwrap failed - ${err.message}`, 'error');
        updateAgentStep(3, false, 'DEK unwrap failed!');
        return;
      }
      
      updateAgentStep(3, true, `DEK recovered (${unwrappedDEK.length} bytes)`);
      
      // Step 4.4: Fetch & decrypt data
      await sleep(600);
      log(`Agent: Fetching data from DDC bucket ${token.bucketId}...`, 'ddc');
      
      let encryptedBlob;
      try {
        encryptedBlob = await ddcStorage.fetch(BigInt(token.bucketId), token.resources[0]);
      } catch (err) {
        log(`Agent: DDC fetch failed - ${err.message}`, 'error');
        updateAgentStep(4, false, 'Fetch failed!');
        return;
      }
      
      log('Agent: Decrypting with AES-256-GCM...', 'crypto');
      
      let healthData;
      try {
        const decrypted = await decryptAES(encryptedBlob.ciphertext, encryptedBlob.iv, unwrappedDEK);
        healthData = JSON.parse(decrypted);
        log(`Agent: Decrypted ${decrypted.length} bytes of health data`, 'success');
      } catch (err) {
        log(`Agent: Decryption failed - ${err.message}`, 'error');
        updateAgentStep(4, false, 'Decryption failed!');
        return;
      }
      
      // Filter data based on granted scopes
      const grantedPaths = token.scopes.map(s => s.path);
      const filteredData = { version: healthData.version, exportedAt: healthData.exportedAt };
      
      const hasSleepScope = grantedPaths.some(p => p.includes('health/sleep'));
      const hasHeartScope = grantedPaths.some(p => p.includes('health/heart'));
      
      if (hasSleepScope) {
        filteredData.sleep = healthData.sleep;
        log(`Agent: Sleep data access GRANTED (${healthData.sleep.length} records)`, 'success');
      } else {
        filteredData.sleep = [];
        log('Agent: Sleep data access DENIED by scope', 'warn');
      }
      
      if (hasHeartScope) {
        filteredData.heartRate = healthData.heartRate;
        log(`Agent: Heart rate access GRANTED (${healthData.heartRate.length} records)`, 'success');
      } else {
        filteredData.heartRate = [];
        log('Agent: Heart rate access DENIED by scope', 'warn');
      }
      
      const accessSummary = [
        hasSleepScope ? `${filteredData.sleep.length} sleep` : null,
        hasHeartScope ? `${filteredData.heartRate.length} HR` : null
      ].filter(Boolean).join(' + ') || 'No data (check scopes)';
      
      updateAgentStep(4, true, accessSummary);
      
      // Step 4.5: Run analysis
      await sleep(700);
      log('Agent: Running health analysis...', 'info');
      
      const analysis = analyzeHealthData(filteredData);
      
      updateAgentStep(5, true, 'Analysis complete!');
      log('Agent: Analysis complete!', 'success');
      
      // Audit
      await addAuditEntry('AGENT_EXECUTED', {
        tokenId: token.id,
        recordsAnalyzed: healthData.sleep.length + healthData.heartRate.length,
        analysisVersion: '1.0',
        fetchSource: 'ddc-direct'
      });
      
      await addAuditEntry('ANALYSIS_COMPLETE', {
        avgSleepHours: analysis.avgSleep.toFixed(2),
        avgHeartRate: analysis.avgHR,
        sleepScore: analysis.sleepScore,
        heartScore: analysis.heartScore
      });
      
      document.getElementById('agentLoading').style.display = 'none';
      
      // Store results and show step 5
      state.analysisResults = analysis;
      await showResults(analysis);
      
      updateStep(4, 'completed');
      updateStep(5, 'active');
    }
    
    function updateAgentStep(stepNum, success, message) {
      const step = document.getElementById(`agentStep${stepNum}`);
      const value = step.querySelector('.kv-value');

      value.textContent = message;
      value.className = 'kv-value ' + (success ? 'success' : '');
    }
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // Health Analysis
    function analyzeHealthData(data) {
      const hasSleep = data.sleep && data.sleep.length > 0;
      const hasHeart = data.heartRate && data.heartRate.length > 0;
      
      let avgSleep = null, avgQuality = null, avgDeep = null, avgRem = null, sleepScore = null;
      if (hasSleep) {
        const sleepDurations = data.sleep.map(s => s.duration);
        const sleepQualities = data.sleep.map(s => s.quality);
        const deepSleep = data.sleep.map(s => s.deep);
        const remSleep = data.sleep.map(s => s.rem);
        
        avgSleep = sleepDurations.reduce((a, b) => a + b, 0) / sleepDurations.length;
        avgQuality = sleepQualities.reduce((a, b) => a + b, 0) / sleepQualities.length;
        avgDeep = deepSleep.reduce((a, b) => a + b, 0) / deepSleep.length;
        avgRem = remSleep.reduce((a, b) => a + b, 0) / remSleep.length;
        sleepScore = Math.round((avgQuality * 0.4) + ((avgSleep / 8) * 60 * 0.3) + ((avgDeep / 2) * 50 * 0.3));
      }
      
      let avgHR = null, avgRestingHR = null, avgHRV = null, maxHR = null, minHR = null, heartScore = null;
      if (hasHeart) {
        const heartRates = data.heartRate.map(h => h.bpm);
        const restingHR = data.heartRate.filter(h => h.context === 'resting').map(h => h.bpm);
        const variability = data.heartRate.map(h => h.variability);
        
        avgHR = Math.round(heartRates.reduce((a, b) => a + b, 0) / heartRates.length);
        avgRestingHR = restingHR.length > 0 
          ? Math.round(restingHR.reduce((a, b) => a + b, 0) / restingHR.length)
          : avgHR;
        avgHRV = Math.round(variability.reduce((a, b) => a + b, 0) / variability.length);
        maxHR = Math.max(...heartRates);
        minHR = Math.min(...heartRates);
        heartScore = Math.round(100 - Math.abs(avgRestingHR - 65) - (avgHRV < 30 ? 20 : 0));
      }
      
      const recommendations = [];
      if (hasSleep) {
        if (avgSleep < 7) recommendations.push('Try to get at least 7 hours of sleep');
        if (avgDeep < 1.5) recommendations.push('Your deep sleep is low — avoid caffeine after 2pm');
      }
      if (hasHeart) {
        if (avgRestingHR > 75) recommendations.push('Consider more cardio to lower resting heart rate');
        if (avgHRV < 30) recommendations.push('Low HRV detected — try stress reduction techniques');
      }
      if (!hasSleep && !hasHeart) {
        recommendations.push('No data available — check your scope permissions');
      } else if (recommendations.length === 0) {
        recommendations.push('Great job — your health metrics look excellent.');
      }
      
      if (!hasSleep) recommendations.push('Sleep data: not shared (scope denied)');
      if (!hasHeart) recommendations.push('Heart rate: not shared (scope denied)');
      
      return {
        avgSleep,
        avgQuality,
        avgDeep,
        avgRem,
        avgHR,
        avgRestingHR,
        avgHRV,
        maxHR,
        minHR,
        sleepScore,
        heartScore,
        recommendations,
        recordsAnalyzed: (data.sleep?.length || 0) + (data.heartRate?.length || 0),
        scopeInfo: { sleepGranted: hasSleep, heartGranted: hasHeart }
      };
    }
    
    // Step 5: Results
    async function showResults(analysis) {
      // Trust Chain Visual Summary
      const trustChainHtml = `
        <div class="trust-chain">
          <div class="trust-chain-title">Trust Chain</div>
          <div class="trust-chain-flow">
            <div class="trust-chain-node">
              <span class="tc-label">User Wallet</span>
              <span class="tc-detail">Ed25519 + X25519</span>
            </div>
            <div class="trust-chain-arrow">
              <span class="tc-arrow-line">→</span>
              <span class="tc-arrow-label">sign</span>
            </div>
            <div class="trust-chain-node">
              <span class="tc-label">Encrypted Data</span>
              <span class="tc-detail">AES-256-GCM + CID</span>
            </div>
            <div class="trust-chain-arrow">
              <span class="tc-arrow-line">→</span>
              <span class="tc-arrow-label">direct</span>
            </div>
            <div class="trust-chain-node">
              <span class="tc-label">DDC SDK</span>
              <span class="tc-detail">Wallet signs tx</span>
            </div>
            <div class="trust-chain-arrow">
              <span class="tc-arrow-line">→</span>
              <span class="tc-arrow-label">store</span>
            </div>
            <div class="trust-chain-node">
              <span class="tc-label">DDC Mainnet</span>
              <span class="tc-detail">Bucket ${state.bucketId || '1229'}</span>
            </div>
          </div>
        </div>
      `;

      // Analysis cards
      const resultsHtml = `
        <div class="analysis-card">
          <div class="analysis-value ${analysis.sleepScore >= 75 ? 'good' : analysis.sleepScore >= 50 ? 'warning' : 'bad'}">${analysis.sleepScore}</div>
          <div class="analysis-label">Sleep Score</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value ${analysis.heartScore >= 80 ? 'good' : analysis.heartScore >= 60 ? 'warning' : 'bad'}">${analysis.heartScore}</div>
          <div class="analysis-label">Heart Score</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.avgSleep.toFixed(1)}h</div>
          <div class="analysis-label">Avg Sleep</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.avgRestingHR}</div>
          <div class="analysis-label">Resting BPM</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.avgHRV}ms</div>
          <div class="analysis-label">Avg HRV</div>
        </div>
        <div class="analysis-card">
          <div class="analysis-value">${analysis.recordsAnalyzed}</div>
          <div class="analysis-label">Records Analyzed</div>
        </div>
      `;

      const analysisResultsEl = document.getElementById('analysisResults');
      analysisResultsEl.insertAdjacentHTML('beforebegin', trustChainHtml);
      analysisResultsEl.innerHTML = resultsHtml;

      // Recommendations
      document.getElementById('recommendations').innerHTML =
        '<pre>' + analysis.recommendations.map(r => escapeHtml(r)).join('\n') + '</pre>';

      // Audit log
      const auditHtml = state.auditLog.map(entry => `
        <div class="audit-entry">
          <div class="audit-time">${new Date(entry.timestamp).toLocaleTimeString()}</div>
          <div class="audit-action">${entry.action}</div>
          <div class="audit-hash" title="${entry.hash}">${entry.hash.slice(0, 12)}...</div>
        </div>
      `).join('');
      document.getElementById('auditLog').innerHTML = auditHtml;

      // Verification details
      let verifyHtml = `
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">Token Signature:</span>
          <span class="verify-value">Ed25519 verified</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">Data CID:</span>
          <span class="verify-value">${state.dataCid.slice(0, 30)}...</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">Storage:</span>
          <span class="verify-value">Direct DDC SDK (Bucket ${state.bucketId})</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot ${state.tokenRevoked ? 'fail' : 'pass'}"></span>
          <span class="verify-label">Token Status:</span>
          <span class="verify-value">${state.tokenRevoked ? '<span class="revocation-status revoked">REVOKED</span>' : '<span class="revocation-status active">ACTIVE</span>'}</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">Hash Chain:</span>
          <span class="verify-value">${state.auditLog.length} entries, valid</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">Encryption:</span>
          <span class="verify-value">AES-256-GCM + X25519</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">Final Hash:</span>
          <span class="verify-value">${state.lastHash}</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">CDN URL:</span>
          <span class="verify-value" style="font-size: 10px;">${DDC_CONFIG.cdnUrlAlt}/${state.bucketId}/${state.dataCid}</span>
        </div>
        <div class="verify-item">
          <span class="verify-dot pass"></span>
          <span class="verify-label">Upload Method:</span>
          <span class="verify-value">Direct DDC SDK (no API proxy)</span>
        </div>
      `;

      document.getElementById('verifyGrid').innerHTML = verifyHtml;

      // Sovereignty Seal
      const elapsed = state.auditLog.length > 0
        ? ((Date.now() - state.auditLog[0].timestamp) / 1000).toFixed(1)
        : '—';
      const sealHtml = `
        <div class="sovereignty-seal">
          <div class="seal-content">
            <div class="seal-shield"><svg viewBox="0 0 24 24" fill="none" width="28" height="28"><path d="M12 2L3 7v5c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-9-5z" fill="currentColor" opacity="0.3"/><path d="M10 15.5l-3.5-3.5 1.41-1.41L10 12.67l5.59-5.59L17 8.5l-7 7z" fill="currentColor"/></svg></div>
            <div class="seal-title">Proof of Data Sovereignty</div>
            <div class="seal-subtitle">All cryptographic operations verified. Your data never left your control.</div>
            <div class="seal-facts">
              <div class="seal-fact">
                <div class="sf-value">${state.auditLog.length}</div>
                <div class="sf-label">Audit Entries</div>
              </div>
              <div class="seal-fact">
                <div class="sf-value">AES-256</div>
                <div class="sf-label">Encryption</div>
              </div>
              <div class="seal-fact">
                <div class="sf-value">Ed25519</div>
                <div class="sf-label">Signatures</div>
              </div>
              <div class="seal-fact">
                <div class="sf-value">${elapsed}s</div>
                <div class="sf-label">Total Time</div>
              </div>
            </div>
            <div class="seal-hash">Final hash: ${state.lastHash}</div>
          </div>
        </div>
      `;
      document.getElementById('verifyGrid').insertAdjacentHTML('afterend', sealHtml);

      updateStep(5, 'completed');
      log('Demo complete! All uploads went DIRECTLY to DDC.', 'success');
    }
    
    function downloadAuditLog() {
      const auditData = {
        version: '1.0',
        demo: 'proofi-health-analyzer',
        network: 'cere-mainnet',
        uploadMethod: 'direct-ddc-sdk',
        exportedAt: new Date().toISOString(),
        storageMode: 'ddc-direct',
        bucketId: state.bucketId?.toString(),
        dataCid: state.dataCid,
        cdnUrl: `${DDC_CONFIG.cdnUrlAlt}/${state.bucketId}/${state.dataCid}`,
        explorerUrl: 'https://explorer.cere.network/',
        entries: state.auditLog,
        verification: {
          algorithm: 'SHA-256',
          chainValid: true,
          finalHash: state.lastHash
        }
      };
      
      const blob = new Blob([JSON.stringify(auditData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `proofi-audit-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      log('Audit log downloaded', 'success');
    }
    
    function restartDemo() {
      location.reload();
    }

    // ========================================
    // TOKEN REVOCATION
    // ========================================

    async function revokeToken() {
      if (!state.capabilityToken || state.tokenRevoked) return;

      const token = state.capabilityToken;
      log('Revoking token ' + token.id + '...', 'warn');

      // Create signed revocation entry
      const revocation = {
        type: 'REVOCATION',
        tokenId: token.id,
        revokedAt: Math.floor(Date.now() / 1000),
        revokedBy: nacl.util.encodeBase64(state.userKeyPair.publicKey),
        reason: 'user_initiated'
      };

      // Sign the revocation with user's Ed25519 key
      const revocationString = JSON.stringify(revocation);
      const revSig = signMessage(revocationString, state.userKeyPair.privateKey);
      revocation.sig = revSig;

      // Store revocation on DDC directly
      if (state.ddcClient) {
        try {
          const { File: DdcFile } = window.CereDdcSdk;
          const dataBuffer = new TextEncoder().encode(JSON.stringify(revocation));
          const file = new DdcFile(dataBuffer, { contentType: 'application/json' });
          const uri = await state.ddcClient.store(state.bucketId, file);
          state.revocationCid = uri.cid;
          log(`Revocation stored on DDC: ${uri.cid}`, 'success');
        } catch (e) {
          log('DDC revocation storage failed: ' + e.message, 'warn');
        }
      }

      state.tokenRevoked = true;

      // Update UI
      const btn = document.getElementById('revokeBtn');
      btn.textContent = 'Token Revoked';
      btn.classList.add('revoked');
      btn.disabled = true;

      document.getElementById('revocationStatus').innerHTML =
        '<span class="revocation-status revoked">REVOKED</span>';

      // Audit
      await addAuditEntry('TOKEN_REVOKED', {
        tokenId: token.id,
        revocationCid: state.revocationCid || 'local-only'
      });

      log('Token revoked successfully', 'success');
    }

    async function checkRevocationStatus(tokenId) {
      if (state.tokenRevoked && state.capabilityToken?.id === tokenId) {
        return { revoked: true, source: 'memory' };
      }
      return { revoked: false };
    }

    // ========================================
    // PUBLIC CID VERIFIER
    // ========================================

    async function publicVerify() {
      const cidInput = document.getElementById('verifyCidInput');
      const bucketInput = document.getElementById('verifyBucketInput');
      const resultEl = document.getElementById('verifierResult');

      const cid = cidInput.value.trim();
      const bucket = bucketInput.value.trim() || '1229';

      if (!cid) {
        resultEl.innerHTML = '<div class="vr-header"><span class="vr-status not-found">Please enter a CID</span></div>';
        resultEl.classList.add('visible');
        return;
      }

      resultEl.innerHTML = '<div class="vr-header"><span class="vr-status">Verifying...</span></div>';
      resultEl.classList.add('visible');

      log(`Public verify: checking CID ${cid} in bucket ${bucket}`, 'ddc');

      const cdnUrl = `${DDC_CONFIG.cdnUrlAlt}/${bucket}/${cid}`;

      try {
        const response = await fetch(cdnUrl);

        if (!response.ok) {
          resultEl.innerHTML = `
            <div class="vr-header">
              <span class="vr-status not-found">Not Found</span>
            </div>
            <div class="verifier-detail">
              <span class="vd-label">CID</span>
              <span class="vd-value">${escapeHtml(cid.slice(0, 40))}${cid.length > 40 ? '...' : ''}</span>
            </div>
            <div class="verifier-detail">
              <span class="vd-label">Bucket</span>
              <span class="vd-value">${escapeHtml(bucket)}</span>
            </div>
            <div class="verifier-detail">
              <span class="vd-label">Status</span>
              <span class="vd-value">HTTP ${response.status} — Content not found on DDC</span>
            </div>
          `;
          log('Public verify: CID not found on DDC', 'warn');
          return;
        }

        const contentType = response.headers.get('content-type') || 'unknown';
        const contentLength = response.headers.get('content-length') || '—';
        const text = await response.text();
        const classification = classifyData(text);

        let dataPreview = text.slice(0, 200);
        if (text.length > 200) dataPreview += '...';

        resultEl.innerHTML = `
          <div class="vr-header">
            <span class="vr-status verified">Verified on DDC</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">CID</span>
            <span class="vd-value">${escapeHtml(cid.slice(0, 40))}${cid.length > 40 ? '...' : ''}</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Bucket</span>
            <span class="vd-value">${escapeHtml(bucket)}</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Size</span>
            <span class="vd-value">${contentLength} bytes</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Content Type</span>
            <span class="vd-value">${escapeHtml(contentType)}</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Classification</span>
            <div class="data-classes">${classification.map(c => `<span class="data-class-tag">${escapeHtml(c)}</span>`).join('')}</div>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">CDN URL</span>
            <span class="vd-value"><a href="${cdnUrl}" target="_blank" rel="noopener" style="color: var(--blue);">${escapeHtml(cdnUrl)}</a></span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Preview</span>
            <span class="vd-value" style="max-width: 400px; word-break: break-all;">${escapeHtml(dataPreview)}</span>
          </div>
        `;

        log(`Public verify: CID verified on DDC (${contentLength} bytes, ${classification.join(', ')})`, 'success');

      } catch (err) {
        resultEl.innerHTML = `
          <div class="vr-header">
            <span class="vr-status not-found">Verification Failed</span>
          </div>
          <div class="verifier-detail">
            <span class="vd-label">Error</span>
            <span class="vd-value">${escapeHtml(err.message)}</span>
          </div>
        `;
        log('Public verify failed: ' + err.message, 'error');
      }
    }

    function classifyData(text) {
      const classes = [];

      try {
        const parsed = JSON.parse(text);
        classes.push('JSON');

        if (parsed.to && parsed.subject && parsed.body) {
          classes.push('DDC-MEMO');
          try {
            const inner = JSON.parse(parsed.body);
            if (inner.ciphertext || inner.iv) classes.push('ENCRYPTED');
            if (inner.type === 'REVOCATION') classes.push('REVOCATION');
          } catch {}
        }

        if (parsed.ciphertext && parsed.iv) classes.push('ENCRYPTED');
        if (parsed.iss && parsed.sub && parsed.scopes) classes.push('CAPABILITY-TOKEN');
        if (parsed.sleep || parsed.heartRate) classes.push('HEALTH-DATA');
        if (parsed.type === 'REVOCATION') classes.push('REVOCATION');

      } catch {
        if (text.startsWith('-----BEGIN')) classes.push('PEM-KEY');
        else if (text.length > 100 && !/\s/.test(text.slice(0, 50))) classes.push('BINARY/ENCODED');
        else classes.push('PLAINTEXT');
      }

      if (classes.length === 0) classes.push('UNKNOWN');
      return classes;
    }

    // Auto-verify from URL params
    (function checkUrlVerify() {
      const params = new URLSearchParams(window.location.search);
      const cid = params.get('verify');
      const bucket = params.get('bucket');
      if (cid) {
        document.getElementById('verifyCidInput').value = cid;
        if (bucket) document.getElementById('verifyBucketInput').value = bucket;
        setTimeout(() => {
          document.getElementById('publicVerifier').scrollIntoView({ behavior: 'smooth' });
          publicVerify();
        }, 1000);
      }
    })();
  </script>
</body>
</html>