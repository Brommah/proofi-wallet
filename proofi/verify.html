<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proofi Verify — Public Proof Verification</title>
  <meta name="description" content="Verify any Proofi proof publicly. Check hash integrity, HMAC-SHA256 signatures, and timestamp validity — no wallet required.">
  <meta property="og:title" content="Proofi Verify — Public Proof Verification">
  <meta property="og:description" content="Verify any Proofi proof publicly. No wallet required.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://proofi-virid.vercel.app/verify">
  <meta property="og:image" content="https://proofi-virid.vercel.app/og-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Proofi Verify">
  <meta name="twitter:description" content="Public proof verification on Cere Network.">
  <meta name="twitter:image" content="https://proofi-virid.vercel.app/og-image.png">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='0' fill='%230A0A0F'/%3E%3Cpath d='M16 4L28 16L16 28L4 16Z' fill='none' stroke='%2300E5FF' stroke-width='2'/%3E%3Cpath d='M16 10L22 16L16 22L10 16Z' fill='%2300E5FF' opacity='0.6'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* ========================================
       PROOFI VERIFY — PUBLIC PROOF VERIFIER
       ======================================== */

    :root {
      --bg: #0A0A0F;
      --bg-elevated: #101018;
      --surface: #16161F;
      --surface-hover: #1C1C28;
      --border: #252535;
      --border-strong: #3A3A50;
      --text: #E4E4F0;
      --text-dim: #8A8AA0;
      --text-muted: #555568;
      --cyan: #00E5FF;
      --green: #00FF88;
      --magenta: #FF3366;
      --amber: #F59E0B;
      --cyan-glow: rgba(0, 229, 255, 0.15);
      --cyan-glow-strong: rgba(0, 229, 255, 0.35);
      --green-glow: rgba(0, 255, 136, 0.12);
      --magenta-glow: rgba(255, 51, 102, 0.12);
      --amber-glow: rgba(245, 158, 11, 0.12);
    }

    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :focus-visible {
      outline: 2px solid #00E5FF;
      outline-offset: 2px;
    }

    .skip-to-content {
      position: absolute;
      top: -100%;
      left: 16px;
      z-index: 999;
      padding: 12px 24px;
      background: var(--cyan);
      color: #000;
      font-weight: 700;
      text-decoration: none;
      border-radius: 0 0 4px 4px;
    }
    .skip-to-content:focus {
      top: 0;
    }
    html { scroll-behavior: smooth; }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
      min-height: 100vh;
    }

    ::selection {
      background: var(--cyan);
      color: var(--bg);
    }

    /* === GRID BACKGROUND === */
    .grid-bg {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      background-image:
        linear-gradient(rgba(0, 229, 255, 0.025) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 229, 255, 0.025) 1px, transparent 1px);
      background-size: 60px 60px;
    }

    .grid-bg::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at 50% 0%, transparent 0%, var(--bg) 70%);
    }

    /* === SCANLINE === */
    .scanline {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, transparent, var(--cyan-glow), transparent);
      opacity: 0.4;
      z-index: 9999;
      pointer-events: none;
      animation: scan 8s linear infinite;
    }

    @keyframes scan {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100vh); }
    }

    /* === ANIMATIONS === */
    .reveal {
      opacity: 0;
      transform: translateY(24px);
      transition: opacity 0.6s cubic-bezier(0.16, 1, 0.3, 1),
                  transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
    }
    .reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }
    .reveal-d1 { transition-delay: 0.1s; }
    .reveal-d2 { transition-delay: 0.2s; }
    .reveal-d3 { transition-delay: 0.3s; }

    @keyframes pulse-glow {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    @keyframes spin-slow {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* === NAV === */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: rgba(10, 10, 15, 0.9);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid var(--border);
    }

    .nav-inner {
      max-width: 800px;
      margin: 0 auto;
      padding: 0 24px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .nav-brand {
      display: flex;
      align-items: center;
      gap: 12px;
      text-decoration: none;
      color: var(--text);
    }

    .nav-logo {
      width: 28px;
      height: 28px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .nav-logo::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border: 2px solid var(--cyan);
      transform: rotate(45deg);
    }

    .nav-logo::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 6px;
      background: var(--cyan);
      box-shadow: 0 0 10px var(--cyan);
    }

    .nav-name {
      font-family: 'Orbitron', sans-serif;
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .nav-name .accent { color: var(--cyan); }

    .nav-links {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .nav-links a {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-dim);
      text-decoration: none;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      transition: color 0.2s;
    }

    .nav-links a:hover { color: var(--cyan); }

    .nav-cta {
      padding: 8px 18px !important;
      border: 1px solid var(--cyan) !important;
      color: var(--cyan) !important;
      transition: all 0.2s !important;
    }

    .nav-cta:hover {
      background: var(--cyan) !important;
      color: var(--bg) !important;
    }

    /* === CONTAINER === */
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 0 24px;
      position: relative;
      z-index: 1;
    }

    /* === HERO === */
    .hero {
      text-align: center;
      padding: 120px 0 48px;
    }

    .hero-badge {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 18px;
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 28px;
    }

    .hero-badge .pulse {
      width: 6px;
      height: 6px;
      background: var(--green);
      box-shadow: 0 0 8px var(--green);
      animation: pulse-glow 2s ease-in-out infinite;
    }

    .hero h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(32px, 5vw, 48px);
      font-weight: 900;
      letter-spacing: -0.5px;
      line-height: 1.15;
      margin-bottom: 16px;
      text-transform: uppercase;
    }

    .hero h1 .glow {
      color: var(--cyan);
      text-shadow: 0 0 30px var(--cyan-glow-strong), 0 0 60px var(--cyan-glow);
    }

    .hero-desc {
      font-size: 16px;
      color: var(--text-dim);
      line-height: 1.7;
      max-width: 520px;
      margin: 0 auto;
      font-weight: 300;
    }

    .hero-desc strong {
      color: var(--text);
      font-weight: 600;
    }

    /* === SHIELD ICON (CSS) === */
    .shield-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      margin-bottom: 24px;
      position: relative;
    }

    .shield-icon::before {
      content: '';
      position: absolute;
      width: 44px;
      height: 44px;
      border: 2px solid var(--cyan);
      transform: rotate(45deg);
      box-shadow: 0 0 20px var(--cyan-glow);
    }

    .shield-icon::after {
      content: '';
      position: absolute;
      width: 14px;
      height: 14px;
      background: var(--cyan);
      box-shadow: 0 0 24px var(--cyan), 0 0 48px var(--cyan-glow);
    }

    /* === INPUT CARD === */
    .verify-card {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      margin-bottom: 24px;
      overflow: hidden;
    }

    .card-header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .card-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--cyan);
    }

    .card-subtitle {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1.5px;
    }

    .card-body {
      padding: 24px;
    }

    /* === INPUT AREA === */
    .input-wrapper {
      position: relative;
    }

    .verify-input {
      width: 100%;
      min-height: 120px;
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 16px 50px 16px 16px;
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      line-height: 1.7;
      resize: vertical;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .verify-input:focus {
      border-color: var(--cyan);
      box-shadow: 0 0 20px var(--cyan-glow);
    }

    .verify-input::placeholder {
      color: var(--text-muted);
      font-family: 'JetBrains Mono', monospace;
    }

    .paste-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: var(--surface-hover);
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      padding: 6px 12px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.15s;
    }

    .paste-btn:hover {
      border-color: var(--cyan);
      color: var(--cyan);
    }

    .input-hint {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 8px;
      letter-spacing: 0.5px;
    }

    /* === DROP ZONE === */
    .drop-zone {
      border: 2px dashed var(--border);
      padding: 28px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: 16px;
      position: relative;
    }

    .drop-zone:hover, .drop-zone.dragover {
      border-color: var(--cyan);
      background: rgba(0, 229, 255, 0.03);
    }

    .drop-zone input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .drop-icon {
      font-size: 24px;
      margin-bottom: 8px;
      opacity: 0.6;
    }

    .drop-title {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 4px;
    }

    .drop-subtitle {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* === SEPARATOR === */
    .or-divider {
      display: flex;
      align-items: center;
      gap: 16px;
      margin: 16px 0;
    }

    .or-divider::before, .or-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
    }

    .or-divider span {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* === VERIFY BUTTON === */
    .verify-actions {
      padding: 16px 24px;
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
      text-decoration: none;
    }

    .btn-primary {
      background: var(--cyan);
      color: var(--bg);
      border: 2px solid var(--cyan);
      padding: 12px 28px;
    }

    .btn-primary:hover {
      background: transparent;
      color: var(--cyan);
      box-shadow: 0 0 24px var(--cyan-glow), inset 0 0 24px var(--cyan-glow);
    }

    .btn-primary:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .btn-primary:disabled:hover {
      background: var(--cyan);
      color: var(--bg);
      box-shadow: none;
    }

    .btn-ghost {
      background: transparent;
      color: var(--text-dim);
      border: 1px solid var(--border);
      padding: 10px 20px;
    }

    .btn-ghost:hover {
      color: var(--text);
      border-color: var(--text-dim);
    }

    .btn-sm {
      font-size: 10px;
      padding: 8px 16px;
      letter-spacing: 1.5px;
    }

    .no-wallet-note {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* === LOADING SPINNER === */
    .spinner-overlay {
      display: none;
      padding: 48px 24px;
      text-align: center;
    }

    .spinner-overlay.active { display: block; }

    .spinner {
      width: 40px;
      height: 40px;
      border: 2px solid var(--border);
      border-top-color: var(--cyan);
      border-radius: 50%;
      animation: spin-slow 0.8s linear infinite;
      margin: 0 auto 16px;
    }

    .spinner-text {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--text-dim);
      letter-spacing: 1px;
    }

    /* === RESULTS === */
    .result-card {
      display: none;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      margin-bottom: 24px;
      overflow: hidden;
      animation: fadeUp 0.4s ease forwards;
    }

    .result-card.show { display: block; }

    /* Status header */
    .result-status {
      padding: 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      border-bottom: 1px solid var(--border);
    }

    .status-icon {
      width: 52px;
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      flex-shrink: 0;
      position: relative;
    }

    .status-icon::before {
      content: '';
      position: absolute;
      inset: 0;
      border: 2px solid;
      transform: rotate(45deg);
    }

    .result-card.verified .status-icon::before {
      border-color: var(--green);
      box-shadow: 0 0 16px var(--green-glow);
    }

    .result-card.invalid .status-icon::before {
      border-color: var(--magenta);
      box-shadow: 0 0 16px var(--magenta-glow);
    }

    .result-card.partial .status-icon::before {
      border-color: var(--amber);
      box-shadow: 0 0 16px var(--amber-glow);
    }

    .result-card.notfound .status-icon::before {
      border-color: var(--text-muted);
    }

    .status-text h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .result-card.verified .status-text h2 { color: var(--green); }
    .result-card.invalid .status-text h2 { color: var(--magenta); }
    .result-card.partial .status-text h2 { color: var(--amber); }
    .result-card.notfound .status-text h2 { color: var(--text-dim); }

    .status-text p {
      font-size: 13px;
      color: var(--text-dim);
      margin-top: 4px;
    }

    /* Check items */
    .check-list {
      padding: 0 24px;
    }

    .check-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 0;
      border-bottom: 1px solid var(--border);
      font-size: 13px;
    }

    .check-item:last-child { border-bottom: none; }

    .check-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      font-weight: 700;
      flex-shrink: 0;
      border: 1px solid;
    }

    .check-icon.pass {
      color: var(--green);
      border-color: var(--green);
    }

    .check-icon.fail {
      color: var(--magenta);
      border-color: var(--magenta);
    }

    .check-icon.warn {
      color: var(--amber);
      border-color: var(--amber);
    }

    .check-icon.na {
      color: var(--text-muted);
      border-color: var(--text-muted);
    }

    .check-label {
      flex: 1;
      color: var(--text-dim);
    }

    .check-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
    }

    .check-value.pass { color: var(--green); }
    .check-value.fail { color: var(--magenta); }
    .check-value.warn { color: var(--amber); }

    /* Metadata table */
    .meta-section {
      border-top: 1px solid var(--border);
    }

    .meta-header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
    }

    .meta-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 3px;
      color: var(--cyan);
    }

    .meta-table {
      width: 100%;
    }

    .meta-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 12px 24px;
      border-bottom: 1px solid var(--border);
      gap: 16px;
      transition: background 0.15s;
    }

    .meta-row:last-child { border-bottom: none; }
    .meta-row:hover { background: var(--surface); }

    .meta-key {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      white-space: nowrap;
      flex-shrink: 0;
      padding-top: 2px;
    }

    .meta-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text-dim);
      text-align: right;
      word-break: break-all;
      line-height: 1.5;
    }

    .meta-value.mono { font-size: 11px; }

    .meta-value .tag {
      display: inline-block;
      padding: 2px 8px;
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .meta-value .tag-green {
      background: var(--green-glow);
      color: var(--green);
      border: 1px solid rgba(0, 255, 136, 0.3);
    }

    .meta-value .tag-red {
      background: var(--magenta-glow);
      color: var(--magenta);
      border: 1px solid rgba(255, 51, 102, 0.3);
    }

    .meta-value .tag-amber {
      background: var(--amber-glow);
      color: var(--amber);
      border: 1px solid rgba(245, 158, 11, 0.3);
    }

    .meta-value .tag-dim {
      background: rgba(85, 85, 104, 0.15);
      color: var(--text-muted);
      border: 1px solid var(--border);
    }

    /* Result actions */
    .result-actions {
      padding: 16px 24px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    /* === FOOTER === */
    footer {
      border-top: 1px solid var(--border);
      margin-top: 48px;
    }

    .footer-inner {
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 20px;
    }

    .footer-brand {
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .footer-brand .accent { color: var(--cyan); }

    .footer-links {
      display: flex;
      align-items: center;
      gap: 24px;
    }

    .footer-links a {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: var(--text-muted);
      text-decoration: none;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      transition: color 0.2s;
    }

    .footer-links a:hover { color: var(--cyan); }

    .footer-cta {
      padding: 8px 18px;
      border: 1px solid var(--cyan);
      color: var(--cyan) !important;
      font-weight: 600 !important;
      transition: all 0.2s;
    }

    .footer-cta:hover {
      background: var(--cyan);
      color: var(--bg) !important;
    }

    /* === TOAST === */
    .toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      opacity: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 10px 24px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text);
      z-index: 999;
      pointer-events: none;
      transition: opacity 0.2s, transform 0.2s;
      max-width: 90vw;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }

    /* === RESPONSIVE === */
    @media (max-width: 768px) {
      .hero { padding: 100px 0 32px; }
      .hero h1 { font-size: 28px; }
      .hero-desc { font-size: 14px; }
      .nav-links a:not(.nav-cta) { display: none; }
      .card-header { flex-direction: column; gap: 4px; align-items: flex-start; }
      .meta-row { flex-direction: column; gap: 4px; }
      .meta-value { text-align: left; }
      .verify-actions { flex-direction: column; gap: 12px; }
      .footer-inner { flex-direction: column; text-align: center; }
      .footer-links { flex-wrap: wrap; justify-content: center; }
      .result-status { flex-direction: column; text-align: center; }
    }

    @media (max-width: 480px) {
      .container { padding: 0 16px; }
      .card-body { padding: 16px; }
      .meta-row { padding: 10px 16px; }
      .check-list { padding: 0 16px; }
      .result-actions { padding: 12px 16px; }
    }
  </style>
</head>
<body>
<a class="skip-to-content" href="#main-content">Skip to content</a>


  <!-- Grid background -->
  <div class="grid-bg"></div>

  <!-- Scanline -->
  <div class="scanline"></div>

  <!-- Nav -->
  <nav role="navigation">
    <div class="nav-inner">
      <a href="/" class="nav-brand">
        <div class="nav-logo"></div>
        <div class="nav-name">PROOF<span class="accent">I</span></div>
      </a>
      <div class="nav-links">
        <a href="/ecosystem">Ecosystem</a>
        <a href="/proofstamp">ProofStamp</a>
        <a href="/app" class="nav-cta">Launch App</a>
      </div>
    </div>
  </nav>

  <div id="main-content" class="container">

    <!-- Hero -->
    <section class="hero reveal">
      <div class="shield-icon"></div>
      <div class="hero-badge">
        <span class="pulse"></span>
        Public Verification
      </div>
      <h1>PROOFI <span class="glow">VERIFY</span></h1>
      <p class="hero-desc">
        Verify any Proofi proof <strong>without a wallet</strong>.
        Paste a proof hash, CID, or full proof JSON to check integrity,
        signatures, and timestamps.
      </p>
    </section>

    <!-- Input Card -->
    <div class="verify-card reveal reveal-d1" id="inputCard">
      <div class="card-header">
        <span class="card-title">Verify Proof</span>
        <span class="card-subtitle">No wallet required</span>
      </div>
      <div class="card-body">
        <div class="input-wrapper">
          <textarea
            class="verify-input"
            id="verifyInput"
            placeholder="Paste a proof hash (SHA-256), CID, or full proof JSON..."
            spellcheck="false"
          ></textarea>
          <button aria-label="Close" class="paste-btn" onclick="pasteFromClipboard()" title="Paste from clipboard">Paste</button>
        </div>
        <div class="input-hint">
          Accepts: SHA-256 hash / CID / Proof JSON / ProofStamp Certificate
        </div>

        <div class="or-divider">
          <span>or</span>
        </div>

        <div class="drop-zone" id="dropZone">
          <input type="file" id="fileInput" accept=".json,.txt" onchange="handleFileDrop(this.files[0])">
          <div class="drop-icon">&#9744;</div>
          <div class="drop-title">Drop a proof JSON file</div>
          <div class="drop-subtitle">Drag a .json proof file here to verify</div>
        </div>
      </div>
      <div class="verify-actions">
        <span class="no-wallet-note">
          &#9670; No wallet connection needed
        </span>
        <button aria-label="Close" class="btn btn-primary" id="verifyBtn" onclick="runVerification()" disabled>
          Verify Proof
        </button>
      </div>
    </div>

    <!-- Loading -->
    <div role="dialog" aria-modal="true" class="spinner-overlay" id="loadingSpinner">
      <div class="spinner"></div>
      <div class="spinner-text" id="spinnerText">Verifying proof...</div>
    </div>

    <!-- Results -->
    <div class="result-card" id="resultCard">
      <!-- Status header (injected by JS) -->
      <div class="result-status" id="resultStatus"></div>

      <!-- Check items -->
      <div class="check-list" id="checkList"></div>

      <!-- Metadata -->
      <div class="meta-section" id="metaSection">
        <div class="meta-header">
          <span class="meta-title">Proof Metadata</span>
        </div>
        <div class="meta-table" id="metaTable"></div>
      </div>

      <!-- Actions -->
      <div class="result-actions" id="resultActions"></div>
    </div>

  </div>

  <!-- Footer -->
  <footer role="contentinfo">
    <div class="footer-inner">
      <div class="footer-brand">PROOF<span class="accent">I</span> VERIFY</div>
      <div class="footer-links">
        <a href="/">proofi.ai</a>
        <a href="/proofstamp">ProofStamp</a>
        <a href="/ecosystem">Ecosystem</a>
        <a href="/app" class="footer-cta">Create your own proofs</a>
      </div>
    </div>
  </footer>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <script>
    // ============================================
    // PROOFI VERIFY — Public Proof Verification
    // ============================================

    const API_URL = 'https://proofi-api-production.up.railway.app';
    const inputEl = document.getElementById('verifyInput');
    const verifyBtn = document.getElementById('verifyBtn');

    // -- Init --
    function init() {
      // Check URL params
      const params = new URLSearchParams(window.location.search);
      const hash = params.get('hash');
      const cid = params.get('cid');

      if (hash) {
        inputEl.value = hash;
        updateVerifyBtn();
        setTimeout(() => runVerification(), 400);
      } else if (cid) {
        inputEl.value = cid;
        updateVerifyBtn();
        setTimeout(() => runVerification(), 400);
      }

      // Input listener
      inputEl.addEventListener('input', updateVerifyBtn);

      // Drag & drop
      const dz = document.getElementById('dropZone');
      dz.addEventListener('dragover', (e) => { e.preventDefault(); dz.classList.add('dragover'); });
      dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
      dz.addEventListener('drop', (e) => {
        e.preventDefault();
        dz.classList.remove('dragover');
        if (e.dataTransfer.files.length) handleFileDrop(e.dataTransfer.files[0]);
      });

      // Trigger reveal animations
      requestAnimationFrame(() => {
        setTimeout(() => {
          document.querySelectorAll('.reveal').forEach(el => el.classList.add('visible'));
        }, 100);
      });
    }

    function updateVerifyBtn() {
      verifyBtn.disabled = !inputEl.value.trim();
    }

    // -- Paste --
    async function pasteFromClipboard() {
      try {
        const text = await navigator.clipboard.readText();
        inputEl.value = text;
        updateVerifyBtn();
        showToast('Pasted from clipboard');
      } catch {
        showToast('Could not access clipboard');
      }
    }

    // -- File drop --
    function handleFileDrop(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        inputEl.value = e.target.result;
        updateVerifyBtn();
        showToast('File loaded: ' + file.name);
      };
      reader.readAsText(file);
    }

    // -- Input detection --
    function detectInputType(raw) {
      const trimmed = raw.trim();

      // Try JSON parse
      try {
        const obj = JSON.parse(trimmed);
        if (typeof obj === 'object' && obj !== null) {
          return { type: 'json', data: obj };
        }
      } catch {}

      // Try parsing ProofStamp certificate text format
      if (trimmed.includes('ProofStamp Certificate') || trimmed.includes('Hash (SHA-256):')) {
        const parsed = parseProofCertificate(trimmed);
        if (parsed) return { type: 'json', data: parsed };
      }

      // CID detection (starts with baf, Qm, or ddc_/local_)
      if (/^(baf[a-z2-7]+|Qm[A-Za-z0-9]+|ddc_[a-z0-9]+|local_[a-z0-9]+)$/i.test(trimmed)) {
        return { type: 'cid', data: trimmed };
      }

      // SHA-256 hash (64 hex chars)
      if (/^[a-fA-F0-9]{64}$/.test(trimmed)) {
        return { type: 'hash', data: trimmed };
      }

      // Generic hex string (could be shorter hash)
      if (/^[a-fA-F0-9]{16,}$/.test(trimmed)) {
        return { type: 'hash', data: trimmed };
      }

      // Anything else, treat as unknown
      return { type: 'unknown', data: trimmed };
    }

    // Parse text-based ProofStamp certificate
    function parseProofCertificate(text) {
      const extract = (label) => {
        const regex = new RegExp(label + ':\\s*(.+)', 'i');
        const match = text.match(regex);
        return match ? match[1].trim() : null;
      };

      const hash = extract('Hash \\(SHA-256\\)') || extract('Hash');
      if (!hash) return null;

      return {
        hash: hash,
        label: extract('Label'),
        isoTime: extract('Timestamp'),
        wallet: extract('Wallet'),
        nonce: extract('Nonce'),
        signature: extract('Signature \\(HMAC-SHA256\\)') || extract('Signature'),
        contentType: (extract('Content') || '').split(' ')[0] || null,
        cid: (extract('Storage') || '').replace('Cere DDC', '').replace(/[^a-zA-Z0-9_]/g, '').trim() || null,
        algorithm: extract('Algorithm') || 'SHA-256',
      };
    }

    // -- Main verification --
    async function runVerification() {
      const raw = inputEl.value.trim();
      if (!raw) return;

      const input = detectInputType(raw);
      showLoading(true);

      try {
        switch (input.type) {
          case 'json':
            await verifyProofJSON(input.data);
            break;
          case 'cid':
            await verifyCID(input.data);
            break;
          case 'hash':
            await verifyHash(input.data);
            break;
          default:
            showResult('notfound', 'Unrecognized Input', 'Could not determine input type. Paste a SHA-256 hash, CID, or proof JSON.', [], []);
        }
      } catch (err) {
        showResult('invalid', 'Verification Error', err.message, [], []);
      }

      showLoading(false);
    }

    // -- Verify full proof JSON --
    async function verifyProofJSON(proof) {
      const checks = [];
      let overallStatus = 'verified';

      // 1. Check structure
      const hasHash = !!proof.hash;
      const hasTimestamp = !!(proof.timestamp || proof.isoTime);
      const hasWallet = !!proof.wallet;
      const hasSignature = !!proof.signature;
      const hasNonce = !!proof.nonce;

      checks.push({
        label: 'Proof structure',
        status: hasHash ? 'pass' : 'fail',
        value: hasHash ? 'Valid (hash present)' : 'Invalid (no hash)',
      });

      if (!hasHash) {
        overallStatus = 'invalid';
      }

      // 2. Hash format
      if (hasHash) {
        const validHashFormat = /^[a-fA-F0-9]{64}$/.test(proof.hash);
        checks.push({
          label: 'Hash format (SHA-256)',
          status: validHashFormat ? 'pass' : 'warn',
          value: validHashFormat ? '64-char hex valid' : 'Non-standard format',
        });
        if (!validHashFormat) overallStatus = overallStatus === 'verified' ? 'partial' : overallStatus;
      }

      // 3. Timestamp
      if (hasTimestamp) {
        const ts = proof.timestamp || Date.parse(proof.isoTime);
        const tsDate = new Date(ts);
        const validTs = !isNaN(tsDate.getTime()) && tsDate.getFullYear() >= 2020;
        checks.push({
          label: 'Timestamp validity',
          status: validTs ? 'pass' : 'fail',
          value: validTs ? tsDate.toISOString() : 'Invalid timestamp',
        });
        if (!validTs) overallStatus = overallStatus === 'verified' ? 'partial' : overallStatus;
      } else {
        checks.push({
          label: 'Timestamp',
          status: 'warn',
          value: 'Not present',
        });
        overallStatus = overallStatus === 'verified' ? 'partial' : overallStatus;
      }

      // 4. Wallet address
      if (hasWallet) {
        const validWallet = proof.wallet.length >= 10;
        checks.push({
          label: 'Wallet address',
          status: validWallet ? 'pass' : 'warn',
          value: validWallet ? truncate(proof.wallet, 20) : 'Suspicious format',
        });
      } else {
        checks.push({
          label: 'Wallet address',
          status: 'warn',
          value: 'Not present',
        });
        overallStatus = overallStatus === 'verified' ? 'partial' : overallStatus;
      }

      // 5. HMAC-SHA256 signature verification
      if (hasSignature && hasNonce && hasWallet && hasHash) {
        try {
          const timestamp = proof.timestamp || Date.parse(proof.isoTime);
          const canonical = JSON.stringify({
            hash: proof.hash,
            timestamp: timestamp,
            wallet: proof.wallet,
            nonce: proof.nonce,
            algorithm: proof.algorithm || 'SHA-256',
          });

          const sigValid = await verifyHMAC(canonical, proof.signature, proof.wallet);

          checks.push({
            label: 'HMAC-SHA256 signature',
            status: sigValid ? 'pass' : 'fail',
            value: sigValid ? 'Signature VALID' : 'Signature INVALID - may be tampered',
          });

          if (!sigValid) overallStatus = 'invalid';
        } catch (e) {
          checks.push({
            label: 'HMAC-SHA256 signature',
            status: 'warn',
            value: 'Verification error: ' + e.message,
          });
          overallStatus = overallStatus === 'verified' ? 'partial' : overallStatus;
        }
      } else if (hasSignature) {
        checks.push({
          label: 'Signature',
          status: 'warn',
          value: 'Present but missing nonce/wallet for verification',
        });
        overallStatus = overallStatus === 'verified' ? 'partial' : overallStatus;
      } else {
        checks.push({
          label: 'Signature',
          status: 'warn',
          value: 'Not present (legacy proof)',
        });
        overallStatus = overallStatus === 'verified' ? 'partial' : overallStatus;
      }

      // 6. Nonce
      if (hasNonce) {
        checks.push({
          label: 'Nonce (replay protection)',
          status: 'pass',
          value: truncate(proof.nonce, 20),
        });
      }

      // Build metadata
      const meta = buildMetadata(proof);

      // Status text
      const statusMap = {
        verified: { title: 'VERIFIED', desc: 'All checks passed. This proof is cryptographically valid.' },
        partial: { title: 'PARTIAL', desc: 'Some checks could not be completed. The proof may be valid but is missing data.' },
        invalid: { title: 'INVALID', desc: 'One or more critical checks failed. This proof may have been tampered with.' },
      };

      const status = statusMap[overallStatus];
      showResult(overallStatus, status.title, status.desc, checks, meta, proof);
    }

    // -- Verify CID --
    async function verifyCID(cid) {
      showSpinnerText('Looking up CID on Proofi network...');

      try {
        // Try fetching from API
        const res = await fetchWithTimeout(`${API_URL}/game/achievements/${cid}`, 8000);
        if (res.ok) {
          const data = await res.json();
          if (data && data.achievements && data.achievements.length > 0) {
            // Found achievements linked to this CID
            const proof = data.achievements[0].data || data.achievements[0];
            await verifyProofJSON(proof);
            return;
          }
        }
      } catch {}

      // CID lookup failed
      showResult('notfound', 'CID NOT FOUND',
        'Could not resolve this CID on the Proofi network. The proof may exist on IPFS or Cere DDC but is not indexed.',
        [
          { label: 'CID lookup', status: 'na', value: 'Not found in Proofi index' },
          { label: 'Network query', status: 'na', value: 'API returned no results' },
        ],
        [
          { key: 'CID', value: cid },
          { key: 'Network', value: 'Cere DDC / Proofi API' },
          { key: 'Status', value: '<span class="tag tag-dim">Not indexed</span>' },
        ]
      );
    }

    // -- Verify hash --
    async function verifyHash(hash) {
      showSpinnerText('Searching for proof with hash...');

      // 1. Check local proofstamp storage
      const localProof = searchLocalProofs(hash);
      if (localProof) {
        await verifyProofJSON(localProof);
        return;
      }

      // 2. Try API lookup
      try {
        const res = await fetchWithTimeout(`${API_URL}/game/achievements/${hash}`, 8000);
        if (res.ok) {
          const data = await res.json();
          if (data && data.achievements && data.achievements.length > 0) {
            const proof = data.achievements[0].data || data.achievements[0];
            await verifyProofJSON(proof);
            return;
          }
        }
      } catch {}

      // 3. Hash not found
      const isValidSHA256 = /^[a-fA-F0-9]{64}$/.test(hash);
      showResult('notfound', 'HASH NOT FOUND',
        'This hash was not found in the Proofi network or local storage. It may have been created on a different device or not yet stored.',
        [
          { label: 'Hash format', status: isValidSHA256 ? 'pass' : 'warn', value: isValidSHA256 ? 'Valid SHA-256 (64 hex)' : 'Non-standard format' },
          { label: 'Local storage', status: 'na', value: 'Not found' },
          { label: 'Network lookup', status: 'na', value: 'Not found in Proofi index' },
        ],
        [
          { key: 'Hash', value: hash },
          { key: 'Algorithm', value: isValidSHA256 ? 'SHA-256' : 'Unknown' },
          { key: 'Status', value: '<span class="tag tag-dim">Not found</span>' },
        ]
      );
    }

    // -- Search local proofstamp storage --
    function searchLocalProofs(hash) {
      try {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('proofstamp_')) {
            const items = JSON.parse(localStorage.getItem(key) || '[]');
            if (Array.isArray(items)) {
              const found = items.find(p => p.hash === hash);
              if (found) return found;
            }
          }
        }
      } catch {}
      return null;
    }

    // -- HMAC-SHA256 verification --
    async function verifyHMAC(canonical, signature, walletAddr) {
      const encoder = new TextEncoder();
      const key = await crypto.subtle.importKey(
        'raw',
        encoder.encode(walletAddr),
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['verify']
      );
      const sigBytes = new Uint8Array(signature.match(/.{2}/g).map(b => parseInt(b, 16)));
      return crypto.subtle.verify('HMAC', key, sigBytes, encoder.encode(canonical));
    }

    // -- Build metadata array from proof object --
    function buildMetadata(proof) {
      const meta = [];

      if (proof.hash) {
        meta.push({ key: 'Hash (SHA-256)', value: proof.hash });
      }

      if (proof.timestamp || proof.isoTime) {
        const ts = proof.isoTime || new Date(proof.timestamp).toISOString();
        const relative = timeAgo(proof.timestamp || Date.parse(proof.isoTime));
        meta.push({ key: 'Timestamp', value: ts + ' (' + relative + ')' });
      }

      if (proof.wallet) {
        meta.push({ key: 'Wallet', value: proof.wallet });
      }

      if (proof.nonce) {
        meta.push({ key: 'Nonce', value: proof.nonce });
      }

      if (proof.signature) {
        meta.push({ key: 'Signature', value: proof.signature });
      }

      if (proof.label) {
        meta.push({ key: 'Label', value: escapeHtml(proof.label) });
      }

      if (proof.contentType) {
        const sizeStr = proof.size ? ' / ' + formatSize(proof.size) : '';
        meta.push({ key: 'Content', value: escapeHtml(proof.contentType) + sizeStr });
      }

      if (proof.cid) {
        meta.push({ key: 'Storage CID', value: proof.cid });
      }

      if (proof.algorithm) {
        meta.push({ key: 'Algorithm', value: proof.algorithm + ' + HMAC-SHA256' });
      }

      if (proof.version) {
        meta.push({ key: 'Version', value: proof.version });
      }

      return meta;
    }

    // -- Display result --
    function showResult(status, title, desc, checks, meta, proofObj = null) {
      const card = document.getElementById('resultCard');
      card.className = 'result-card show ' + status;

      // Status header
      const iconMap = {
        verified: '&#10003;',
        invalid: '&#10007;',
        partial: '!',
        notfound: '?',
      };

      document.getElementById('resultStatus').innerHTML = `
        <div class="status-icon">${iconMap[status] || '?'}</div>
        <div class="status-text">
          <h2>${escapeHtml(title)}</h2>
          <p>${escapeHtml(desc)}</p>
        </div>
      `;

      // Checks
      const checkListEl = document.getElementById('checkList');
      if (checks.length > 0) {
        checkListEl.innerHTML = checks.map(c => `
          <div class="check-item">
            <div class="check-icon ${c.status}">${c.status === 'pass' ? '&#10003;' : c.status === 'fail' ? '&#10007;' : c.status === 'warn' ? '!' : '-'}</div>
            <span class="check-label">${escapeHtml(c.label)}</span>
            <span class="check-value ${c.status}">${escapeHtml(c.value)}</span>
          </div>
        `).join('');
        checkListEl.style.display = 'block';
      } else {
        checkListEl.style.display = 'none';
      }

      // Metadata
      const metaSection = document.getElementById('metaSection');
      const metaTable = document.getElementById('metaTable');
      if (meta.length > 0) {
        metaTable.innerHTML = meta.map(m => `
          <div class="meta-row">
            <span class="meta-key">${escapeHtml(m.key)}</span>
            <span class="meta-value mono">${m.value}</span>
          </div>
        `).join('');
        metaSection.style.display = 'block';
      } else {
        metaSection.style.display = 'none';
      }

      // Actions
      const actionsEl = document.getElementById('resultActions');
      let actionsHTML = `
        <button aria-label="Close" class="btn btn-ghost btn-sm" onclick="resetVerifier()">Verify Another</button>
      `;

      if (proofObj) {
        actionsHTML += `
          <button class="btn btn-ghost btn-sm" onclick="copyProofJSON()">Copy JSON</button>
          <button class="btn btn-ghost btn-sm" onclick="downloadProof()">Download Proof</button>
        `;
      }

      if (status === 'notfound') {
        actionsHTML += `
          <a href="/proofstamp" class="btn btn-ghost btn-sm">Create a Proof</a>
        `;
      }

      actionsEl.innerHTML = actionsHTML;

      // Store for copy/download
      window._lastVerifiedProof = proofObj;

      // Scroll into view
      card.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    // -- Loading --
    function showLoading(show) {
      document.getElementById('loadingSpinner').classList.toggle('active', show);
      document.getElementById('resultCard').classList.toggle('show', false);
      if (!show) document.getElementById('resultCard').classList.remove('show');
    }

    function showSpinnerText(text) {
      document.getElementById('spinnerText').textContent = text;
    }

    // -- Reset --
    function resetVerifier() {
      inputEl.value = '';
      updateVerifyBtn();
      document.getElementById('resultCard').className = 'result-card';
      inputEl.focus();
      // Clear URL params
      if (window.history.replaceState) {
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    }

    // -- Copy JSON --
    function copyProofJSON() {
      if (!window._lastVerifiedProof) return;
      const text = JSON.stringify(window._lastVerifiedProof, null, 2);
      navigator.clipboard.writeText(text).then(() => {
        showToast('Proof JSON copied to clipboard');
      }).catch(() => {
        showToast('Could not copy to clipboard');
      });
    }

    // -- Download --
    function downloadProof() {
      if (!window._lastVerifiedProof) return;
      const proof = window._lastVerifiedProof;
      const blob = new Blob([JSON.stringify(proof, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'proofi-proof-' + (proof.hash || 'unknown').slice(0, 8) + '.json';
      a.click();
      URL.revokeObjectURL(url);
      showToast('Proof downloaded');
    }

    // -- Helpers --
    function truncate(str, len) {
      if (!str) return '';
      if (str.length <= len) return str;
      return str.slice(0, len / 2) + '...' + str.slice(-(len / 2));
    }

    function escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function formatSize(bytes) {
      if (!bytes || bytes === 0) return '0 B';
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function timeAgo(ts) {
      if (!ts) return '';
      const diff = Date.now() - ts;
      const mins = Math.floor(diff / 60000);
      if (mins < 0) return 'in the future';
      if (mins < 1) return 'just now';
      if (mins < 60) return mins + 'm ago';
      const hrs = Math.floor(mins / 60);
      if (hrs < 24) return hrs + 'h ago';
      const days = Math.floor(hrs / 24);
      if (days < 30) return days + 'd ago';
      const months = Math.floor(days / 30);
      if (months < 12) return months + 'mo ago';
      return Math.floor(months / 12) + 'y ago';
    }

    async function fetchWithTimeout(url, timeoutMs) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const res = await fetch(url, { signal: controller.signal });
        clearTimeout(id);
        return res;
      } catch (err) {
        clearTimeout(id);
        throw err;
      }
    }

    let toastTimeout;
    function showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.className = 'toast show';
      clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => t.className = 'toast', 3000);
    }

    // -- Keyboard shortcut --
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
        runVerification();
      }
    });

    // -- Boot --
    init();
  </script>
</body>
</html>
